---
title: q1339. Maximum Product of Splitted Binary Tree / 分裂二元樹的最大乘積
note_type: knowledge
domain: leetcode
tags: [leetcode, knowledge]
created: 2026-02-03
updated: 2026-02-03
status: active
source: leetcode
difficulty: Medium
complexity_time: O(n)
complexity_space: O(h)
review_interval_days: 14
next_review: 2026-02-17
---
# q1339. Maximum Product of Splitted Binary Tree / 分裂二元樹的最大乘積
[1339. Maximum Product of Splitted Binary Tree](https://leetcode.com/problems/maximum-product-of-splitted-binary-tree/)

Medium

Topics

![premium lock icon](https://leetcode.com/_next/static/images/lock-a6627e2c7fa0ce8bc117c109fb4e567d.svg)Companies

Hint

Given the `root` of a binary tree, split the binary tree into two subtrees by removing one edge such that the product of the sums of the subtrees is maximized.
給定二元樹的 `root`，移除一條邊把樹分成兩棵子樹，使兩子樹總和乘積最大。

Return the maximum product of the sums of the two subtrees. Since the answer may be too large, return it **modulo** `10^9 + 7`.
回傳兩子樹總和乘積的最大值，若太大則回傳 `10^9 + 7` 取模後的值。

**Note** that you need to maximize the answer before taking the mod and not after taking it.
**注意** 需先在原始數值上取最大，再取模。

**Example 1:**

![](https://assets.leetcode.com/uploads/2020/01/21/sample_1_1699.png)

**Input:** root = [1,2,3,4,5,6]
**Output:** 110
**Explanation:** Remove the red edge and get 2 binary trees with sum 11 and 10. Their product is 110 (11*10)
**解釋：**移除紅色邊後得到總和為 11 與 10 的兩棵樹，乘積為 110 (11*10)。

**Example 2:**

![](https://assets.leetcode.com/uploads/2020/01/21/sample_2_1699.png)

**Input:** root = [1,null,2,3,4,null,null,5,6]
**Output:** 90
**Explanation:** Remove the red edge and get 2 binary trees with sum 15 and 6. Their product is 90 (15*6)
**解釋：**移除紅色邊後得到總和為 15 與 6 的兩棵樹，乘積為 90 (15*6)。

**Constraints:**

- The number of nodes in the tree is in the range `2 <= n <= 5 * 10^4`.
- `1 <= Node.val <= 10^4`
- 節點數量範圍為 `2 <= n <= 5 * 10^4`。
- `1 <= Node.val <= 10^4`。

## 解題筆記與程式碼

通用演算法筆記：[tree_postorder_subtree_sum](../algorithm/tree_postorder_subtree_sum.md)
資料結構筆記：[binary_tree](../data_structure/binary_tree.md)

### 思路拆解

- 移除一條邊等價於選一個子樹，設其總和為 `s`，另一棵的總和就是 `total - s`。
- 目標是最大化 `s * (total - s)`，所以只要枚舉每個節點的子樹總和即可。
- 子樹總和需要由子節點往上累加，最自然的方式是後序 DFS。

### 為什麼要先算總和

- 乘積需要 `total - s`，必須先知道全樹總和，才能在每個子樹時計算補樹總和。

### 演算法

1. 先做一次後序 DFS 計算整棵樹的總和 `total`。
2. 再做一次後序 DFS：回傳每個節點的子樹總和 `s`，並更新最大值 `s * (total - s)`。
3. 最終回傳最大值對 `1_000_000_007` 取模。

### 時間與空間

- 時間：`O(n)`。
- 空間：`O(h)` 遞迴堆疊，`h` 為樹高。

```rust
// Definition for a binary tree node.
// #[derive(Debug, PartialEq, Eq)]
// pub struct TreeNode {
// pub val: i32,
// pub left: Option<Rc<RefCell<TreeNode>>>,
// pub right: Option<Rc<RefCell<TreeNode>>>,
// }
//
// impl TreeNode {
// #[inline]
// pub fn new(val: i32) -> Self {
// TreeNode {
// val,
// left: None,
// right: None
// }
// }
// }
use std::rc::Rc;
use std::cell::RefCell;
impl Solution {
	pub fn max_product(root: Option<Rc<RefCell<TreeNode>>>) -> i32 {
		const MOD: i128 = 1_000_000_007;

		fn sum_tree(node: &Option<Rc<RefCell<TreeNode>>>) -> i64 {
			if let Some(rc) = node {
				let (left, right, val) = {
					let n = rc.borrow();
					(n.left.clone(), n.right.clone(), n.val as i64)
				};
				val + sum_tree(&left) + sum_tree(&right)
			} else {
				0
			}
		}

		fn dfs(node: &Option<Rc<RefCell<TreeNode>>>, total: i64, best: &mut i128) -> i64 {
			if let Some(rc) = node {
				let (left, right, val) = {
					let n = rc.borrow();
					(n.left.clone(), n.right.clone(), n.val as i64)
				};
				let left_sum = dfs(&left, total, best);
				let right_sum = dfs(&right, total, best);
				let sub_sum = left_sum + right_sum + val;
				let product = (sub_sum as i128) * ((total - sub_sum) as i128);
				if product > *best {
					*best = product;
				}
				sub_sum
			} else {
				0
			}
		}

		let total = sum_tree(&root);
		let mut best: i128 = 0;
		dfs(&root, total, &mut best);
		(best % MOD) as i32
	}
}
```

## 實作細節

- 使用 `i128` 計算乘積，避免中間值溢位。
- 對 `Rc<RefCell<TreeNode>>` 先取出 `left/right/val`，避免借用衝突。
