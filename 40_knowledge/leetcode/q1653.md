---
title: q1653. Minimum Deletions to Make String Balanced / 使字串平衡的最少刪除次數
note_type: knowledge
domain: leetcode
tags: [leetcode, knowledge]
created: 2026-02-07
updated: 2026-02-07
status: active
source: leetcode
complexity_time: O(n)
complexity_space: O(n)
review_interval_days: 14
next_review: 2026-02-21
---
# q1653. Minimum Deletions to Make String Balanced / 使字串平衡的最少刪除次數
[1653. Minimum Deletions to Make String Balanced](https://leetcode.com/problems/minimum-deletions-to-make-string-balanced/)

Medium

Topics

![premium lock icon](https://leetcode.com/_next/static/images/lock-a6627e2c7fa0ce8bc117c109fb4e567d.svg)Companies

Hint

You are given a string `s` consisting only of characters `'a'` and `'b'`.
給定一個字串 `s`，只包含字元 `'a'` 與 `'b'`。

You can delete any number of characters in `s` to make `s` balanced.
你可以刪除 `s` 中任意數量的字元，讓 `s` 變成 balanced。

`s` is balanced if there is no pair of indices `(i, j)` such that `i < j` and `s[i] = 'b'` and `s[j] = 'a'`.
balanced 的定義是：不存在任何索引對 `(i, j)` 滿足 `i < j` 且 `s[i] = 'b'`、`s[j] = 'a'`。

Return the minimum number of deletions needed to make `s` balanced.
請回傳讓 `s` 成為 balanced 所需的最少刪除次數。

**Example 1:**

**Input:** s = "aababbab"  
**Output:** 2  
**Explanation:** You can either:
**說明：** 你可以使用以下任一方式：
- Delete the characters at 0-indexed positions 2 and 6 (`"aababbab"` -> `"aaabbb"`), or
- 刪除 0-indexed 的第 2 與第 6 個字元（`"aababbab"` -> `"aaabbb"`），或
- Delete the characters at 0-indexed positions 3 and 6 (`"aababbab"` -> `"aabbbb"`).
- 刪除 0-indexed 的第 3 與第 6 個字元（`"aababbab"` -> `"aabbbb"`）。

**Example 2:**

**Input:** s = "bbaaaaabb"  
**Output:** 2  
**Explanation:** The only solution is to delete the first two characters.
**說明：** 唯一解法是刪除前兩個字元。

**Constraints:**

- `1 <= s.length <= 10^5`
- `s[i]` is `'a'` or `'b'`.
- `1 <= s.length <= 10^5`。
- `s[i]` 只會是 `'a'` 或 `'b'`。

## 解題筆記與程式碼

通用演算法筆記：[prefix_suffix_penalty_scan](../algorithm/prefix_suffix_penalty_scan.md)  
通用資料結構筆記：[prefix_suffix_count_array](../data_structure/prefix_suffix_count_array.md)

### 思路拆解

- balanced 字串不能出現 `b ... a` 的逆序，因此刪完後的字串可視為 `a* + b*`。
- 設定切點 `j`（左側保留 `a`，右側保留 `b`）後：
  - 左側 `[0, j)` 中所有 `'b'` 都必須刪掉。
  - 右側 `[j, n)` 中所有 `'a'` 都必須刪掉。
- 因此刪除成本可寫成：
  - `cost(j) = prefixB[j] + suffixA[j]`
- 只要線性掃描所有 `j`，取最小成本即可。

### 演算法

1. 建立 `prefixB`，`prefixB[i + 1]` 代表 `s[0..i]` 中 `'b'` 的個數。
2. 建立 `suffixA`，`suffixA[i]` 代表 `s[i..n-1]` 中 `'a'` 的個數。
3. 掃描 `j = 0..=n`，計算 `prefixB[j] + suffixA[j]`，維護最小值。
4. 回傳最小值。

### 時間與空間

- 時間：`O(n)`。
- 空間：`O(n)`（兩個計數陣列）。

```rust
impl Solution {
    pub fn minimum_deletions(s: String) -> i32 {
        let bytes = s.as_bytes();
        let n = bytes.len();

        let mut prefix_b = vec![0i32; n + 1];
        for i in 0..n {
            prefix_b[i + 1] = prefix_b[i] + if bytes[i] == b'b' { 1 } else { 0 };
        }

        let mut suffix_a = vec![0i32; n + 1];
        for i in (0..n).rev() {
            suffix_a[i] = suffix_a[i + 1] + if bytes[i] == b'a' { 1 } else { 0 };
        }

        let mut ans = i32::MAX;
        for j in 0..=n {
            let deletions = prefix_b[j] + suffix_a[j];
            if deletions < ans {
                ans = deletions;
            }
        }

        ans
    }
}
```

### 實作細節

- 切點 `j` 是「左閉右開」分界：左側是 `[0, j)`，右側是 `[j, n)`。
- `prefix` / `suffix` 陣列長度使用 `n + 1` 可以自然處理 `j = 0` 與 `j = n`。
