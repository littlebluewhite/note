---
title: q840. Magic Squares In Grid / 矩陣中的幻方
note_type: knowledge
domain: leetcode
tags: [leetcode, knowledge]
created: 2026-02-03
updated: 2026-02-03
status: active
source: leetcode
complexity_time: O(row * col)
complexity_space: O(1)
review_interval_days: 14
next_review: 2026-02-17
---
# q840. Magic Squares In Grid / 矩陣中的幻方
[840. Magic Squares In Grid](https://leetcode.com/problems/magic-squares-in-grid/)

Medium

Topics

![premium lock icon](https://leetcode.com/_next/static/images/lock-a6627e2c7fa0ce8bc117c109fb4e567d.svg)Companies

A `3 x 3` **magic square** is a `3 x 3` grid filled with distinct numbers **from** 1 **to** 9 such that each row, column, and both diagonals all have the same sum.
`3 x 3` **魔術方陣** 是一個 `3 x 3` 方格，填入 **1 到 9** 互異的數字，使得每一列、每一欄與兩條對角線的總和都相同。

Given a `row x col` `grid` of integers, how many `3 x 3` magic square subgrids are there?
給定 `row x col` 的整數矩陣 `grid`，請問其中有多少個 `3 x 3` 的魔術方陣子矩陣？

Note: while a magic square can only contain numbers from 1 to 9, `grid` may contain numbers up to 15.
注意：魔術方陣只能包含 1 到 9，但 `grid` 的數值可能到 15。

**Example 1:**

![](https://assets.leetcode.com/uploads/2020/09/11/magic_main.jpg)

**Input:** grid = [ [4,3,8,4],[9,5,1,9],[2,7,6,2] ]
**Output:** 1
**Explanation:** 
The following subgrid is a 3 x 3 magic square:
下面這個子矩陣是一個 3 x 3 魔術方陣：
![](https://assets.leetcode.com/uploads/2020/09/11/magic_valid.jpg)
while this one is not:
而這個不是：
![](https://assets.leetcode.com/uploads/2020/09/11/magic_invalid.jpg)
In total, there is only one magic square inside the given grid.
所以總共有 1 個魔術方陣。

**Example 2:**

**Input:** grid = [ [8] ]
**Output:** 0

**Constraints:**

- `row == grid.length`
- `col == grid[i].length`
- `1 <= row, col <= 10`
- `0 <= grid[i][j] <= 15`
- `row == grid.length`
- `col == grid[i].length`
- `1 <= row, col <= 10`
- `0 <= grid[i][j] <= 15`

## 解題筆記與程式碼

通用演算法筆記：[fixed_size_subgrid_scan](../algorithm/fixed_size_subgrid_scan.md)
資料結構筆記：[presence_array](../data_structure/presence_array.md)

### 思路拆解

- 用固定尺寸掃描：只要列舉每個 `3 x 3` 子矩陣即可。
- `3 x 3` 魔術方陣必須含有 1..9 各一次，所以先檢查範圍與是否重複。
- `3 x 3` 且數字是 1..9 時，中心必為 5（總和 45、每列 15），可當作快速剪枝。
- 最後比對三列、三欄與兩條對角線總和是否相同。

### 演算法

1. 若 `row < 3` 或 `col < 3`，回傳 0。
2. 逐一枚舉每個左上角 `(r, c)`，檢查對應的 `3 x 3` 是否為魔術方陣。
3. 子矩陣檢查流程：
   - 中心不是 5 直接失敗。
   - 用 `seen[1..9]` 檢查數字合法且無重複。
   - 設定第一列和為 `target`，比對其它列、欄與兩條對角線。
4. 統計通過的數量。

### 時間與空間

- 時間：`O(row * col)`（每個視窗固定 9 格檢查）。
- 空間：`O(1)`（固定大小的 `seen` 陣列）。

```rust
fn is_magic(grid: &Vec<Vec<i32>>, r: usize, c: usize) -> bool {
    if grid[r + 1][c + 1] != 5 {
        return false;
    }

    let mut seen = [false; 10];
    for i in 0..3 {
        for j in 0..3 {
            let v = grid[r + i][c + j];
            if v < 1 || v > 9 {
                return false;
            }
            let idx = v as usize;
            if seen[idx] {
                return false;
            }
            seen[idx] = true;
        }
    }

    let target = grid[r][c] + grid[r][c + 1] + grid[r][c + 2];
    for i in 0..3 {
        let row_sum = grid[r + i][c] + grid[r + i][c + 1] + grid[r + i][c + 2];
        if row_sum != target {
            return false;
        }
    }
    for j in 0..3 {
        let col_sum = grid[r][c + j] + grid[r + 1][c + j] + grid[r + 2][c + j];
        if col_sum != target {
            return false;
        }
    }
    let diag1 = grid[r][c] + grid[r + 1][c + 1] + grid[r + 2][c + 2];
    if diag1 != target {
        return false;
    }
    let diag2 = grid[r][c + 2] + grid[r + 1][c + 1] + grid[r + 2][c];
    if diag2 != target {
        return false;
    }
    true
}

impl Solution {
    pub fn num_magic_squares_inside(grid: Vec<Vec<i32>>) -> i32 {
        let rows = grid.len();
        let cols = grid[0].len();
        if rows < 3 || cols < 3 {
            return 0;
        }

        let mut count = 0;
        for r in 0..=rows - 3 {
            for c in 0..=cols - 3 {
                if is_magic(&grid, r, c) {
                    count += 1;
                }
            }
        }
        count
    }
}
```
