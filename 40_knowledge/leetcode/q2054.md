---
title: q2054. Two Best Non-Overlapping Events / 兩個最佳不重疊活動
note_type: knowledge
domain: leetcode
tags: [leetcode, knowledge]
created: 2026-02-03
updated: 2026-02-03
status: active
source: leetcode
difficulty: Medium
complexity_time: O(n log n)
complexity_space: O(n)
review_interval_days: 14
next_review: 2026-02-17
---
# q2054. Two Best Non-Overlapping Events / 兩個最佳不重疊活動
[2054. Two Best Non-Overlapping Events](https://leetcode.com/problems/two-best-non-overlapping-events/)

Medium

Topics

![premium lock icon](https://leetcode.com/_next/static/images/lock-a6627e2c7fa0ce8bc117c109fb4e567d.svg)Companies

Hint

You are given a **0-indexed** 2D integer array of `events` where `events[i] = [startTimei, endTimei, valuei]`. The `ith` event starts at `startTimei` and ends at `endTimei`, and if you attend this event, you will receive a value of `valuei`.
給定 **0-indexed** 二維整數陣列 `events`，`events[i] = [startTimei, endTimei, valuei]`。第 `i` 個活動從 `startTimei` 開始，到 `endTimei` 結束，參加可獲得 `valuei` 的價值。

You can choose **at most two non-overlapping** events to attend such that the sum of their values is **maximized**.
你最多只能選 **兩個不重疊** 的活動，讓總價值 **最大化**。

Return _this **maximum** sum._
請回傳這個 **最大** 總和。

Note that the start time and end time is **inclusive**: that is, you cannot attend two events where one of them starts and the other ends at the same time. More specifically, if you attend an event with end time `t`, the next event must start at or after `t + 1`.
注意起訖時間是 **包含端點**：如果一個活動在時間 `t` 結束，下一個活動必須在 `t + 1` 或之後開始，不能在同一時間點接續。

**Example 1:**

![](https://assets.leetcode.com/uploads/2021/09/21/picture5.png)

**Input:** events = [ [1,3,2],[4,5,2],[2,4,3] ]
**Output:** 4
**Explanation:** Choose the green events, 0 and 1 for a sum of 2 + 2 = 4.
選擇第 0 與第 1 個活動（綠色），總和 2 + 2 = 4。

**Example 2:**

![Example 1 Diagram](https://assets.leetcode.com/uploads/2021/09/21/picture1.png)

**Input:** events = [ [1,3,2],[4,5,2],[1,5,5] ]
**Output:** 5
**Explanation:** Choose event 2 for a sum of 5.
選擇第 2 個活動，總和 5。

**Example 3:**

![](https://assets.leetcode.com/uploads/2021/09/21/picture3.png)

**Input:** events = [ [1,5,3],[1,5,1],[6,6,5] ]
**Output:** 8
**Explanation:** Choose events 0 and 2 for a sum of 3 + 5 = 8.
選擇第 0 與第 2 個活動，總和 3 + 5 = 8。

**Constraints:**

- `2 <= events.length <= 10^5`
- `events[i].length == 3`
- `1 <= startTimei <= endTimei <= 10^9`
- `1 <= valuei <= 10^6`
- `2 <= events.length <= 10^5`。
- `events[i].length == 3`。
- `1 <= startTimei <= endTimei <= 10^9`。
- `1 <= valuei <= 10^6`。

## 解題筆記與程式碼

通用演算法筆記：[interval_scheduling_two_events](../algorithm/interval_scheduling_two_events.md)
通用演算法筆記：[binary_search_lower_bound](../algorithm/binary_search_lower_bound.md)
通用資料結構筆記：[suffix_max_array](../data_structure/suffix_max_array.md)

### 思路拆解

- 只選最多兩個活動，固定第一個活動後，第二個活動一定是「開始時間 >= `end + 1`」的最早可行區間中價值最大的那個。
- 依開始時間排序後，用 `starts` 陣列做二分搜尋，找出下一個可接的活動索引。
- 從右往左預先算好 `suffix_max[i]`，代表從第 `i` 個活動到最後能取得的最大價值，讓第二個活動可以 `O(1)` 查到最佳值。

### 演算法

1. 將活動依 `startTime` 升冪排序，建立 `starts` 陣列。
2. 建立 `suffix_max`，`suffix_max[i] = max(events[i].value, suffix_max[i + 1])`。
3. 對每個活動 `i`：
   - 用二分搜尋找到第一個 `start >= end + 1` 的索引 `j`。
   - 候選答案為 `value[i] + suffix_max[j]`（若 `j == n` 則只取 `value[i]`）。
4. 取所有候選中的最大值。

### 為什麼要搭配 `suffix_max`

排序後，對每個活動都需要快速知道「能接在它後面的最佳活動價值」。`suffix_max` 將這個查詢壓到 `O(1)`，配合二分搜尋找出接續位置，整體時間降為 `O(n log n)`。

### 時間與空間

- 時間：`O(n log n)`（排序 + 每個活動一次二分搜尋）。
- 空間：`O(n)`（`starts` 與 `suffix_max`）。

```rust
impl Solution {
    pub fn max_two_events(mut events: Vec<Vec<i32>>) -> i32 {
        events.sort_by_key(|e| e[0]);

        let n = events.len();
        let mut starts = Vec::with_capacity(n);
        for e in &events {
            starts.push(e[0]);
        }

        let mut suffix_max = vec![0; n + 1];
        for i in (0..n).rev() {
            let v = events[i][2];
            suffix_max[i] = if suffix_max[i + 1] > v { suffix_max[i + 1] } else { v };
        }

        let mut ans = 0;
        for i in 0..n {
            let end = events[i][1];
            let val = events[i][2];
            let next_start = end + 1;
            let j = Self::lower_bound(&starts, next_start);
            let total = if j < n { val + suffix_max[j] } else { val };
            if total > ans {
                ans = total;
            }
        }
        ans
    }

    fn lower_bound(arr: &Vec<i32>, target: i32) -> usize {
        let mut l = 0usize;
        let mut r = arr.len();
        while l < r {
            let m = l + (r - l) / 2;
            if arr[m] < target {
                l = m + 1;
            } else {
                r = m;
            }
        }
        l
    }
}
```
