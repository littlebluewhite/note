---
title: q799. Champagne Tower / 香檳塔
note_type: knowledge
domain: leetcode
tags: [leetcode, knowledge]
created: 2026-02-14
updated: 2026-02-14
status: active
source: leetcode
difficulty: Medium
complexity_time: O(r^2)
complexity_space: O(r^2)
review_interval_days: 14
next_review: 2026-02-28
---
# q799. Champagne Tower / 香檳塔
[799. Champagne Tower](https://leetcode.com/problems/champagne-tower/)

Medium

Topics

![premium lock icon](https://leetcode.com/_next/static/images/lock-a6627e2c7fa0ce8bc117c109fb4e567d.svg)Companies

Hint

We stack glasses in a pyramid, where the **first** row has `1` glass, the **second** row has `2` glasses, and so on until the 100th row. Each glass holds one cup of champagne.
我們把杯子堆成金字塔：第 **1** 列有 `1` 個杯子，第 **2** 列有 `2` 個杯子，依此類推到第 100 列。每個杯子最多裝 1 cup 香檳。

Then, some champagne is poured into the first glass at the top. When the topmost glass is full, any excess liquid poured will fall equally to the glass immediately to the left and right of it. When those glasses become full, any excess champagne will fall equally to the left and right of those glasses, and so on. (A glass at the bottom row has its excess champagne fall on the floor.)
接著把一些香檳倒進最上方的第一個杯子。當某杯滿了之後，多出來的液體會平均流到下一列左、右兩個相鄰杯子。那些杯子滿了後，超出的香檳也會再往下平均分流，如此遞推。（最底列杯子的多餘香檳會流到地板上。）

Now after pouring some non-negative integer cups of champagne, return how full the `j`th glass in the `i`th row is (both `i` and `j` are 0-indexed.)
現在給定倒入的非負整數杯數，請回傳第 `i` 列第 `j` 個杯子的裝填比例（`i`、`j` 都是 0-indexed）。

**Example 1:**

**Input:** poured = 1, query_row = 1, query_glass = 1  
**Output:** 0.00000  
**Explanation:** We poured 1 cup of champagne into the top glass `(0, 0)`. There is no overflow, so glasses below remain empty.
**輸入：** poured = 1, query_row = 1, query_glass = 1  
**輸出：** 0.00000  
**說明：** 倒入 1 cup 到頂部 `(0, 0)` 後不會溢流，所以下方杯子都維持為空。

**Example 2:**

**Input:** poured = 2, query_row = 1, query_glass = 1  
**Output:** 0.50000  
**Explanation:** After the top glass is filled, 1 cup overflows and is split equally. So glasses `(1, 0)` and `(1, 1)` each receive 0.5 cup.
**輸入：** poured = 2, query_row = 1, query_glass = 1  
**輸出：** 0.50000  
**說明：** 頂部杯子裝滿後有 1 cup 溢流並平均分給兩側，故 `(1, 0)` 與 `(1, 1)` 各得到 0.5 cup。

**Example 3:**

**Input:** poured = 100000009, query_row = 33, query_glass = 17  
**Output:** 1.00000
**輸入：** poured = 100000009, query_row = 33, query_glass = 17  
**輸出：** 1.00000

**Constraints:**

- `0 <= poured <= 10^9`
- `0 <= query_glass <= query_row < 100`
- `0 <= poured <= 10^9`。
- `0 <= query_glass <= query_row < 100`。

## 解題筆記與程式碼

通用演算法筆記：[layered_overflow_dp_simulation](../algorithm/layered_overflow_dp_simulation.md)  
通用演算法筆記：[dp_dynamic_programming](../algorithm/dp_dynamic_programming.md)  
資料結構筆記：[triangular_dp_array](../data_structure/triangular_dp_array.md)

### 思路拆解

- 這題本質是「分層傳遞」：每個杯子容量上限是 `1.0`，只把超出的量往下一層傳。
- 定義 `flow[r][c]` 為到達第 `r` 列第 `c` 杯的總液量（可超過 1）。
- 若 `flow[r][c] > 1`，溢流量是 `flow[r][c] - 1`，左右各分到一半。
- 只要模擬到 `query_row` 即可，最後答案為 `min(1.0, flow[query_row][query_glass])`。

### 演算法

1. 建立大小約 `(query_row + 2) x (query_row + 2)` 的三角 DP 陣列 `flow`，初值皆為 `0.0`。
2. 設 `flow[0][0] = poured`。
3. 由上到下掃描每一列（到 `query_row - 1`）：
   - 對每個杯子 `(r, c)` 計算 `overflow = (flow[r][c] - 1.0) / 2.0`。
   - 若 `overflow > 0`，則：
     - `flow[r + 1][c] += overflow`
     - `flow[r + 1][c + 1] += overflow`
4. 回傳 `flow[query_row][query_glass].min(1.0)`。

### 時間與空間

- 時間：`O(r^2)`，`r = query_row`，因為需要掃描到目標列的三角區域。
- 空間：`O(r^2)`，儲存每個杯子的到達液量。

```rust
impl Solution {
    pub fn champagne_tower(poured: i32, query_row: i32, query_glass: i32) -> f64 {
        let r = query_row as usize;
        let g = query_glass as usize;

        let mut flow = vec![vec![0.0f64; r + 2]; r + 2];
        flow[0][0] = poured as f64;

        for row in 0..r {
            for col in 0..=row {
                let overflow = (flow[row][col] - 1.0) / 2.0;
                if overflow > 0.0 {
                    flow[row + 1][col] += overflow;
                    flow[row + 1][col + 1] += overflow;
                }
            }
        }

        flow[r][g].min(1.0)
    }
}
```

## 實作細節

- `r + 2` 的配置可避免 `row + 1`、`col + 1` 越界。
- 題目要求回傳裝填比例，答案必定介於 `[0, 1]`，因此最後要做 `min(1.0)`。
- 使用 `f64` 可直接處理二分流造成的小數。
