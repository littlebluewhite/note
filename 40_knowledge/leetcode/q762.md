---
title: q762. Prime Number of Set Bits in Binary Representation / 二進位表示中質數個數的置位
note_type: knowledge
domain: leetcode
tags: [leetcode, knowledge]
created: 2026-02-21
updated: 2026-02-21
status: active
source: leetcode
difficulty: Easy
complexity_time: O(right - left + 1)
complexity_space: O(1)
review_interval_days: 14
next_review: 2026-03-07
---
# q762. Prime Number of Set Bits in Binary Representation / 二進位表示中質數個數的置位
[762. Prime Number of Set Bits in Binary Representation](https://leetcode.com/problems/prime-number-of-set-bits-in-binary-representation/)

Easy

Topics

Companies

Given two integers `left` and `right`, return the count of numbers in the inclusive range `[left, right]` having a prime number of set bits in their binary representation.
給定兩個整數 `left` 與 `right`，請回傳在閉區間 `[left, right]` 內，二進位表示中置位（值為 `1` 的 bit）個數為質數的整數數量。

Recall that the number of set bits an integer has is the number of `1`'s present when written in binary.
整數的置位數量，指的是它的二進位表示中 `1` 的個數。

- For example, `21` written in binary is `10101`, which has `3` set bits.
- 例如 `21` 的二進位是 `10101`，其中有 `3` 個置位。

**Example 1:**

**Input:** left = 6, right = 10
**Output:** 4
**Explanation:** 6 (`110`) has 2 set bits, 7 (`111`) has 3 set bits, 9 (`1001`) has 2 set bits, and 10 (`1010`) has 2 set bits. All of these are prime counts.
**輸入：** left = 6, right = 10
**輸出：** 4
**說明：** 6（`110`）有 2 個置位、7（`111`）有 3 個置位、9（`1001`）有 2 個置位、10（`1010`）有 2 個置位，這些置位數都為質數。

**Example 2:**

**Input:** left = 10, right = 15
**Output:** 5
**Explanation:** 10 (`1010`) has 2 set bits, 11 (`1011`) has 3 set bits, 12 (`1100`) has 2 set bits, 13 (`1101`) has 3 set bits, and 14 (`1110`) has 3 set bits.
**輸入：** left = 10, right = 15
**輸出：** 5
**說明：** 10（`1010`）有 2 個置位、11（`1011`）有 3 個置位、12（`1100`）有 2 個置位、13（`1101`）有 3 個置位、14（`1110`）有 3 個置位，皆符合條件。

**Constraints:**

- `1 <= left <= right <= 10^6`
- `0 <= right - left <= 10^4`
- `1 <= left <= right <= 10^6`。
- `0 <= right - left <= 10^4`。

## 解題筆記與程式碼

通用演算法筆記：[range_enumeration_popcount_filter](../algorithm/range_enumeration_popcount_filter.md)
通用演算法筆記：[primality_test_sqrt](../algorithm/primality_test_sqrt.md)
資料結構筆記：[small_prime_lookup_table](../data_structure/small_prime_lookup_table.md)

### 思路拆解

- 直接枚舉 `x` 從 `left` 到 `right`。
- 用 `count_ones()` 取得 `x` 的置位數 `k`。
- 判斷 `k` 是否為質數，若是就累加答案。
- 由於 `right <= 10^6`，`k` 最大只到 `20`，可用「小質數查表」做 `O(1)` 判斷。

### 為什麼可用「小質數查表」

- `10^6` 的二進位長度不到 20 bit，因此 set bits 數量只可能落在 `0..20`。
- `0..20` 內的質數只有：`2, 3, 5, 7, 11, 13, 17, 19`。
- 可用位元遮罩常數 `PRIME_MASK`，透過 `((PRIME_MASK >> k) & 1) == 1` 判斷是否為質數，省去每次試除。

### 演算法

1. 宣告 `PRIME_MASK`，把 `2,3,5,7,11,13,17,19` 對應 bit 位置設為 1。
2. 迴圈枚舉 `x in [left, right]`。
3. `k = (x as u32).count_ones()`。
4. 若 `((PRIME_MASK >> k) & 1) == 1`，`ans += 1`。
5. 回傳 `ans`。

### 時間與空間

- 時間：`O(right - left + 1)`。
- 空間：`O(1)`。

```rust
impl Solution {
    pub fn count_prime_set_bits(left: i32, right: i32) -> i32 {
        // Prime indices in [0, 20]: 2,3,5,7,11,13,17,19
        const PRIME_MASK: i32 = (1 << 2)
            | (1 << 3)
            | (1 << 5)
            | (1 << 7)
            | (1 << 11)
            | (1 << 13)
            | (1 << 17)
            | (1 << 19);

        let mut ans = 0;
        for x in left..=right {
            let k = (x as u32).count_ones() as i32;
            if ((PRIME_MASK >> k) & 1) == 1 {
                ans += 1;
            }
        }
        ans
    }
}
```

## Related problems / 相關題目

- [q401](./q401.md)
- [q693](./q693.md)
- [191. Number of 1 Bits](https://leetcode.com/problems/number-of-1-bits/)
- [204. Count Primes](https://leetcode.com/problems/count-primes/)
- [338. Counting Bits](https://leetcode.com/problems/counting-bits/)
