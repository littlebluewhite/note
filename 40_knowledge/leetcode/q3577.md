---
title: q3577. Count the Number of Computer Unlocking Permutations / 統計電腦解鎖排列的數量
note_type: knowledge
domain: leetcode
tags: [leetcode, knowledge]
created: 2026-02-03
updated: 2026-02-03
status: active
source: leetcode
complexity_time: O(n)
complexity_space: O(1)
review_interval_days: 14
next_review: 2026-02-17
---
# q3577. Count the Number of Computer Unlocking Permutations / 統計電腦解鎖排列的數量
[3577. Count the Number of Computer Unlocking Permutations](https://leetcode.com/problems/count-the-number-of-computer-unlocking-permutations/)

Medium

Topics

![premium lock icon](https://leetcode.com/_next/static/images/lock-a6627e2c7fa0ce8bc117c109fb4e567d.svg)Companies

Hint

You are given an array `complexity` of length `n`.
給定長度為 `n` 的陣列 `complexity`。

There are `n` **locked** computers in a room with labels from 0 to `n - 1`, each with its own **unique** password. The password of the computer `i` has a complexity `complexity[i]`.
房間裡有 `n` 台標號 0 到 `n - 1` 的上鎖電腦，每台都有唯一密碼；第 `i` 台電腦的密碼複雜度為 `complexity[i]`。

The password for the computer labeled 0 is **already** decrypted and serves as the root. All other computers must be unlocked using it or another previously unlocked computer, following this information:
標號為 0 的電腦密碼已解出並作為根，其餘電腦必須用它或已解鎖的其他電腦來解鎖，規則如下：

- You can decrypt the password for the computer `i` using the password for computer `j`, where `j` is **any** integer less than `i` with a lower complexity. (i.e. `j < i` and `complexity[j] < complexity[i]`)
- To decrypt the password for computer `i`, you must have already unlocked a computer `j` such that `j < i` and `complexity[j] < complexity[i]`.
- 若要解開電腦 `i`，可以使用任一滿足 `j < i` 且 `complexity[j] < complexity[i]` 的已解鎖電腦 `j`。
- 也就是說，當電腦 `i` 要被解鎖時，必須已經解鎖某個 `j < i` 並且其複雜度更低。

Find the number of permutations of `[0, 1, 2, ..., (n - 1)]` that represent a valid order in which the computers can be unlocked, starting from computer 0 as the only initially unlocked one.
請找出 `[0, 1, 2, ..., (n - 1)]` 的排列數，代表從唯一已解鎖的電腦 0 開始，可以依序解開所有電腦的有效順序。

Since the answer may be large, return it **modulo** 109 + 7.
答案可能很大，請回傳對 10^9 + 7 取模的結果。

**Note** that the password for the computer **with label** 0 is decrypted, and _not_ the computer with the first position in the permutation.
注意：已解出的密碼屬於標號 0 的電腦，而不是排列中的第一個位置。

**Example 1:**

**Input:** complexity = [1,2,3]

**Output:** 2

**Explanation:**

The valid permutations are:

- [0, 1, 2]
    - Unlock computer 0 first with root password.
    - Unlock computer 1 with password of computer 0 since `complexity[0] < complexity[1]`.
    - Unlock computer 2 with password of computer 1 since `complexity[1] < complexity[2]`.
- [0, 2, 1]
    - Unlock computer 0 first with root password.
    - Unlock computer 2 with password of computer 0 since `complexity[0] < complexity[2]`.
    - Unlock computer 1 with password of computer 0 since `complexity[0] < complexity[1]`.

**Example 2:**

**Input:** complexity = [3,3,3,4,4,4]

**Output:** 0

**Explanation:**

There are no possible permutations which can unlock all computers.

**Constraints:**

- `2 <= complexity.length <= 105`
- `1 <= complexity[i] <= 109`
- `2 <= complexity.length <= 10^5`。
- `1 <= complexity[i] <= 10^9`。

```rust
impl Solution {
    pub fn count_permutations(complexity: Vec<i32>) -> i32 {
        const MOD: i64 = 1_000_000_007;
        let root = complexity[0] as i64;
        if complexity.iter().skip(1).any(|&c| (c as i64) <= root) {
            return 0;
        }

        let mut ans: i64 = 1;
        let limit = complexity.len() as i64 - 1; // factorial of remaining (n-1) positions
        for k in 2..=limit {
            ans = ans * k % MOD;
        }
        ans as i32
    }
}
```

## 解題筆記與程式碼

通用演算法筆記：[combinatorics_counting](../algorithm/combinatorics_counting.md)

### 核心觀察

- 除了標號 0 以外，電腦 `i` 需要先存在一台標號更小且複雜度更低的已解鎖電腦；唯一的初始已解鎖電腦就是 0。
- 若存在任一 `i > 0` 使得 `complexity[i] <= complexity[0]`，則找不到符合條件的解鎖者，答案為 0。
- 當 `complexity[0]` 是全域唯一最小值時，電腦 0 的複雜度必然低於所有其他電腦，且標號也更小，因此 0 一支就能解鎖全部；剩下的 `n-1` 台電腦可以任意順序排列。

### 演算法

1. 取出 `complexity[0]`，掃描其餘元素，若有 `<= complexity[0]` 直接回傳 0。
2. 否則計算 `(n-1)! mod 1e9+7` 作為答案（0 必須在首位，其餘任意）。

### 時間與空間

- 時間：`O(n)` 掃描 + `O(n)` 計算階乘。
- 空間：`O(1)` 額外空間。


## 補充筆記：Unlocking permutations with a root of minimal complexity

## Idea
- Only computer `0` is initially unlocked; any other computer `i` needs an already-unlocked `j < i` with `complexity[j] < complexity[i]`.
- If there exists any `i > 0` with `complexity[i] <= complexity[0]`, `i` can never be unlocked (no smaller-index, lower-complexity helper), so the answer is `0`.
- When `complexity[0]` is the unique minimum, computer `0` alone satisfies the requirement for every other computer (`0 < i` and `complexity[0] < complexity[i]`), so after unlocking `0`, all remaining computers can appear in any order.

## Resulting formula
- If some `complexity[i] <= complexity[0]` for `i > 0`: answer `0`.
- Otherwise: answer `(n-1)! mod 1e9+7` (permutations of the remaining `n-1` computers with `0` fixed first).

## Complexity
- Time: `O(n)` to verify the minimum and compute factorial.
- Space: `O(1)` extra.
