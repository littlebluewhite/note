---
title: q3510. Minimum Pair Removal to Sort Array II / 排序陣列的最小配對移除 II
note_type: knowledge
domain: leetcode
tags: [leetcode, knowledge]
created: 2026-02-03
updated: 2026-02-03
status: active
source: leetcode
complexity_time: O(n log n)
complexity_space: O(n)
review_interval_days: 14
next_review: 2026-02-17
---
# q3510. Minimum Pair Removal to Sort Array II / 排序陣列的最小配對移除 II
[3510. Minimum Pair Removal to Sort Array II](https://leetcode.com/problems/minimum-pair-removal-to-sort-array-ii/)

Hard

Topics

![premium lock icon](https://leetcode.com/_next/static/images/lock-a6627e2c7fa0ce8bc117c109fb4e567d.svg)Companies

Hint

Given an array `nums`, you can perform the following operation any number of times:
給定陣列 `nums`，你可以執行下列操作任意次：

- Select the **adjacent** pair with the **minimum** sum in `nums`. If multiple such pairs exist, choose the leftmost one.
- Replace the pair with their sum.
- 選擇 `nums` 中**相鄰**且**總和最小**的一對；若有多組，選最左邊那組。
- 用這一對的總和取代該對元素。

Return the **minimum number of operations** needed to make the array **non-decreasing**.
請回傳使陣列變成**非遞減**所需的**最少操作次數**。

An array is said to be **non-decreasing** if each element is greater than or equal to its previous element (if it exists).
非遞減陣列指的是每個元素都大於等於前一個元素（若存在）。

**Example 1:**

**Input:** nums = [5,2,3,1]

**Output:** 2

**Explanation:**

- The pair `(3,1)` has the minimum sum of 4. After replacement, `nums = [5,2,4]`.
- The pair `(2,4)` has the minimum sum of 6. After replacement, `nums = [5,6]`.
- `(3,1)` 的總和最小為 4，取代後 `nums = [5,2,4]`。
- `(2,4)` 的總和最小為 6，取代後 `nums = [5,6]`。

The array `nums` became non-decreasing in two operations.
陣列在兩次操作後變為非遞減。

**Example 2:**

**Input:** nums = [1,2,2]

**Output:** 0

**Explanation:**

The array `nums` is already sorted.
陣列本來就已經排序完成。

**Constraints:**

- `1 <= nums.length <= 10^5`
- `-10^9 <= nums[i] <= 10^9`
- `1 <= nums.length <= 10^5`。
- `-10^9 <= nums[i] <= 10^9`。

## 解題筆記與程式碼

通用演算法筆記：[lazy_deletion_priority_queue](../algorithm/lazy_deletion_priority_queue.md)
通用演算法筆記：[adjacent_inversion_count](../algorithm/adjacent_inversion_count.md)
通用資料結構筆記：[priority_queue_binary_heap](../data_structure/priority_queue_binary_heap.md)
通用資料結構筆記：[doubly_linked_list](../data_structure/doubly_linked_list.md)

### 思路拆解

- 題目要求每次取「最小相鄰對」合併，直接掃描會變成 `O(n^2)`，在 1e5 的規模會超時（q3507 的做法）。
- 用最小堆維護所有相鄰對的 `(sum, left_index)`，搭配延遲刪除處理「已失效的舊相鄰對」。
- 用雙向鏈結串列（`prev/next` 陣列）表示目前陣列，支援 `O(1)` 合併與鄰居查詢。
- 用 `decrease_count` 記錄相鄰遞減對數量；當 `decrease_count == 0` 時，陣列已非遞減，可停止。

### 演算法

1. 初始化 `vals`、`prev`、`next`、`removed`，並把所有相鄰對的 `(sum, left_index)` 放入最小堆。
2. 計算初始 `decrease_count`（`vals[i] > vals[i+1]` 的數量）；若為 0 直接回傳。
3. 迴圈取堆頂 `(sum, u)`，令 `v = next[u]`：
   - 若 `v` 不存在、`u` 或 `v` 已被移除、或 `vals[u] + vals[v] != sum`，視為失效資料，跳過。
   - 以 `(u, v)` 合併成 `sum`，更新 `prev/next`，標記 `v` 為移除。
   - 只針對受影響的相鄰對更新 `decrease_count`（舊的三對移除、合併後的兩對加入）。
   - 將新的相鄰對推回堆。
4. 當 `decrease_count == 0`，回傳操作次數。

### 為什麼要延遲刪除

合併會讓舊的相鄰對失效，但從二元堆內直接刪除成本高；延遲刪除只需在彈出時做「仍相鄰、未被移除、sum 未變」的檢查即可。

### 時間與空間

- 時間：`O(n log n)`（最多 `n-1` 次合併，每次 `log n` 堆操作）。
- 空間：`O(n)`（雙向鏈結串列 + 堆）。

```rust
use std::cmp::Reverse;
use std::collections::BinaryHeap;

impl Solution {
    pub fn minimum_pair_removal(nums: Vec<i32>) -> i32 {
        let n = nums.len();
        if n <= 1 {
            return 0;
        }

        let mut vals: Vec<i64> = nums.iter().map(|&x| x as i64).collect();
        let mut prev: Vec<i32> = (0..n as i32).map(|i| i - 1).collect();
        let mut next: Vec<i32> = (0..n as i32).map(|i| i + 1).collect();
        let mut removed = vec![false; n];
        next[n - 1] = -1;

        let mut heap: BinaryHeap<Reverse<(i64, i32)>> = BinaryHeap::with_capacity(3 * n);
        let mut decrease_count = 0i32;
        for i in 0..n - 1 {
            if vals[i] > vals[i + 1] {
                decrease_count += 1;
            }
            heap.push(Reverse((vals[i] + vals[i + 1], i as i32)));
        }

        if decrease_count == 0 {
            return 0;
        }

        let mut ops = 0i32;
        while decrease_count > 0 {
            let Reverse((sum, u_idx)) = match heap.pop() {
                Some(v) => v,
                None => break,
            };
            let u = u_idx as usize;
            if removed[u] {
                continue;
            }
            let v_idx = next[u];
            if v_idx == -1 {
                continue;
            }
            let v = v_idx as usize;
            if removed[v] {
                continue;
            }
            if vals[u] + vals[v] != sum {
                continue;
            }

            let p_idx = prev[u];
            let next_v = next[v];

            if p_idx != -1 && vals[p_idx as usize] > vals[u] {
                decrease_count -= 1;
            }
            if vals[u] > vals[v] {
                decrease_count -= 1;
            }
            if next_v != -1 && vals[v] > vals[next_v as usize] {
                decrease_count -= 1;
            }

            ops += 1;
            vals[u] = sum;
            next[u] = next_v;
            if next_v != -1 {
                prev[next_v as usize] = u as i32;
            }
            removed[v] = true;

            if p_idx != -1 && vals[p_idx as usize] > vals[u] {
                decrease_count += 1;
            }
            if next_v != -1 && vals[u] > vals[next_v as usize] {
                decrease_count += 1;
            }

            if decrease_count == 0 {
                break;
            }

            if p_idx != -1 {
                heap.push(Reverse((vals[p_idx as usize] + vals[u], p_idx)));
            }
            if next_v != -1 {
                heap.push(Reverse((vals[u] + vals[next_v as usize], u as i32)));
            }
        }

        ops
    }
}
```
