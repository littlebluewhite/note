---
title: q2147. Number of Ways to Divide a Long Corridor / 分隔長廊的方案數
note_type: knowledge
domain: leetcode
tags: [leetcode, knowledge]
created: 2026-02-03
updated: 2026-02-03
status: active
source: leetcode
difficulty: Hard
complexity_time: O(n)
complexity_space: m
review_interval_days: 14
next_review: 2026-02-17
---
# q2147. Number of Ways to Divide a Long Corridor / 分隔長廊的方案數
[2147. Number of Ways to Divide a Long Corridor](https://leetcode.com/problems/number-of-ways-to-divide-a-long-corridor/)

Hard

Topics

![premium lock icon](https://leetcode.com/_next/static/images/lock-a6627e2c7fa0ce8bc117c109fb4e567d.svg)Companies

Hint

Along a long library corridor, there is a line of seats and decorative plants. You are given a **0-indexed** string `corridor` of length `n` consisting of letters `'S'` and `'P'` where each `'S'` represents a seat and each `'P'` represents a plant.
在一條長走廊上，有座位與植物排成一列。給定**0-indexed** 字串 `corridor`（長度 `n`），只包含字元 `'S'`（seat 座位）與 `'P'`（plant 植物）。

One room divider has **already** been installed to the left of index `0`, and **another** to the right of index `n - 1`. Additional room dividers can be installed. For each position between indices `i - 1` and `i` (`1 <= i <= n - 1`), at most one divider can be installed.
走廊最左（索引 0 之前）與最右（索引 `n-1` 之後）各已裝好一道隔板；在任意相鄰索引 `i-1` 與 `i` 之間（`1 <= i <= n-1`），最多可額外裝一片隔板。

Divide the corridor into non-overlapping sections, where each section has **exactly two seats** with any number of plants. There may be multiple ways to perform the division. Two ways are **different** if there is a position with a room divider installed in the first way but not in the second way.
請把走廊分成互不重疊的區段，每段**恰好兩張座位**，植物數不限。兩種切法若存在一個位置只有其中一種放了隔板，即視為不同。

Return _the number of ways to divide the corridor_. Since the answer may be very large, return it **modulo** `109 + 7`. If there is no way, return `0`.
請回傳可行切法數，答案對 `10^9 + 7` 取模；若無法達成條件則回傳 0。

**Example 1:**

![](https://assets.leetcode.com/uploads/2021/12/04/1.png)

**Input:** corridor = "SSPPSPS"
**Output:** 3
**Explanation:** There are 3 different ways to divide the corridor.
The black bars in the above image indicate the two room dividers already installed.
Note that in each of the ways, **each** section has exactly **two** seats.

**Example 2:**

![](https://assets.leetcode.com/uploads/2021/12/04/2.png)

**Input:** corridor = "PPSPSP"
**Output:** 1
**Explanation:** There is only 1 way to divide the corridor, by not installing any additional dividers.
Installing any would create some section that does not have exactly two seats.

**Example 3:**

![](https://assets.leetcode.com/uploads/2021/12/12/3.png)

**Input:** corridor = "S"
**Output:** 0
**Explanation:** There is no way to divide the corridor because there will always be a section that does not have exactly two seats.

**Constraints:**

- `n == corridor.length`
- `1 <= n <= 105`
- `corridor[i]` is either `'S'` or `'P'`.
- `n == corridor.length`。
- `1 <= n <= 10^5`。
- `corridor[i]` 為 `'S'` 或 `'P'`。

## 解題筆記與程式碼

DP 筆記：[dp_dynamic_programming](../algorithm/dp_dynamic_programming.md)
通用演算法筆記：[combinatorics_counting](../algorithm/combinatorics_counting.md)

### 核心觀察

- 每個合法區段必含兩個座位，因此所有座位的位置決定了區段邊界；植物只影響「分隔線可以放在哪」。
- 座位總數若為 0 或奇數，一定無法切分。
- 兩個連續區段的邊界落在第 2k+1 與第 2k+2 張座位之間，若其中夾了 `g` 個植物，分隔線可放的選擇數為 `g + 1`，獨立相乘即可。

### 演算法

1. 掃描 `corridor` 收集所有座位索引 `pos`，若座位數為 0 或奇數直接回傳 0。
2. 對每個相鄰區段邊界（即 `pos[2k+1]` 與 `pos[2k+2]`），計算間隔植物數 `gap = pos[2k+2] - pos[2k+1] - 1`，累乘 `ans *= gap + 1 (mod MOD)`。
3. 乘積結果即為可行切法；若只有一組座位，乘積範圍為空，答案為 1。

### 時間與空間

- 時間：O(n) 單次掃描。
- 空間：O(m) 儲存座位索引（`m` 為座位數）。

```rust
impl Solution {
    pub fn number_of_ways(corridor: String) -> i32 {
        const MOD: i64 = 1_000_000_007;
        let mut seats = Vec::new();
        for (i, ch) in corridor.bytes().enumerate() {
            if ch == b'S' {
                seats.push(i as i64);
            }
        }

        if seats.len() < 2 || seats.len() % 2 == 1 {
            return 0;
        }

        let mut ans: i64 = 1;
        let pairs = seats.len() / 2;
        for k in 0..pairs - 1 {
            let left = seats[2 * k + 1];
            let right = seats[2 * k + 2];
            let gap = right - left - 1;
            ans = ans * (gap + 1) % MOD;
        }

        ans as i32
    }
}
```


## 補充筆記：座位數為奇數，答案 0。
