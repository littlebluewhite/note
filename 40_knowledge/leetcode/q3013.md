---
title: q3013. Divide an Array Into Subarrays With Minimum Cost II / 將陣列分成具有最小成本的子陣列 II
note_type: knowledge
domain: leetcode
tags: [leetcode, knowledge]
created: 2026-02-03
updated: 2026-02-03
status: active
source: leetcode
difficulty: Hard
complexity_time: O(n log n)
complexity_space: O(n)
review_interval_days: 14
next_review: 2026-02-17
---
# q3013. Divide an Array Into Subarrays With Minimum Cost II / 將陣列分成具有最小成本的子陣列 II

Link: https://leetcode.com/problems/divide-an-array-into-subarrays-with-minimum-cost-ii/

Difficulty: Hard

---

You are given a **0-indexed** array of integers `nums` of length `n`, and two **positive** integers `k` and `dist`.
給你一個長度為 `n` 的 **0-indexed** 整數陣列 `nums`，以及兩個 **正整數** `k` 與 `dist`。

The cost of an array is the value of its first element. For example, the cost of `[1,2,3]` is `1` while the cost of `[3,4,1]` is `3`.
一個陣列的 cost 定義為「第一個元素的值」。例如 `[1,2,3]` 的 cost 是 `1`，而 `[3,4,1]` 的 cost 是 `3`。

You need to divide `nums` into `k` disjoint contiguous subarrays, such that the difference between the starting index of the **second** subarray and the starting index of the **kth** subarray should be **less than or equal to** `dist`.
你需要把 `nums` 分成 `k` 個互不重疊的連續子陣列，且「第 2 段的起點」與「第 k 段的起點」兩者索引差要 **<= `dist`**。

In other words, if you divide `nums` into the subarrays `nums[0..(i1 - 1)], nums[i1..(i2 - 1)], ..., nums[ik-1..(n - 1)]`, then `ik-1 - i1 <= dist`.
換句話說，若切成 `nums[0..(i1-1)], nums[i1..(i2-1)], ..., nums[ik-1..(n-1)]`，則必須滿足 `ik-1 - i1 <= dist`。

Return the **minimum** possible sum of the cost of these subarrays.
請回傳這些子陣列 cost 總和的 **最小值**。

---

Example 1:

Input: `nums = [1,3,2,6,4,2], k = 3, dist = 3`
Output: `5`
Explanation: The best possible way to divide `nums` into `3` subarrays is: `[1,3]`, `[2,6,4]`, and `[2]`. This choice is valid because `ik-1 - i1` is `5 - 2 = 3` which is equal to `dist`. The total cost is `nums[0] + nums[2] + nums[5]` which is `1 + 2 + 2 = 5`.
It can be shown that there is no possible way to divide `nums` into `3` subarrays at a cost lower than `5`.

Example 2:

Input: `nums = [10,1,2,2,2,1], k = 4, dist = 3`
Output: `15`
Explanation: The best possible way to divide `nums` into `4` subarrays is: `[10]`, `[1]`, `[2]`, and `[2,2,1]`. This choice is valid because `ik-1 - i1` is `3 - 1 = 2` which is less than `dist`. The total cost is `nums[0] + nums[1] + nums[2] + nums[3]` which is `10 + 1 + 2 + 2 = 15`.
The division `[10]`, `[1]`, `[2,2,2]`, and `[1]` is not valid, because the difference between `ik-1` and `i1` is `5 - 1 = 4`, which is greater than `dist`.
It can be shown that there is no possible way to divide `nums` into `4` subarrays at a cost lower than `15`.

Example 3:

Input: `nums = [10,8,18,9], k = 3, dist = 1`
Output: `36`
Explanation: The best possible way to divide `nums` into `3` subarrays is: `[10]`, `[8]`, and `[18,9]`. This choice is valid because `ik-1 - i1` is `2 - 1 = 1` which is equal to `dist`. The total cost is `nums[0] + nums[1] + nums[2]` which is `10 + 8 + 18 = 36`.
The division `[10]`, `[8,18]`, and `[9]` is not valid, because the difference between `ik-1` and `i1` is `3 - 1 = 2`, which is greater than `dist`.
It can be shown that there is no possible way to divide `nums` into `3` subarrays at a cost lower than `36`.

Constraints:

- `3 <= n <= 10^5`
- `1 <= nums[i] <= 10^9`
- `3 <= k <= n`
- `k - 2 <= dist <= n - 2`

---

## 解題筆記與程式碼

### 核心觀察

- 第 1 段一定從 `0` 開始，所以一定會付出 `nums[0]`。
- 其餘 `k-1` 段，只要決定它們的「起點 index」，分段方式就唯一確定。
- 條件只限制：第 2 段起點 `i1` 和第 k 段起點 `ik-1` 的距離 `ik-1 - i1 <= dist`。

### 等價改寫：枚舉第 k 段起點 i

令第 k 段起點為 `i`（也就是 `ik-1 = i`）。

那麼第 2 段起點 `i1` 必須滿足：

- `i1 >= i - dist`

而在 `k` 段中，我們除了固定的 `nums[0]` 與最後一段起點 `nums[i]` 之外，還需要再選出 `k-2` 個子陣列起點，必須落在：

- `[(i - dist) .. (i - 1)]` 這個索引範圍內（視窗）

因此，對固定的 `i`，最小成本就是：

- `nums[0] + nums[i] + (視窗內最小的 k-2 個 nums[j] 的總和)`

當 `i` 往右移動，這個視窗會以固定長度滑動，所以變成典型的：

- Sliding window + 維護 window 內 k-smallest sum

相關筆記：
- [[sliding_window_k_smallest_sum]]
- [[ordered_multiset_btreemap]]

### 做法 B（最穩）：兩個 multiset（Rust 用 BTreeMap）

維護兩個 multiset：
- `st1`：存「最小的 m = k-2 個值」，並維護 `sum1`
- `st2`：存剩下的值

每次視窗滑動：
- 移除離開視窗的元素（如果有）
- 加入新進視窗的元素
- 呼叫 `rebalance()` 讓 `st1` 的元素數量維持 `m`

最後答案：
- 初始化 `i = k-1`（視窗是 `[1 .. k-2]`）
- 接著 `i` 從 `k` 到 `n-1`，視窗變成 `[i-dist .. i-1]`

### 複雜度

- 時間：`O(n log n)`（每步插入/刪除/搬移都是 `log n`）
- 空間：`O(n)`

---

## Rust（BTreeMap multiset）參考實作

```rust
use std::collections::BTreeMap;

struct MultiSet {
    mp: BTreeMap<i32, i32>,
    size: usize,
}

impl MultiSet {
    fn new() -> Self {
        Self { mp: BTreeMap::new(), size: 0 }
    }

    fn insert(&mut self, x: i32) {
        *self.mp.entry(x).or_insert(0) += 1;
        self.size += 1;
    }

    fn remove(&mut self, x: i32) -> bool {
        if let Some(cnt) = self.mp.get_mut(&x) {
            *cnt -= 1;
            if *cnt == 0 {
                self.mp.remove(&x);
            }
            self.size -= 1;
            true
        } else {
            false
        }
    }

    fn min_key(&self) -> i32 {
        *self.mp.first_key_value().unwrap().0
    }

    fn max_key(&self) -> i32 {
        *self.mp.last_key_value().unwrap().0
    }

    fn pop_min(&mut self) -> i32 {
        let x = self.min_key();
        self.remove(x);
        x
    }

    fn pop_max(&mut self) -> i32 {
        let x = self.max_key();
        self.remove(x);
        x
    }

    fn is_empty(&self) -> bool {
        self.size == 0
    }
}

struct Container {
    m: usize,      // want m smallest in st1
    st1: MultiSet, // m smallest
    st2: MultiSet, // the rest
    sum1: i64,
}

impl Container {
    fn new(m: usize) -> Self {
        Self { m, st1: MultiSet::new(), st2: MultiSet::new(), sum1: 0 }
    }

    fn rebalance(&mut self) {
        // st1 too small
        while self.st1.size < self.m && !self.st2.is_empty() {
            let x = self.st2.pop_min();
            self.st1.insert(x);
            self.sum1 += x as i64;
        }
        // st1 too large
        while self.st1.size > self.m {
            let x = self.st1.pop_max();
            self.sum1 -= x as i64;
            self.st2.insert(x);
        }
    }

    fn add(&mut self, x: i32) {
        // heuristic: compare with min(st2)
        if !self.st2.is_empty() {
            let min2 = self.st2.min_key();
            if x >= min2 {
                self.st2.insert(x);
            } else {
                self.st1.insert(x);
                self.sum1 += x as i64;
            }
        } else {
            self.st1.insert(x);
            self.sum1 += x as i64;
        }
        self.rebalance();
    }

    fn erase(&mut self, x: i32) {
        if self.st1.remove(x) {
            self.sum1 -= x as i64;
        } else {
            // must exist in st2
            self.st2.remove(x);
        }
        self.rebalance();
    }
}

impl Solution {
    pub fn minimum_cost(nums: Vec<i32>, k: i32, dist: i32) -> i64 {
        let n = nums.len();
        let m = (k as usize).saturating_sub(2);
        let mut cnt = Container::new(m);

        // init window for i = k-1: indices [1 .. k-2]
        for idx in 1..(k as usize - 1) {
            cnt.add(nums[idx]);
        }

        // i = k-1
        let mut ans = cnt.sum1 + nums[k as usize - 1] as i64;

        // i from k .. n-1
        for i in (k as usize)..n {
            let j = i as i32 - dist - 1; // leaving index = i - dist - 1
            if j > 0 {
                cnt.erase(nums[j as usize]);
            }
            // entering value is nums[i-1]
            cnt.add(nums[i - 1]);

            ans = ans.min(cnt.sum1 + nums[i] as i64);
        }

        ans + nums[0] as i64
    }
}
```
