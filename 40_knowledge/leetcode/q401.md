---
title: q401. Binary Watch / 二進位手錶
note_type: knowledge
domain: leetcode
tags: [leetcode, knowledge]
created: 2026-02-17
updated: 2026-02-17
status: active
source: leetcode
difficulty: Easy
complexity_time: O(1)
complexity_space: O(1)
review_interval_days: 14
next_review: 2026-03-03
---
# q401. Binary Watch / 二進位手錶
[401. Binary Watch](https://leetcode.com/problems/binary-watch/)

Easy

Topics

Companies

A binary watch has 4 LEDs on the top to represent the hours (`0-11`), and 6 LEDs on the bottom to represent the minutes (`0-59`). Each LED represents a zero or one, with the least significant bit on the right.
二進位手錶上方有 4 顆 LED 代表小時（`0-11`），下方有 6 顆 LED 代表分鐘（`0-59`）。每顆 LED 代表 0 或 1，且最右邊是最低有效位（LSB）。

For example, the below binary watch reads `"4:51"`.
例如，下圖二進位手錶可讀作 `"4:51"`。

Given an integer `turnedOn` which represents the number of LEDs that are currently on (ignoring the PM), return all possible times the watch could represent. You may return the answer in **any order**.
給定整數 `turnedOn`，表示目前亮起的 LED 顆數（不考慮 AM/PM），請回傳手錶所有可能表示的時間，答案順序不限。

The hour must not contain a leading zero.
小時不能有前導零。

- For example, `"01:00"` is not valid. It should be `"1:00"`.
- 例如 `"01:00"` 不合法，應寫成 `"1:00"`。

The minute must consist of two digits and may contain a leading zero.
分鐘必須固定兩位數，允許前導零。

- For example, `"10:2"` is not valid. It should be `"10:02"`.
- 例如 `"10:2"` 不合法，應寫成 `"10:02"`。

**Example 1:**

**Input:** turnedOn = 1
**Output:** ["0:01","0:02","0:04","0:08","0:16","0:32","1:00","2:00","4:00","8:00"]
**Explanation:** Exactly one LED is on, so valid times are those where hour+minute bit count equals 1.
**說明：** 只有一顆 LED 亮起，因此所有「小時位元 1 的數量 + 分鐘位元 1 的數量 = 1」的時間都合法。

**Example 2:**

**Input:** turnedOn = 9
**Output:** []
**Explanation:** A valid time cannot have 9 LEDs on under the `0..11` hour and `0..59` minute constraints.
**說明：** 在小時 `0..11`、分鐘 `0..59` 的限制下，不可能同時有 9 顆 LED 亮起。

**Constraints:**

- `0 <= turnedOn <= 10`
- `0 <= turnedOn <= 10`。

## 解題筆記與程式碼

通用演算法筆記：[bounded_enumeration_popcount_filter](../algorithm/bounded_enumeration_popcount_filter.md)
資料結構筆記：[fixed_width_bitmask_integer](../data_structure/fixed_width_bitmask_integer.md)

### 思路拆解

- 這題範圍很小且固定：小時只有 `12` 種、分鐘只有 `60` 種，直接枚舉全部 `12 * 60 = 720` 個時間最穩定。
- 對每個 `(hour, minute)`，計算 `hour.count_ones() + minute.count_ones()`，等於 `turnedOn` 就收進答案。
- 輸出格式注意：小時不用補零、分鐘要補成兩位（`{:02}`）。

### 演算法

1. 設 `target = turnedOn`。
2. 迴圈 `hour` 從 `0..11`，`minute` 從 `0..59`。
3. 若 `popcount(hour) + popcount(minute) == target`，加入 `format!("{}:{:02}", hour, minute)`。
4. 回傳答案。

### 時間與空間

- 時間：`O(12 * 60)`，為固定常數，可視為 `O(1)`。
- 空間：`O(1)`（不含輸出）。

```rust
impl Solution {
    pub fn read_binary_watch(turned_on: i32) -> Vec<String> {
        let target = turned_on as u32;
        let mut ans = Vec::new();

        for hour in 0..12u32 {
            for minute in 0..60u32 {
                if hour.count_ones() + minute.count_ones() == target {
                    ans.push(format!("{}:{:02}", hour, minute));
                }
            }
        }

        ans
    }
}
```

## Related problems / 相關題目

- [q190](./q190.md)
- [191. Number of 1 Bits](https://leetcode.com/problems/number-of-1-bits/)
- [338. Counting Bits](https://leetcode.com/problems/counting-bits/)
