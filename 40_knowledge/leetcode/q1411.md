---
title: q1411. Number of Ways to Paint N × 3 Grid / 給 N x 3 網格塗色的方案數
note_type: knowledge
domain: leetcode
tags: [leetcode, knowledge]
created: 2026-02-03
updated: 2026-02-03
status: active
source: leetcode
complexity_time: O(n)
complexity_space: O(1)
review_interval_days: 14
next_review: 2026-02-17
---
# q1411. Number of Ways to Paint N × 3 Grid / 給 N x 3 網格塗色的方案數
[1411. Number of Ways to Paint N × 3 Grid](https://leetcode.com/problems/number-of-ways-to-paint-n-3-grid/)

Hard

Topics

![premium lock icon](https://leetcode.com/_next/static/images/lock-a6627e2c7fa0ce8bc117c109fb4e567d.svg)Companies

Hint

You have a `grid` of size `n x 3` and you want to paint each cell of the grid with exactly one of the three colors: **Red**, **Yellow,** or **Green** while making sure that no two adjacent cells have the same color (i.e., no two cells that share vertical or horizontal sides have the same color).
你有一個大小為 `n x 3` 的網格，要用三種顏色：**紅**、**黃**、**綠**，為每格塗上恰好一種顏色，並確保任兩個相鄰格子（水平或垂直相鄰）顏色不同。

Given `n` the number of rows of the grid, return _the number of ways_ you can paint this `grid`. As the answer may grow large, the answer **must be** computed modulo `10^9 + 7`.
給定網格列數 `n`，回傳塗色方案數。答案可能很大，必須對 `10^9 + 7` 取模。

**Example 1:**

![](https://assets.leetcode.com/uploads/2020/03/26/e1.png)

**Input:** n = 1
**Output:** 12
**Explanation:** There are 12 possible way to paint the grid as shown.
**說明：** 如圖共有 12 種塗法。

**Example 2:**

**Input:** n = 5000
**Output:** 30228214

**Constraints:**

- `n == grid.length`
- `1 <= n <= 5000`
- `n == grid.length`。
- `1 <= n <= 5000`。

## 解題筆記與程式碼

通用演算法筆記：[dp_dynamic_programming](../algorithm/dp_dynamic_programming.md)

### 思路拆解

- 每列只有 3 格，合法列型態只分兩類：`ABA`（兩色且首尾同色）與 `ABC`（三色皆不同）。
- 把每一列的塗法數量壓縮成兩個計數：`a` 代表 `ABC`，`b` 代表 `ABA`。
- 相鄰列只受垂直限制，且顏色只有 3 種，轉移數量只與型態有關，與實際顏色無關。

### 轉移關係（只需兩種型態）

- 例：上一列為 `1,2,3`（`ABC`），新列為 `ABA` 時 `A` 只能選 2，`B` 有 2 種，因此 `ABC -> ABA` 為 2。
- 例：上一列為 `1,2,1`（`ABA`），新列為 `ABA` 時 `A` 可選 2 或 3；若 `A=2` 則 `B` 有 2 種，若 `A=3` 則 `B` 有 1 種，共 3。
- 依同樣方式可得：
  - `ABC -> ABC`: 2
  - `ABC -> ABA`: 2
  - `ABA -> ABC`: 2
  - `ABA -> ABA`: 3
- 轉移式：
  - `a' = 2a + 2b`
  - `b' = 2a + 3b`

### 演算法

1. 初始化 `a = 6`、`b = 6`（第一列 `ABC` 與 `ABA` 各 6 種）。
2. 從第 2 列到第 `n` 列，依轉移式更新 `a`、`b` 並取模。
3. 回傳 `(a + b) % MOD`。

### 時間與空間

- 時間：`O(n)`
- 空間：`O(1)`

```rust
const MOD: i64 = 1_000_000_007;

impl Solution {
    pub fn num_of_ways(n: i32) -> i32 {
        let n = n as usize;
        if n == 1 {
            return 12;
        }

        let mut a: i64 = 6; // ABC
        let mut b: i64 = 6; // ABA

        for _ in 2..=n {
            let new_a = (2 * a + 2 * b) % MOD;
            let new_b = (2 * a + 3 * b) % MOD;
            a = new_a;
            b = new_b;
        }

        ((a + b) % MOD) as i32
    }
}
```
