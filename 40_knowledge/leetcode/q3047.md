---
title: q3047. Find the Largest Area of Square Inside Two Rectangles / 求兩個矩形內最大正方形面積
note_type: knowledge
domain: leetcode
tags: [leetcode, knowledge]
created: 2026-02-03
updated: 2026-02-03
status: active
source: leetcode
complexity_time: O(n^2)
complexity_space: O(1)
review_interval_days: 14
next_review: 2026-02-17
---
# q3047. Find the Largest Area of Square Inside Two Rectangles / 求兩個矩形內最大正方形面積
[3047. Find the Largest Area of Square Inside Two Rectangles](https://leetcode.com/problems/find-the-largest-area-of-square-inside-two-rectangles/)

Medium

Topics

![premium lock icon](https://leetcode.com/_next/static/images/lock-a6627e2c7fa0ce8bc117c109fb4e567d.svg)Companies

Hint

There exist `n` rectangles in a 2D plane with edges parallel to the x and y axis. You are given two 2D integer arrays `bottomLeft` and `topRight` where `bottomLeft[i] = [a_i, b_i]` and `topRight[i] = [c_i, d_i]` represent the **bottom-left** and **top-right** coordinates of the `ith` rectangle, respectively.
平面上有 `n` 個與 x、y 軸平行的矩形。給定二維整數陣列 `bottomLeft` 與 `topRight`，其中 `bottomLeft[i] = [a_i, b_i]`、`topRight[i] = [c_i, d_i]` 分別代表第 `i` 個矩形的 **左下角** 與 **右上角** 座標。

You need to find the **maximum** area of a **square** that can fit inside the intersecting region of at least two rectangles. Return `0` if such a square does not exist.
你需要找出可放入「至少兩個矩形交集區域」內的 **最大** 正方形面積；若不存在，回傳 `0`。

**Example 1:**

![](https://assets.leetcode.com/uploads/2024/01/05/example12.png)

**Input:** bottomLeft = [ [1,1],[2,2],[3,1] ], topRight = [ [3,3],[4,4],[6,6] ]
**Output:** 1
**Explanation:**
A square with side length 1 can fit inside either the intersecting region of rectangles 0 and 1 or the intersecting region of rectangles 1 and 2. Hence the maximum area is 1. It can be shown that a square with a greater side length can not fit inside any intersecting region of two rectangles.
邊長為 1 的正方形可以放在矩形 0 與 1 的交集，或矩形 1 與 2 的交集，因此最大面積為 1。可證明更大的正方形無法放入任何兩個矩形的交集。

**Example 2:**

![](https://assets.leetcode.com/uploads/2024/07/15/diag.png)

**Input:** bottomLeft = [ [1,1],[1,3],[1,5] ], topRight = [ [5,5],[5,7],[5,9] ]
**Output:** 4
**Explanation:**
A square with side length 2 can fit inside either the intersecting region of rectangles 0 and 1 or the intersecting region of rectangles 1 and 2. Hence the maximum area is `2 * 2 = 4`. It can be shown that a square with a greater side length can not fit inside any intersecting region of two rectangles.
邊長為 2 的正方形可以放在矩形 0 與 1 的交集，或矩形 1 與 2 的交集，因此最大面積為 `2 * 2 = 4`。可證明更大的正方形無法放入任何兩個矩形的交集。

**Example 3:**

![](https://assets.leetcode.com/uploads/2024/01/04/rectanglesexample2.png)

**Input:** bottomLeft = [ [1,1],[2,2],[1,2] ], topRight = [ [3,3],[4,4],[3,4] ]
**Output:** 1
**Explanation:**
A square with side length 1 can fit inside the intersecting region of any two rectangles. Also, no larger square can, so the maximum area is 1. Note that the region can be formed by the intersection of more than 2 rectangles.
邊長為 1 的正方形可以放在任意兩個矩形的交集內，也無法放入更大的正方形，因此最大面積為 1。注意交集也可能是多於兩個矩形共同形成的區域。

**Example 4:**

![](https://assets.leetcode.com/uploads/2024/01/04/rectanglesexample3.png)

**Input:** bottomLeft = [ [1,1],[3,3],[3,1] ], topRight = [ [2,2],[4,4],[4,2] ]
**Output:** 0
**Explanation:**
No pair of rectangles intersect, hence, the answer is 0.
沒有任何矩形對互相交疊，因此答案為 0。

**Constraints:**

- `n == bottomLeft.length == topRight.length`
- `2 <= n <= 10^3`
- `bottomLeft[i].length == topRight[i].length == 2`
- `1 <= bottomLeft[i][0], bottomLeft[i][1] <= 10^7`
- `1 <= topRight[i][0], topRight[i][1] <= 10^7`
- `bottomLeft[i][0] < topRight[i][0]`
- `bottomLeft[i][1] < topRight[i][1]`
- `n == bottomLeft.length == topRight.length`。
- `2 <= n <= 10^3`。
- `bottomLeft[i].length == topRight[i].length == 2`。
- `1 <= bottomLeft[i][0], bottomLeft[i][1] <= 10^7`。
- `1 <= topRight[i][0], topRight[i][1] <= 10^7`。
- `bottomLeft[i][0] < topRight[i][0]`。
- `bottomLeft[i][1] < topRight[i][1]`。

## 解題筆記與程式碼

通用演算法筆記：[axis_aligned_rectangle_intersection](../algorithm/axis_aligned_rectangle_intersection.md)
資料結構筆記：[pairwise_index_scan](../data_structure/pairwise_index_scan.md)

### 思路拆解

- 目標是「至少兩個矩形交集」內可放的最大正方形；任何多矩形交集都是某個矩形對交集的子集合，因此最大正方形一定來自某一對矩形。
- 對每一對矩形計算交集矩形的寬 `w` 與高 `h`；若 `w <= 0` 或 `h <= 0` 代表不相交。
- 交集內可放的最大正方形邊長為 `min(w, h)`，面積為 `side^2`，取所有矩形對的最大值即可。

### 為什麼只需要兩兩枚舉

- 若一個正方形能放入「至少兩個矩形」的交集，則必定能放入其中任一對矩形的交集中。
- 因此最大答案必定出現在某個矩形對的交集內，枚舉所有矩形對即可覆蓋。

### 演算法

1. 令答案 `best = 0`。
2. 對所有 `i < j`：
   - 交集寬度 `w = min(x2_i, x2_j) - max(x1_i, x1_j)`。
   - 交集高度 `h = min(y2_i, y2_j) - max(y1_i, y1_j)`。
   - 若 `w > 0` 且 `h > 0`，則 `side = min(w, h)`，更新 `best = max(best, side^2)`。
3. 回傳 `best`。

### 時間與空間

- 時間：`O(n^2)`，枚舉所有矩形對。
- 空間：`O(1)` 額外空間。

```rust
impl Solution {
    pub fn largest_square_area(bottom_left: Vec<Vec<i32>>, top_right: Vec<Vec<i32>>) -> i64 {
        let n = bottom_left.len();
        let mut best: i64 = 0;

        for i in 0..n {
            for j in (i + 1)..n {
                let left = bottom_left[i][0].max(bottom_left[j][0]) as i64;
                let right = top_right[i][0].min(top_right[j][0]) as i64;
                let bottom = bottom_left[i][1].max(bottom_left[j][1]) as i64;
                let top = top_right[i][1].min(top_right[j][1]) as i64;

                let w = right - left;
                let h = top - bottom;
                if w > 0 && h > 0 {
                    let side = if w < h { w } else { h };
                    let area = side * side;
                    if area > best {
                        best = area;
                    }
                }
            }
        }

        best
    }
}
```
