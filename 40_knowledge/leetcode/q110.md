---
title: q110. Balanced Binary Tree / 平衡二元樹
note_type: knowledge
domain: leetcode
tags: [leetcode, knowledge]
created: 2026-02-08
updated: 2026-02-08
status: active
source: leetcode
difficulty: Easy
complexity_time: O(n)
complexity_space: O(h)
review_interval_days: 14
next_review: 2026-02-22
---
# q110. Balanced Binary Tree / 平衡二元樹
[110. Balanced Binary Tree](https://leetcode.com/problems/balanced-binary-tree/)

Easy

Topics

![premium lock icon](https://leetcode.com/_next/static/images/lock-a6627e2c7fa0ce8bc117c109fb4e567d.svg)Companies

Given a binary tree, determine if it is height-balanced.
給定一棵二元樹，判斷它是否為高度平衡（height-balanced）。

A height-balanced binary tree is defined as a binary tree in which the left and right subtrees of every node differ in height by no more than `1`.
高度平衡二元樹的定義是：每個節點的左、右子樹高度差都不超過 `1`。

**Example 1:**

**Input:** root = [3,9,20,null,null,15,7]
**Output:** true
**輸入：** root = [3,9,20,null,null,15,7]
**輸出：** true

**Example 2:**

**Input:** root = [1,2,2,3,3,null,null,4,4]
**Output:** false
**輸入：** root = [1,2,2,3,3,null,null,4,4]
**輸出：** false

**Example 3:**

**Input:** root = []
**Output:** true
**輸入：** root = []
**輸出：** true

**Constraints:**

- The number of nodes in the tree is in the range `[0, 5000]`.
- `-10^4 <= Node.val <= 10^4`
- 樹的節點數量介於 `[0, 5000]`。
- `-10^4 <= Node.val <= 10^4`。

## 解題筆記與程式碼

通用演算法筆記：[tree_postorder_height_balance_check](../algorithm/tree_postorder_height_balance_check.md)
資料結構筆記：[binary_tree](../data_structure/binary_tree.md)

### 思路拆解

- 直覺做法是對每個節點都重新計算左右高度，會退化成 `O(n^2)`。
- 正確做法是「後序 DFS」：先拿到左右子樹結果，再決定當前節點是否平衡。
- `dfs(node)` 回傳高度；若子樹已不平衡，直接回傳特殊值 `-1` 代表 fail，往上層一路早停。
- 當前節點若 `abs(left_h - right_h) > 1`，同樣回傳 `-1`。
- 最終只要檢查 `dfs(root) != -1`。

### 演算法

1. 定義 `height_or_fail(node) -> i32`。
2. 若 `node` 為空，回傳高度 `0`。
3. 遞迴取得左子樹高度 `lh`；若 `lh == -1` 直接回傳 `-1`。
4. 遞迴取得右子樹高度 `rh`；若 `rh == -1` 直接回傳 `-1`。
5. 若 `|lh - rh| > 1`，回傳 `-1`。
6. 否則回傳 `max(lh, rh) + 1`。
7. 主函式回傳 `height_or_fail(root) != -1`。

### 時間與空間

- 時間：`O(n)`，每個節點最多被訪問一次。
- 空間：`O(h)`，遞迴堆疊深度，`h` 為樹高（最壞 `O(n)`）。

```rust
// Definition for a binary tree node.
// #[derive(Debug, PartialEq, Eq)]
// pub struct TreeNode {
//   pub val: i32,
//   pub left: Option<Rc<RefCell<TreeNode>>>,
//   pub right: Option<Rc<RefCell<TreeNode>>>,
// }
//
// impl TreeNode {
//   #[inline]
//   pub fn new(val: i32) -> Self {
//     TreeNode {
//       val,
//       left: None,
//       right: None
//     }
//   }
// }

use std::cell::RefCell;
use std::rc::Rc;

impl Solution {
    pub fn is_balanced(root: Option<Rc<RefCell<TreeNode>>>) -> bool {
        fn height_or_fail(node: Option<Rc<RefCell<TreeNode>>>) -> i32 {
            if node.is_none() {
                return 0;
            }

            let rc = node.unwrap();
            let (left, right) = {
                let n = rc.borrow();
                (n.left.clone(), n.right.clone())
            };

            let lh = height_or_fail(left);
            if lh == -1 {
                return -1;
            }

            let rh = height_or_fail(right);
            if rh == -1 {
                return -1;
            }

            if (lh - rh).abs() > 1 {
                -1
            } else {
                lh.max(rh) + 1
            }
        }

        height_or_fail(root) != -1
    }
}
```

## 補充筆記

- `-1` sentinel 讓「高度計算」與「平衡檢查」合併在同一趟 DFS，避免重複走訪。
- 若語言遞迴深度限制較嚴，可改成顯式堆疊做後序遍歷。
