---
title: q756. Pyramid Transition Matrix / 金字塔轉換矩陣
note_type: knowledge
domain: leetcode
tags: [leetcode, knowledge]
created: 2026-02-03
updated: 2026-02-03
status: active
source: leetcode
complexity_time: O(6^n)
complexity_space: O(S)
review_interval_days: 14
next_review: 2026-02-17
---
# q756. Pyramid Transition Matrix / 金字塔轉換矩陣
[756. Pyramid Transition Matrix](https://leetcode.com/problems/pyramid-transition-matrix/)

Medium

Topics

![premium lock icon](https://leetcode.com/_next/static/images/lock-a6627e2c7fa0ce8bc117c109fb4e567d.svg)Companies

You are stacking blocks to form a pyramid. Each block has a color, which is represented by a single letter. Each row of blocks contains **one less block** than the row beneath it and is centered on top.
你正在堆疊方塊形成金字塔。每個方塊是一種顏色，用單一字母表示。每一層的方塊數量比下方少 **一個**，並置中排列。

To make the pyramid aesthetically pleasing, there are only specific **triangular patterns** that are allowed. A triangular pattern consists of a **single block** stacked on top of **two blocks**. The patterns are given as a list of three-letter strings `allowed`, where the first two characters of a pattern represent the left and right bottom blocks respectively, and the third character is the top block.
為了讓金字塔美觀，只允許特定的 **三角形樣式**。三角形樣式由 **一個** 方塊疊在 **兩個** 方塊之上構成。樣式以三字母字串 `allowed` 給定，前兩個字母代表底層左、右方塊，第三個字母代表上層方塊。

- For example, `"ABC"` represents a triangular pattern with a `'C'` block stacked on top of an `'A'` (left) and `'B'` (right) block. Note that this is different from `"BAC"` where `'B'` is on the left bottom and `'A'` is on the right bottom.
例如，`"ABC"` 代表上方是 `'C'`，下方左邊是 `'A'`、右邊是 `'B'`。注意這不同於 `"BAC"`，因為左下和右下順序不同。

You start with a bottom row of blocks `bottom`, given as a single string, that you **must** use as the base of the pyramid.
你從底層字串 `bottom` 開始，並 **必須** 把它作為金字塔的底座。

Given `bottom` and `allowed`, return `true` _if you can build the pyramid all the way to the top such that **every triangular pattern** in the pyramid is in_ `allowed`_, or_ `false` _otherwise_.
給定 `bottom` 與 `allowed`，若你能從底層一路堆到頂部，且金字塔中的 **每個三角形樣式** 都在 `allowed` 內，回傳 `true`，否則回傳 `false`。

**Example 1:**

![](https://assets.leetcode.com/uploads/2021/08/26/pyramid1-grid.jpg)

**Input:** bottom = "BCD", allowed = ["BCC","CDE","CEA","FFF"]
**Output:** true
**Explanation:** The allowed triangular patterns are shown on the right.
Starting from the bottom (level 3), we can build "CE" on level 2 and then build "A" on level 1.
There are three triangular patterns in the pyramid, which are "BCC", "CDE", and "CEA". All are allowed.
**輸入：** bottom = "BCD", allowed = ["BCC","CDE","CEA","FFF"]
**輸出：** true
**說明：** 右側顯示可用的三角形樣式。從底層（第 3 層）開始，可在第 2 層建出 "CE"，再在第 1 層建出 "A"。金字塔中的三角形樣式為 "BCC"、"CDE"、"CEA"，全部都在 allowed 中。

**Example 2:**

![](https://assets.leetcode.com/uploads/2021/08/26/pyramid2-grid.jpg)

**Input:** bottom = "AAAA", allowed = ["AAB","AAC","BCD","BBE","DEF"]
**Output:** false
**Explanation:** The allowed triangular patterns are shown on the right.
Starting from the bottom (level 4), there are multiple ways to build level 3, but trying all the possibilites, you will get always stuck before building level 1.
**輸入：** bottom = "AAAA", allowed = ["AAB","AAC","BCD","BBE","DEF"]
**輸出：** false
**說明：** 右側顯示可用的三角形樣式。從底層（第 4 層）開始，雖然第 3 層有多種建法，但嘗試所有可能後都會在建到第 1 層之前卡住。

**Constraints:**

- `2 <= bottom.length <= 6`
- `0 <= allowed.length <= 216`
- `allowed[i].length == 3`
- The letters in all input strings are from the set `{'A', 'B', 'C', 'D', 'E', 'F'}`.
- All the values of `allowed` are **unique**.
- `2 <= bottom.length <= 6`
- `0 <= allowed.length <= 216`
- `allowed[i].length == 3`
- 所有字母皆屬於 `{'A','B','C','D','E','F'}`。
- `allowed` 內的字串皆 **不重複**。
---
## 解題筆記與程式碼

通用演算法筆記：[backtracking_dfs_memo](../algorithm/backtracking_dfs_memo.md)
資料結構筆記：[hash_map_set](../data_structure/hash_map_set.md)

### 思路拆解

- 觀察到每一層只依賴下一層相鄰兩塊的配對，因此可用 DFS 嘗試所有可能的上一層組合。
- 用 `allowed` 建立「底層兩字母 -> 上層可用字母集合」的映射，讓轉移只走有效分支。
- 為避免重複計算，針對每一層字串做記憶化：同樣的 row 若已經確認不可達頂層，就不再重算。

### 逐步示例（Example 1）

**輸入**

- `bottom = "BCD"`
- `allowed = ["BCC","CDE","CEA","FFF"]`

**步驟 1：建立配對規則**

- `BC -> [C]`（因為 "BCC"）
- `CD -> [E]`（因為 "CDE"）
- `CE -> [A]`（因為 "CEA"）
- `FF -> [F]`（因為 "FFF"；這個在本例不會用到）

**步驟 2：從底層往上生成第 2 層**

底層為 `"B C D"`，相鄰配對只有兩組：

- `B C` 可變成 `C`
- `C D` 可變成 `E`

所以第 2 層唯一可能是 `"CE"`。

**步驟 3：由第 2 層生成頂層**

第 2 層為 `"C E"`：

- `C E` 可變成 `A`

所以頂層是 `"A"`，成功完成金字塔。

**結論**

- 本例使用到的三角形樣式只有 `"BCC"`, `"CDE"`, `"CEA"`。
- `"FFF"` 只是 allowed 中的可用樣式之一，實際沒有被使用，也不影響是否能成功建塔。

### 為什麼要 DFS + 記憶化（從這個例子延伸）

- 每一層的每個位置可能對應多個上層字母（例如 `AA -> [B, C]`），會形成分支。
- DFS 會嘗試所有可行組合，只要任一組能到頂層就回傳 `true`。
- 記憶化可以避免同一個 row 重複計算（例如不同路徑生成相同的中間層）。

### 演算法

1. 建立 `pair -> tops` 的映射（`HashMap` 或 6x6 Vec）。
2. 定義 `can_build(row)`：
   - 若 `row.len() == 1`，回傳 `true`。
   - 若 `row` 在 memo 中，直接回傳結果。
   - 透過回溯生成所有可能的 `next_row`，只要任何一個 `can_build(next_row)` 為真就回傳 `true`。
   - 若全部失敗，記錄 memo 後回傳 `false`。
3. 回傳 `can_build(bottom)`。

### 時間與空間

- 時間：`O(6^n)`
- 空間：`O(S)`

Where:
`n`: length of `bottom` string.
`S`: number of distinct row states cached in memo.


```rust
use std::collections::HashMap;

impl Solution {
    pub fn pyramid_transition(bottom: String, allowed: Vec<String>) -> bool {
        let mut trans: Vec<Vec<Vec<u8>>> = vec![vec![Vec::new(); 6]; 6];
        for s in allowed {
            let b = s.as_bytes();
            let a = (b[0] - b'A') as usize;
            let c = (b[1] - b'A') as usize;
            trans[a][c].push(b[2]);
        }

        let mut memo: HashMap<Vec<u8>, bool> = HashMap::new();
        let row = bottom.into_bytes();
        can_build(row, &trans, &mut memo)
    }
}

fn can_build(
    row: Vec<u8>,
    trans: &Vec<Vec<Vec<u8>>>,
    memo: &mut HashMap<Vec<u8>, bool>,
) -> bool {
    if row.len() == 1 {
        return true;
    }
    if let Some(&cached) = memo.get(&row) {
        return cached;
    }

    let mut next: Vec<u8> = Vec::with_capacity(row.len() - 1);
    let ok = build_next(0, &row, &mut next, trans, memo);
    memo.insert(row, ok);
    ok
}

fn build_next(
    idx: usize,
    row: &[u8],
    next: &mut Vec<u8>,
    trans: &Vec<Vec<Vec<u8>>>,
    memo: &mut HashMap<Vec<u8>, bool>,
) -> bool {
    if idx == row.len() - 1 {
        return can_build(next.clone(), trans, memo);
    }
    let a = (row[idx] - b'A') as usize;
    let b = (row[idx + 1] - b'A') as usize;
    for &top in trans[a][b].iter() {
        next.push(top);
        if build_next(idx + 1, row, next, trans, memo) {
            return true;
        }
        next.pop();
    }
    false
}
```