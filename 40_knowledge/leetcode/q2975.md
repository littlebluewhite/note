---
title: q2975. Maximum Square Area by Removing Fences From a Field / 移除柵欄後田地的最大正方形面積
note_type: knowledge
domain: leetcode
tags: [leetcode, knowledge]
created: 2023-11-05
updated: 2026-02-03
status: active
source: leetcode
complexity_time: O(H^2 + V^2)
complexity_space: O(H^2)
review_interval_days: 14
next_review: 2023-11-19
canonical: leetcode/q2975.md
---
# q2975. Maximum Square Area by Removing Fences From a Field / 移除柵欄後田地的最大正方形面積
[2975. Maximum Square Area by Removing Fences From a Field](https://leetcode.com/problems/maximum-square-area-by-removing-fences-from-a-field/)

Medium

Topics

![premium lock icon](https://leetcode.com/_next/static/images/lock-a6627e2c7fa0ce8bc117c109fb4e567d.svg)Companies

Hint

There is a large `(m - 1) x (n - 1)` rectangular field with corners at `(1, 1)` and `(m, n)` containing some horizontal and vertical fences given in arrays `hFences` and `vFences` respectively.
有一塊大的 `(m - 1) x (n - 1)` 矩形田地，四角在 `(1, 1)` 與 `(m, n)`，內部有水平與垂直柵欄，分別由陣列 `hFences` 與 `vFences` 給定。

Horizontal fences are from the coordinates `(hFences[i], 1)` to `(hFences[i], n)` and vertical fences are from the coordinates `(1, vFences[i])` to `(m, vFences[i])`.
水平柵欄從座標 `(hFences[i], 1)` 到 `(hFences[i], n)`，垂直柵欄從座標 `(1, vFences[i])` 到 `(m, vFences[i])`。

Return _the **maximum** area of a **square** field that can be formed by **removing** some fences (**possibly none**) or_ `-1` _if it is impossible to make a square field_.
請回傳透過移除部分柵欄（**可以不移除**）所能形成的 **最大** 正方形面積；若無法形成正方形則回傳 `-1`。

Since the answer may be large, return it **modulo** `10^9 + 7`.
由於答案可能很大，請對 `10^9 + 7` 取模。

**Note:** The field is surrounded by two horizontal fences from the coordinates `(1, 1)` to `(1, n)` and `(m, 1)` to `(m, n)` and two vertical fences from the coordinates `(1, 1)` to `(m, 1)` and `(1, n)` to `(m, n)`. These fences **cannot** be removed.
**注意：** 田地外圍有兩條水平柵欄 `(1, 1)` 到 `(1, n)`、`(m, 1)` 到 `(m, n)`，以及兩條垂直柵欄 `(1, 1)` 到 `(m, 1)`、`(1, n)` 到 `(m, n)`，這些柵欄 **不可** 移除。

**Example 1:**

![](https://assets.leetcode.com/uploads/2023/11/05/screenshot-from-2023-11-05-22-40-25.png)

**Input:** m = 4, n = 3, hFences = [2,3], vFences = [2]
**Output:** 4
**Explanation:** Removing the horizontal fence at 2 and the vertical fence at 2 will give a square field of area 4.
**說明：** 移除水平柵欄 2 與垂直柵欄 2，可形成面積為 4 的正方形。

**Example 2:**

![](https://assets.leetcode.com/uploads/2023/11/22/maxsquareareaexample1.png)

**Input:** m = 6, n = 7, hFences = [2], vFences = [4]
**Output:** -1
**Explanation:** It can be proved that there is no way to create a square field by removing fences.
**說明：** 可以證明無論移除哪些柵欄都無法形成正方形。

**Constraints:**

- `3 <= m, n <= 10^9`
- `1 <= hFences.length, vFences.length <= 600`
- `1 < hFences[i] < m`
- `1 < vFences[i] < n`
- `hFences` and `vFences` are unique.
- `3 <= m, n <= 10^9`。
- `1 <= hFences.length, vFences.length <= 600`。
- `1 < hFences[i] < m`。
- `1 < vFences[i] < n`。
- `hFences` 與 `vFences` 內元素不重複。

## 解題筆記與程式碼

通用演算法筆記：[pairwise_distance_enumeration](../algorithm/pairwise_distance_enumeration.md)
通用資料結構筆記：[hash_map_set](../data_structure/hash_map_set.md)

### 思路拆解

- 移除柵欄後，任意兩條水平柵欄之間的距離都能成為高度；垂直方向亦同。
- 只要某個距離同時出現在水平與垂直方向，就能形成邊長為該距離的正方形。
- 先列舉水平所有兩兩距離放進 `HashSet`，再掃描垂直距離找最大交集。

### 演算法

1. 將邊界 `1`、`m` 加入 `hFences`，邊界 `1`、`n` 加入 `vFences`，排序。
2. 列舉所有水平兩兩距離，存入 `HashSet`。
3. 列舉垂直兩兩距離，若存在於 `HashSet`，更新最大邊長。
4. 若最大邊長不存在回傳 `-1`，否則回傳 `side^2 mod (10^9 + 7)`。

### 為什麼可行

移除柵欄等同於把相鄰區塊合併，因此任意兩條保留的柵欄之間距離都可形成邊界。水平與垂直同時存在的距離，即可構成正方形的邊長。

### 時間與空間

- 時間：`O(H^2 + V^2)`，`H = hFences.length + 2`，`V = vFences.length + 2`。
- 空間：`O(H^2)`，儲存水平距離集合。

```rust
use std::collections::HashSet;

impl Solution {
    pub fn maximize_square_area(m: i32, n: i32, h_fences: Vec<i32>, v_fences: Vec<i32>) -> i32 {
        const MOD: i64 = 1_000_000_007;

        let mut h: Vec<i64> = h_fences.into_iter().map(|x| x as i64).collect();
        let mut v: Vec<i64> = v_fences.into_iter().map(|x| x as i64).collect();
        h.push(1);
        h.push(m as i64);
        v.push(1);
        v.push(n as i64);
        h.sort_unstable();
        v.sort_unstable();

        let mut hset: HashSet<i64> = HashSet::new();
        for i in 0..h.len() {
            for j in (i + 1)..h.len() {
                hset.insert(h[j] - h[i]);
            }
        }

        let mut max_side: i64 = -1;
        for i in 0..v.len() {
            for j in (i + 1)..v.len() {
                let d = v[j] - v[i];
                if hset.contains(&d) && d > max_side {
                    max_side = d;
                }
            }
        }

        if max_side < 0 {
            return -1;
        }
        let area = (max_side % MOD) * (max_side % MOD) % MOD;
        area as i32
    }
}
```

## Related problems / 相關題目

- [1465. Maximum Area of a Piece of Cake After Horizontal and Vertical Cuts](https://leetcode.com/problems/maximum-area-of-a-piece-of-cake-after-horizontal-and-vertical-cuts/) / 水平垂直切割後的最大面積
