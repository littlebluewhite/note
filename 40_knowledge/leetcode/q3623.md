---
title: q3623. Count Number of Trapezoids I / 統計梯形數量 I
note_type: knowledge
domain: leetcode
tags: [leetcode, knowledge]
created: 2026-02-03
updated: 2026-02-03
status: active
source: leetcode
complexity_time: O(n + m)
complexity_space: O(m)
review_interval_days: 14
next_review: 2026-02-17
---
# q3623. Count Number of Trapezoids I / 統計梯形數量 I
[3623. Count Number of Trapezoids I](https://leetcode.com/problems/count-number-of-trapezoids-i/)

Medium

Topics

![premium lock icon](https://leetcode.com/_next/static/images/lock-a6627e2c7fa0ce8bc117c109fb4e567d.svg)Companies

Hint

You are given a 2D integer array `points`, where `points[i] = [xi, yi]` represents the coordinates of the `ith` point on the Cartesian plane.
給定二維整數陣列 `points`，其中 `points[i] = [xi, yi]` 表示平面上第 i 個點的座標。

A **horizontal** **trapezoid** is a convex quadrilateral with **at least one pair** of horizontal sides (i.e. parallel to the x-axis). Two lines are parallel if and only if they have the same slope.
**水平梯形** 是一個凸四邊形，至少有一對邊平行於 x 軸；兩直線斜率相同即為平行。

Return the _number of unique_ **_horizontal_ _trapezoids_** that can be formed by choosing any four distinct points from `points`.
請回傳從 `points` 中任取四個不同點能形成的不同水平梯形數量。

Since the answer may be very large, return it **modulo** `109 + 7`.
答案可能很大，請對 `1e9+7` 取模。

**Example 1:**

**Input:** points = [ [1,0],[2,0],[3,0],[2,2],[3,2] ]
**Output:** 3

**Explanation:**

![](https://assets.leetcode.com/uploads/2025/05/01/desmos-graph-6.png)![](https://assets.leetcode.com/uploads/2025/05/01/desmos-graph-7.png)![](https://assets.leetcode.com/uploads/2025/05/01/desmos-graph-8.png)

There are three distinct ways to pick four points that form a horizontal trapezoid:

- Using points `[1,0]`, `[2,0]`, `[3,2]`, and `[2,2]`.
- Using points `[2,0]`, `[3,0]`, `[3,2]`, and `[2,2]`.
- Using points `[1,0]`, `[3,0]`, `[3,2]`, and `[2,2]`.

**Example 2:**

**Input:** points = [ [0,0],[1,0],[0,1],[2,1] ]

**Output:** 1

**Explanation:**

![](https://assets.leetcode.com/uploads/2025/04/29/desmos-graph-5.png)

There is only one horizontal trapezoid that can be formed.

**Constraints:**

- `4 <= points.length <= 105`
- `–108 <= xi, yi <= 108`
- All points are pairwise distinct.

## 解題筆記與程式碼

通用演算法筆記：[combinatorics_counting](../algorithm/combinatorics_counting.md)
通用演算法筆記：[grouping_aggregation](../algorithm/grouping_aggregation.md)
資料結構筆記：[hash_map_set](../data_structure/hash_map_set.md)
### 核心觀察

- 水平梯形的兩條平行邊必須分別取自兩條不同的 y 軸水平線，各線至少需要兩個點。
- 對於同一條 y 線，能組成水平邊的選法數為 `C(cnt, 2)`；若我們只考慮這些「可當作邊的選法」，那麼任意兩條不同 y 線的組合就能形成一個梯形，組數為 `C(cnt1, 2) * C(cnt2, 2)`.
- 將所有 y 線的 `C(cnt, 2)` 記為 `b_i`，答案是 `sum_{i<j} b_i * b_j`。用恆等式 `sum_{i<j} b_i*b_j = ((sum b_i)^2 - sum b_i^2) / 2`，即可在 O(m) 完成（m 為不同 y 數）。

### 演算法

1. 用 `HashMap` 統計每個 y 值出現次數 `cnt`，若 `cnt >= 2` 計算 `b = C(cnt, 2)` 並收集起來。
2. 計算 `sum_b = Σ b` 與 `sum_b2 = Σ b^2`（都取模）。
3. 套入公式：`ans = ((sum_b^2 - sum_b2 + MOD) % MOD) * inv2 % MOD`，其中 `inv2 = (MOD + 1) / 2 = 500000004`.

### 範例檢驗

- Example 1：y=0 有 3 點 → `C(3,2)=3`，y=2 有 2 點 → `C(2,2)=1`，組合數 `3 * 1 = 3`，符合範例輸出。

### 時間與空間

- 時間：O(n + m)，n 為點數，m 為不同 y 數。
- 空間：O(m) 儲存每條 y 的點數與對應的組合數。

### Rust 程式碼

```rust
use std::collections::HashMap;

const MOD: i64 = 1_000_000_007;
const INV2: i64 = 500_000_004; // 2 在 MOD 下的乘法反元素

impl Solution {
    pub fn count_trapezoids(points: Vec<Vec<i32>>) -> i32 {
        let mut freq: HashMap<i32, i64> = HashMap::new();
        for p in points {
            let y = p[1];
            *freq.entry(y).or_insert(0) += 1;
        }

        let mut sum_b: i64 = 0;
        let mut sum_b2: i64 = 0;

        for &cnt in freq.values() {
            if cnt < 2 {
                continue;
            }
            let base = (cnt * (cnt - 1) / 2) % MOD; // 該 y 線能提供的水平邊選法
            sum_b = (sum_b + base) % MOD;
            let base_sq = ((base as i128 * base as i128) % MOD as i128) as i64;
            sum_b2 = (sum_b2 + base_sq) % MOD;
        }

        let mut ans = ((sum_b as i128 * sum_b as i128) % MOD as i128) as i64;
        ans = (ans - sum_b2) % MOD;
        if ans < 0 {
            ans += MOD;
        }
        ans = (ans * INV2) % MOD;

        ans as i32
    }
}
```


## 補充筆記：先按斜率分組算 `C(cnt, 2)`，再以同式計算兩兩乘積（需額外考慮凸性/共線重疊）。  
