---
title: q3573. Best Time to Buy and Sell Stock V / 買賣股票的最佳時機 V
note_type: knowledge
domain: leetcode
tags: [leetcode, knowledge]
created: 2026-02-03
updated: 2026-02-03
status: active
source: leetcode
difficulty: Medium
complexity_time: O(n * k)
complexity_space: O(k)
review_interval_days: 14
next_review: 2026-02-17
---
# q3573. Best Time to Buy and Sell Stock V / 買賣股票的最佳時機 V
[3573. Best Time to Buy and Sell Stock V](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-v/)

Medium

Topics

![premium lock icon](https://leetcode.com/_next/static/images/lock-a6627e2c7fa0ce8bc117c109fb4e567d.svg)Companies

Hint

You are given an integer array `prices` where `prices[i]` is the price of a stock in dollars on the `ith` day, and an integer `k`.
給定整數陣列 `prices`，其中 `prices[i]` 是第 `i` 天的股價，以及整數 `k`。

You are allowed to make at most `k` transactions, where each transaction can be either of the following:
允許最多進行 `k` 筆交易，每筆交易可以是下列兩種之一：

- **Normal transaction**: Buy on day `i`, then sell on a later day `j` where `i < j`. You profit `prices[j] - prices[i]`.
- **一般交易**：在第 `i` 天買入，之後第 `j (i < j)` 天賣出，獲利為 `prices[j] - prices[i]`。
    
- **Short selling transaction**: Sell on day `i`, then buy back on a later day `j` where `i < j`. You profit `prices[i] - prices[j]`.
- **放空交易**：在第 `i` 天賣出，之後第 `j (i < j)` 天買回，獲利為 `prices[i] - prices[j]`。
    

**Note** that you must complete each transaction before starting another. Additionally, you can't buy or sell on the same day you are selling or buying back as part of a previous transaction.
注意：必須先完成前一筆交易再開始下一筆；當天用來平倉（賣出或買回）的日子不能同時再買或賣以開啟新交易。

Return the **maximum** total profit you can earn by making **at most** `k` transactions.
請回傳最多進行 `k` 筆交易時可以得到的最大總獲利。

**Example 1:**

**Input:** prices = [1,7,9,8,2], k = 2

**Output:** 14

**Explanation:**

We can make $14 of profit through 2 transactions:
透過兩筆交易可以賺取 14 的獲利：

- A normal transaction: buy the stock on day 0 for $1 then sell it on day 2 for $9.
- A short selling transaction: sell the stock on day 3 for $8 then buy back on day 4 for $2.
- 一般交易：第 0 天用 1 買入，第 2 天用 9 賣出。
- 放空交易：第 3 天用 8 賣出，第 4 天用 2 買回。

**Example 2:**

**Input:** prices = [12,16,19,19,8,1,19,13,9], k = 3

**Output:** 36

**Explanation:**

We can make $36 of profit through 3 transactions:
透過三筆交易可以賺取 36 的獲利：

- A normal transaction: buy the stock on day 0 for $12 then sell it on day 2 for $19.
- A short selling transaction: sell the stock on day 3 for $19 then buy back on day 4 for $8.
- A normal transaction: buy the stock on day 5 for $1 then sell it on day 6 for $19.
- 一般交易：第 0 天以 12 買入，第 2 天以 19 賣出。
- 放空交易：第 3 天以 19 賣出，第 4 天以 8 買回。
- 一般交易：第 5 天以 1 買入，第 6 天以 19 賣出。

**Constraints:**

- `2 <= prices.length <= 103`
- `1 <= prices[i] <= 109`
- `1 <= k <= prices.length / 2`
- `2 <= prices.length <= 10^3`
- `1 <= prices[i] <= 10^9`
- `1 <= k <= prices.length / 2`

## 解題筆記與程式碼

DP 筆記：[dp_dynamic_programming](../algorithm/dp_dynamic_programming.md)

### 思路拆解

- 一筆交易一定是「先開倉再平倉」，且平倉當天不能再開新倉；這些限制都能靠 DP 的更新時序自然滿足。
- 同時允許做多/做空 ⇒ 需要兩種持倉狀態，加上一種空手狀態：`rest`（空手）、`long`（持多）、`short`（持空）。
- 交易數只在「平倉」時 +1；開倉不增加交易數，所以狀態要分層表示「已完成 t 筆交易」。
- 為了避免同日先平倉再開倉，當天的狀態僅從「前一日」讀取，算出「當日新陣列」後再整批覆蓋。

### 為什麼要三個陣列（一步一步）

1) 任何一天結束時，你可能是「空手」或「持多」或「持空」，三種情況互斥，故要三個容器分別存最佳收益。  
2) `rest[t]`：目前空手且已完成 `t` 筆交易，這是唯一能「開倉」的入口。  
3) `long[t]`：目前手上有多單，尚未算進完成的交易數；未平倉前只能選賣出。  
4) `short[t]`：目前手上有空單，同理尚未算進完成的交易數；未平倉前只能買回。  
5) 交易數在「平倉」瞬間才會 +1，所以平倉會從 `long/short[t]` 轉到 `rest[t+1]`。開倉不增加交易數，故從 `rest[t]` 轉到 `long/short[t]`。  
6) 依價格 `p` 走一天的更新順序（僅用前一日狀態）：  
   - 先算平倉：如果昨天持多，今天賣出賺 `+p`，進入 `next_rest[t+1]`；如果昨天持空，今天買回賺 `-p`，也進入 `next_rest[t+1]`。  
   - 再算開倉：只能用昨天的空手 `rest[t]` 去買入（變 `next_long[t]`）或賣出（變 `next_short[t]`）。  
   - 全程不會用「今天剛平倉得到的 `next_rest`」去開新倉，因為開倉讀的是昨天的 `rest`，自然禁止同日平倉再開倉。  
7) 走完所有天數，拿所有 `rest[0..=k]` 的最大值，因為只有空手狀態才代表交易都平掉，收益落袋。

### 核心觀察

- 任一交易只取決於開倉與平倉價差；做多或放空可視為兩種「持倉」狀態，獲利分別是 `+price`（賣出平倉多單）與 `-price`（買回平倉空單）。
- 不能在平倉當天重新開倉，使用「前一日的狀態更新當日」的 DP 即可自然禁止同日開收，無須額外冷卻旗標。
- 以「完成 t 筆交易」為狀態維度，維護三個陣列：`rest[t]`（空手）、`long[t]`（持多）、`short[t]`（持空）。開倉不增加交易數，平倉使交易數 +1。

### 演算法

1) 初始化：`rest[0] = 0`，其餘全設極小值（代表不可能）。  
2) 對每一天的價格 `p`：  
   - 先複製前一日的 `rest/long/short` 成為 `next_*`。  
   - 平倉：若持多/持空存在，就嘗試更新 `next_rest[t+1]` 為 `long[t] + p` 或 `short[t] - p`。  
   - 開倉：僅能用「前一日的空手」開倉，更新 `next_long[t] = max(next_long[t], rest[t] - p)`、`next_short[t] = max(next_short[t], rest[t] + p)`。  
   - 全部更新完後，`rest/long/short = next_*`。因為當天只用「舊 rest」開倉，所以同日不會出現先平倉再開倉。  
3) 走完所有天數後，答案是 `rest[0..=k]` 的最大值（空手時的收益）。

### 時間與空間

- 時間：`O(n * k)`，`n <= 10^3, k <= 500` 可接受。  
- 空間：`O(k)` 使用三個長度 `k+1` 的陣列。

```rust
impl Solution {
    pub fn maximum_profit(prices: Vec<i32>, k: i32) -> i64 {
        let k = k as usize;
        let neg: i64 = i64::MIN / 4;
        let mut rest = vec![neg; k + 1];
        let mut long = vec![neg; k + 1];
        let mut short = vec![neg; k + 1];
        rest[0] = 0;

        for &p in &prices {
            let price = p as i64;
            let mut next_rest = rest.clone();
            let mut next_long = long.clone();
            let mut next_short = short.clone();

            for t in 0..=k {
                if t < k {
                    if long[t] != neg {
                        next_rest[t + 1] = next_rest[t + 1].max(long[t] + price);
                    }
                    if short[t] != neg {
                        next_rest[t + 1] = next_rest[t + 1].max(short[t] - price);
                    }
                }
                if rest[t] != neg {
                    next_long[t] = next_long[t].max(rest[t] - price);
                    next_short[t] = next_short[t].max(rest[t] + price);
                }
            }

            rest = next_rest;
            long = next_long;
            short = next_short;
        }

        *rest.iter().max().unwrap()
    }
}
```


## 補充筆記：  
當日 `rest[t+1]`（平倉所得）不會在同一迭代被用來更新當日 `long/short`，因為 `long/short` 只讀取前一日的 `rest`。因此平倉後至少隔一日才能再開倉，無需額外標誌。

### 初始化與邊界

- `NEG = i64::MIN / 4` 作為不可能狀態，避免加減價格時溢位。  
- Day 0 之前（基準）：  
  - `rest[0] = 0`；其他 `rest` 為 `NEG`。  
  - `long`、`short` 全為 `NEG`。  
- 若 `k = 0`，直接回傳 0；轉移也不會越界。
- `NEG` 與價格/獲利量級：  
  - 最高價差約 `1e5`，最多 `k=5e2`，累積量級 `5e7`；再乘常數仍遠小於 `|i64::MIN/4|`。  
  - 使用 `i64::MIN/4` 確保 `NEG ± price` 不會溢位。

### 偽碼（單層滾動）

```
NEG = i64::MIN / 4
rest = vec![NEG; k+1]; rest[0] = 0
long = vec![NEG; k+1]
short = vec![NEG; k+1]

for p in prices:
    new_rest = rest.clone()
    new_long = long.clone()
    new_short = short.clone()

    for t in 0..=k:
        // 平倉 -> rest[t+1]
        if t + 1 <= k {
            new_rest[t+1] = max(new_rest[t+1], long[t] + p, short[t] - p)
        }
        // 開倉 -> long[t], short[t]
        new_long[t]  = max(new_long[t],  rest[t] - p)
        new_short[t] = max(new_short[t], rest[t] + p)
    }

    rest = new_rest; long = new_long; short = new_short

answer = max(rest)
```

若要節省常數，可用兩層陣列 `prev`/`curr` 並每日日末 `swap`；邏輯相同。

### 程式碼解析（核心片段）

以下對應 Rust / 類似語言的實作重點：

- 前綴常數：`let neg = i64::MIN / 4;`。  
- 狀態初始化：`rest = vec![neg; k+1]; rest[0] = 0; long = vec![neg; k+1]; short = vec![neg; k+1];`。  
- 每日更新（保持前一日與當日分離）：  
  ```rust
  let mut nr = rest.clone();
  let mut nl = long.clone();
  let mut ns = short.clone();
  for t in 0..=k {
      if t + 1 <= k {
          nr[t + 1] = nr[t + 1].max(long[t] + p).max(short[t] - p); // 平倉
      }
      nl[t] = nl[t].max(rest[t] - p);   // 開多
      ns[t] = ns[t].max(rest[t] + p);   // 開空
  }
  rest = nr; long = nl; short = ns;
  ```
- 最終答案：`rest.iter().copied().max().unwrap()`。  
- 若改用雙層陣列：  
  - `rest_cur.fill(neg); long_cur.fill(neg); ...`  
  - 用 `rest_prev` 讀取、`rest_cur` 寫入，日末 `swap(rest_prev, rest_cur)`，並重置 `*_cur` 為 `neg`。
- 若需優化常數：  
  - 可把 `for t in 0..k`，內部手動展開平倉分支，或用迭代器 `take(k)` 避免邊界判斷。  
  - 但務必確保 `t+1` 不越界，且仍讀取前一日 `rest`。

### 複雜度

- 時間：`O(n * k)`。  
- 空間：`O(k)`（使用滾動即可，若採雙層備份為 `O(k)` 常數倍）。

### 注意實作細節

- 必須使用 `i64`：價格、交易數乘積可達 `1e5 * 1e5 = 1e10`，再累積需要 64 位。  
- 迭代順序不限，但要保證使用「前一日」狀態計算「當日」狀態；用獨立新陣列最安全。  
- 若使用原地更新，需先計算平倉部分寫回 `rest_next`，開倉部分讀取的是舊 `rest`，避免同日連續操作。
- 若允許「同一天先開倉再平倉」會破壞題意；本設計因讀舊狀態而自動避免。
- 回傳時只能取 `rest`，不可取 `long/short`（未平倉不算完成）。

### 範例（prices = [1, 7, 2, 5], k = 2）

Day 0, p=1  
- 開多：`long[0] = -1`；開空：`short[0] = 1`。

Day 1, p=7  
- 平多：`rest[1] = 6`；平空：`rest[1] = max(6, 1-7=-6) = 6`。  
- 仍可從舊 `rest[0]=0` 再開倉：`short[0] = max(1, 0+7=7)`。

Day 2, p=2  
- 從前日的 `short[0]=7` 平倉：`rest[1] = max(6, 7-2=5) = 6`。  
- 從 `rest[1]=6` 開空（不能同日，需用前日值）：`short[1] = 6 + 2 = 8`。

Day 3, p=5  
- 平倉完成第 2 筆：`rest[2] = max(NEG, long[1]+5, short[1]-5) = max(NEG, NEG, 8-5=3) = 3`。  
- 也可以在 Day2 開多 `long[1]=6-2=4`，此處平倉得 `9`；`rest[2]` 取最大為 `9`。  
- 最終答案 `max(rest) = max(rest[0]=0, rest[1]=6, rest[2]=9) = 9`。

該解對應兩筆交易：  
1) Day0 多 -> Day1 平，多賺 `+6`。  
2) Day2 多 -> Day3 平，多賺 `+(5-2)=3`。合計 9。

### 自行檢查要點

- `k=1`、全上漲：應開多一次並平倉。  
- `k=1`、全下跌：可開空一次並平倉。  
- `k` 很大（大於可用交易數）：答案不變，但狀態維度仍為 `k+1`。  
- 價格長度為 1：無法平倉，`max(rest)=0`。  
- 交替價格、限制隔日開倉：確認未誤用「當日 rest」開倉。
