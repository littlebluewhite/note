---
title: q2211. Count Collisions on a Road / 統計道路上的碰撞次數
note_type: knowledge
domain: leetcode
tags: [leetcode, knowledge]
created: 2026-02-03
updated: 2026-02-03
status: active
source: leetcode
complexity_time: O(n)
complexity_space: O(1)
review_interval_days: 14
next_review: 2026-02-17
---
# q2211. Count Collisions on a Road / 統計道路上的碰撞次數
[2211. Count Collisions on a Road](https://leetcode.com/problems/count-collisions-on-a-road/)

Medium

Topics

![premium lock icon](https://leetcode.com/_next/static/images/lock-a6627e2c7fa0ce8bc117c109fb4e567d.svg)Companies

Hint

There are `n` cars on an infinitely long road. The cars are numbered from `0` to `n - 1` from left to right and each car is present at a **unique** point.
給定一條無限長的道路上有 `n` 輛車，從左到右編號 `0` 到 `n - 1`，且每輛車的位置都不重疊。

You are given a **0-indexed** string `directions` of length `n`. `directions[i]` can be either `'L'`, `'R'`, or `'S'` denoting whether the `ith` car is moving towards the **left**, towards the **right**, or **staying** at its current point respectively. Each moving car has the **same speed**.
給定長度為 `n` 的 0-indexed 字串 `directions`，`directions[i]` 可能是 `'L'`、`'R'` 或 `'S'`，代表第 `i` 輛車往左、往右或保持靜止；所有移動的車速相同。

The number of collisions can be calculated as follows:
碰撞次數的計算方式如下：

- When two cars moving in **opposite** directions collide with each other, the number of collisions increases by `2`.
- 兩輛車若對向相撞，碰撞次數增加 `2`。
- When a moving car collides with a stationary car, the number of collisions increases by `1`.
- 一輛移動的車撞上靜止的車，碰撞次數增加 `1`。

After a collision, the cars involved can no longer move and will stay at the point where they collided. Other than that, cars cannot change their state or direction of motion.
發生碰撞後，相關的車輛都會停在碰撞點；除此之外，車輛不會改變狀態或方向。

Return the **total number of collisions** that will happen on the road.
請回傳道路上會發生的**碰撞總次數**。

**Example 1:**

**Input:** directions = "RLRSLL"
**Output:** 5
**Explanation:**
The collisions that will happen on the road are:
- Cars 0 and 1 will collide with each other. Since they are moving in opposite directions, the number of collisions becomes 0 + 2 = 2.
- Cars 2 and 3 will collide with each other. Since car 3 is stationary, the number of collisions becomes 2 + 1 = 3.
- Cars 3 and 4 will collide with each other. Since car 3 is stationary, the number of collisions becomes 3 + 1 = 4.
- Cars 4 and 5 will collide with each other. After car 4 collides with car 3, it will stay at the point of collision and get hit by car 5. The number of collisions becomes 4 + 1 = 5.
Thus, the total number of collisions that will happen on the road is 5. 
發生的碰撞依序如上，總次數為 5。

**Example 2:**

**Input:** directions = "LLRR"
**Output:** 0
**Explanation:**
No cars will collide with each other. Thus, the total number of collisions that will happen on the road is 0.
沒有任何碰撞發生，因此答案為 0。

**Constraints:**

- `1 <= directions.length <= 105`
- `directions[i]` is either `'L'`, `'R'`, or `'S'`.
- `1 <= directions.length <= 105`。
- `directions[i]` 只能是 `'L'`、`'R'` 或 `'S'`。

## 解題筆記與程式碼

通用演算法筆記：[two_pointers](../algorithm/two_pointers.md)

### 核心觀察

- 最左側連續的 `'L'` 只會往更左邊移動，不會遇到任何車；最右側連續的 `'R'` 只會往更右邊移動，同樣不會碰撞，兩者都可忽略。
- 剩下的區間內，所有車最終都會停住；每一輛移動中的車（`'L'` 或 `'R'`）一定至少產生一次碰撞，而 `'S'` 不增加碰撞。
- 因此，答案等於「去掉前後安全區」後，區間內非 `'S'` 的車輛數量。

### 演算法

1. 以雙指標移除開頭連續的 `'L'`，再移除結尾連續的 `'R'`，得到中間可能發生碰撞的區間 `[l, r)`。
2. 在該區間統計不是 `'S'` 的字元數量，即為總碰撞次數。

### 時間與空間

- 時間：O(n)。
- 空間：O(1)。

```rust
impl Solution {
    pub fn count_collisions(directions: String) -> i32 {
        let bytes = directions.as_bytes();
        let n = bytes.len();
        let mut l = 0usize;
        let mut r = n;

        while l < r && bytes[l] == b'L' {
            l += 1;
        }
        while r > l && bytes[r - 1] == b'R' {
            r -= 1;
        }

        let mut collisions = 0;
        for &ch in &bytes[l..r] {
            if ch != b'S' {
                collisions += 1;
            }
        }

        collisions
    }
}
```


## 補充筆記：[#2211 Count Collisions on a Road](q2211.md)
