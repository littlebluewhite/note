---
title: q696. Count Binary Substrings / 計算二進位子字串數量
note_type: knowledge
domain: leetcode
tags: [leetcode, knowledge]
created: 2026-02-19
updated: 2026-02-19
status: active
source: leetcode
difficulty: Easy
complexity_time: O(n)
complexity_space: O(1)
review_interval_days: 14
next_review: 2026-03-05
---
# q696. Count Binary Substrings / 計算二進位子字串數量
[696. Count Binary Substrings](https://leetcode.com/problems/count-binary-substrings/)

Easy

Topics

Companies

Given a binary string `s`, return the number of non-empty substrings that have the same number of `0`'s and `1`'s, and all the `0`'s and all the `1`'s in these substrings are grouped consecutively.
給定一個二進位字串 `s`，請回傳其中非空子字串的數量，且每個被計數的子字串都必須同時滿足：`0` 與 `1` 的數量相同，而且所有 `0` 與所有 `1` 都各自連續成一段。

Substrings that occur multiple times are counted the number of times they occur.
若同一內容的子字串出現在不同位置，需依出現次數重複計算。

**Example 1:**

**Input:** s = "00110011"
**Output:** 6
**Explanation:** There are 6 substrings that have equal number of consecutive 1's and 0's: "0011", "01", "1100", "10", "0011", and "01". Notice that some of these substrings repeat and are counted the number of times they occur. Also, "00110011" is not a valid substring because all the 0's (and 1's) are not grouped together.
**說明：** 符合條件的子字串共有 6 個：`"0011"`、`"01"`、`"1100"`、`"10"`、`"0011"`、`"01"`。其中有重複內容要照次數計算；另外 `"00110011"` 不合法，因為它的 `0` 與 `1` 並非各自只形成單一連續段。

**Example 2:**

**Input:** s = "10101"
**Output:** 4
**Explanation:** There are 4 substrings: "10", "01", "10", "01" that have equal number of consecutive 1's and 0's.
**說明：** 符合條件的子字串為 `"10"`、`"01"`、`"10"`、`"01"`，共 4 個。

**Constraints:**

- `1 <= s.length <= 10^5`
- `s[i]` is either `'0'` or `'1'`.
- `1 <= s.length <= 10^5`。
- `s[i]` 只能是 `'0'` 或 `'1'`。

## 解題筆記與程式碼

通用演算法筆記：[binary_run_boundary_count](../algorithm/binary_run_boundary_count.md)
通用演算法筆記：[grouped_loop_scan](../algorithm/grouped_loop_scan.md)
資料結構筆記：[dual_run_length_state](../data_structure/dual_run_length_state.md)

### 思路拆解

- 合法子字串一定長得像 `000...111...` 或 `111...000...`，也就是只跨越「相鄰兩個連續段」。
- 把字串切成連續段長度後，假設相鄰兩段長度為 `a` 與 `b`，它們能形成的合法子字串數量就是 `min(a, b)`。
- 全部答案就是對每一組相鄰段做 `min(前一段, 目前段)` 的加總。

### 為什麼 `min(前一段, 目前段)` 正確

- 在邊界兩側，若左段長度為 `a`、右段長度為 `b`，可取長度 `1..min(a,b)` 的對稱前後綴來配對。
- 每個可取長度 `k` 對應一個合法子字串（左邊取 `k` 個、右邊取 `k` 個），總共有 `min(a,b)` 個。
- 超過較短段長度就無法保持 `0`/`1` 數量相同，因此不合法。

### 演算法

1. 線性掃描字串，維護兩個段長：`prev_run`（前一段）與 `curr_run`（目前段）。
2. 若當前字元與前一字元相同，`curr_run += 1`；否則遇到新段邊界：
   - 先把 `min(prev_run, curr_run)` 加到答案。
   - 再做狀態轉移：`prev_run = curr_run`，`curr_run = 1`。
3. 掃描結束後，再把最後一組 `min(prev_run, curr_run)` 補進答案。

### 時間與空間

- 時間：`O(n)`
- 空間：`O(1)`

Where:
`n`: `s` 的長度。

```rust
impl Solution {
    pub fn count_binary_substrings(s: String) -> i32 {
        let bytes = s.as_bytes();
        let mut prev_run = 0i32;
        let mut curr_run = 1i32;
        let mut ans = 0i32;

        for i in 1..bytes.len() {
            if bytes[i] == bytes[i - 1] {
                curr_run += 1;
            } else {
                ans += prev_run.min(curr_run);
                prev_run = curr_run;
                curr_run = 1;
            }
        }

        ans + prev_run.min(curr_run)
    }
}
```

## 補充筆記

- 此題不需要真的切出所有子字串，只需計算段長與邊界貢獻。
- 若先做完整 run-length array 也可解，但空間會從 `O(1)` 變成 `O(g)`（`g` 為段數）。
