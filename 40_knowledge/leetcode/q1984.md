---
title: q1984. Minimum Difference Between Highest and Lowest of K Scores / 學生分數的最小差值
note_type: knowledge
domain: leetcode
tags: [leetcode, knowledge]
created: 2026-02-03
updated: 2026-02-03
status: active
source: leetcode
difficulty: Easy
complexity_time: O(n log n)
complexity_space: O(1)
review_interval_days: 14
next_review: 2026-02-17
---
# q1984. Minimum Difference Between Highest and Lowest of K Scores / 學生分數的最小差值
[1984. Minimum Difference Between Highest and Lowest of K Scores](https://leetcode.com/problems/minimum-difference-between-highest-and-lowest-of-k-scores/)

Easy

Topics

![premium lock icon](https://leetcode.com/_next/static/images/lock-a6627e2c7fa0ce8bc117c109fb4e567d.svg)Companies

Hint

You are given a **0-indexed** integer array `nums`, where `nums[i]` represents the score of the `ith` student. You are also given an integer `k`.
給定一個 **0-indexed** 整數陣列 `nums`，其中 `nums[i]` 代表第 `i` 位學生的分數，另給一個整數 `k`。

Pick the scores of any `k` students from the array so that the **difference** between the **highest** and the **lowest** of the `k` scores is **minimized**.
從陣列中挑選任意 `k` 位學生，使這 `k` 個分數的 **最高值** 與 **最低值** 的 **差** 最小。

Return the **minimum** possible difference.
請回傳 **最小可能差值**。

**Example 1:**

**Input:** nums = [90], k = 1
**Output:** 0
**Explanation:** There is one way to pick score(s) of one student:
**說明：** 只有一種選法：
- [**90**]. The difference between the highest and lowest score is 90 - 90 = 0.
- [**90**]。最高分與最低分的差為 90 - 90 = 0。
The minimum possible difference is 0.
最小可能差值為 0。

**Example 2:**

**Input:** nums = [9,4,1,7], k = 2
**Output:** 2
**Explanation:** There are six ways to pick score(s) of two students:
**說明：** 共有六種選法：
- [**9**,**4**,1,7]. The difference between the highest and lowest score is 9 - 4 = 5.
- [**9**,**4**,1,7]。最高分與最低分的差為 9 - 4 = 5。
- [**9**,4,**1**,7]. The difference between the highest and lowest score is 9 - 1 = 8.
- [**9**,4,**1**,7]。最高分與最低分的差為 9 - 1 = 8。
- [**9**,4,1,**7**]. The difference between the highest and lowest score is 9 - 7 = 2.
- [**9**,4,1,**7**]。最高分與最低分的差為 9 - 7 = 2。
- [9,**4**,**1**,7]. The difference between the highest and lowest score is 4 - 1 = 3.
- [9,**4**,**1**,7]。最高分與最低分的差為 4 - 1 = 3。
- [9,**4**,1,**7**]. The difference between the highest and lowest score is 7 - 4 = 3.
- [9,**4**,1,**7**]。最高分與最低分的差為 7 - 4 = 3。
- [9,4,**1**,**7**]. The difference between the highest and lowest score is 7 - 1 = 6.
- [9,4,**1**,**7**]。最高分與最低分的差為 7 - 1 = 6。
The minimum possible difference is 2.
最小可能差值為 2。

**Constraints:**

- `1 <= k <= nums.length <= 1000`
- `1 <= k <= nums.length <= 1000`。
- `0 <= nums[i] <= 105`
- `0 <= nums[i] <= 10^5`。

## 解題筆記與程式碼

通用演算法筆記：[sliding_window](../algorithm/sliding_window.md)
資料結構筆記：[sorted_array](../data_structure/sorted_array.md)

### 思路拆解

- 先排序，任何選到的 `k` 個分數，最高與最低就會落在某個排序後區間的兩端。
- 最小差值一定來自「排序後的連續 `k` 個元素」：只需掃描每個固定長度視窗的端點差。
- 因此問題變成：在排序後的陣列中，找最小的 `nums[i+k-1] - nums[i]`。

### 為什麼只要看連續 `k` 個

- 排序後設 `a[0] <= ... <= a[n-1]`。任意選出 `k` 個元素，其最小值為 `a[i]`，最大值為 `a[j]`。
- 區間 `[i, j]` 中至少有 `k` 個元素。選擇這個區間內的任意 `k` 個元素，其差值都不會小於 `a[j] - a[i]`。
- 因此最小差值一定來自某個連續的長度 `k` 視窗。

### 演算法

1. 將 `nums` 升冪排序。
2. 以固定長度視窗掃描 `i = 0..n-k`：
   - 更新 `ans = min(ans, nums[i+k-1] - nums[i])`。
3. 回傳 `ans`。

### 時間與空間

- 時間：`O(n log n)`（排序）。
- 空間：`O(1)` 額外空間（就地排序），不含輸入。

```rust
impl Solution {
    pub fn minimum_difference(mut nums: Vec<i32>, k: i32) -> i32 {
        let k = k as usize;
        nums.sort_unstable();
        let mut ans = i32::MAX;
        for i in 0..=nums.len() - k {
            let diff = nums[i + k - 1] - nums[i];
            if diff < ans {
                ans = diff;
            }
        }
        ans
    }
}
```

## 補充筆記：固定長度視窗只需看左右端點，因為排序後中間值不會改變差值。
