---
title: q3719. Longest Balanced Subarray I / 最長平衡子陣列 I
note_type: knowledge
domain: leetcode
tags: [leetcode, knowledge]
created: 2026-02-10
updated: 2026-02-10
status: active
source: leetcode
difficulty: Medium
complexity_time: O(n^2)
complexity_space: O(U)
review_interval_days: 14
next_review: 2026-02-24
---
# q3719. Longest Balanced Subarray I / 最長平衡子陣列 I
[3719. Longest Balanced Subarray I](https://leetcode.com/problems/longest-balanced-subarray-i/)

Medium

Topics

Companies

Hint

You are given an integer array `nums`.
給定一個整數陣列 `nums`。

A **subarray** is called **balanced** if the number of **distinct even** numbers in the subarray is equal to the number of **distinct odd** numbers.
若某個**子陣列**中，**不同偶數**的個數等於**不同奇數**的個數，則稱其為 **balanced**（平衡）。

Return the length of the **longest** balanced subarray.
回傳最長平衡子陣列的長度。

**Example 1:**

**Input:** `nums = [2,5,4,3]`
**Output:** `4`
**Explanation:**
The longest balanced subarray is `[2,5,4,3]`.
最長平衡子陣列是 `[2,5,4,3]`。
It has 2 distinct even numbers `[2,4]` and 2 distinct odd numbers `[5,3]`.
其中不同偶數有 2 個（`[2,4]`），不同奇數有 2 個（`[5,3]`）。

**Example 2:**

**Input:** `nums = [3,2,2,5,4]`
**Output:** `5`
**Explanation:**
The longest balanced subarray is `[3,2,2,5,4]`.
最長平衡子陣列是 `[3,2,2,5,4]`。
It has 2 distinct even numbers `[2,4]` and 2 distinct odd numbers `[3,5]`.
其中不同偶數有 2 個（`[2,4]`），不同奇數有 2 個（`[3,5]`）。

**Example 3:**

**Input:** `nums = [1,2,3,2]`
**Output:** `3`
**Explanation:**
The longest balanced subarray is `[2,3,2]`.
最長平衡子陣列是 `[2,3,2]`。
It has 1 distinct even number `[2]` and 1 distinct odd number `[3]`.
其中不同偶數有 1 個（`[2]`），不同奇數有 1 個（`[3]`）。

**Constraints:**

- `1 <= nums.length <= 1500`
- `nums.length` 範圍為 `1..=1500`。
- `1 <= nums[i] <= 10^5`
- `nums[i]` 範圍為 `1..=10^5`。

## 解題筆記與程式碼

通用演算法筆記：[subarray_enumeration_incremental_distinct_count](../algorithm/subarray_enumeration_incremental_distinct_count.md)
資料結構筆記：[timestamped_presence_array](../data_structure/timestamped_presence_array.md)
資料結構筆記：[array](../data_structure/array.md)

### 思路拆解

- `n <= 1500`，可以接受 `O(n^2)`：固定左端點 `l`，向右擴展 `r`，枚舉所有子陣列。
- 關鍵是要維護「目前子陣列內，不同奇數數量、不同偶數數量」。
- 為了避免每次換 `l` 都把 `seen` 清空，使用「版本標記陣列」：
  - `seen_ver[x] = version` 代表值 `x` 在本輪左端點已經出現過。
  - 每次進入新左端點時 `version += 1`，等同邏輯清空，省去 `O(U)` 重設成本。
- 每次擴展 `r`：
  - 若 `nums[r]` 在本版本第一次出現，依奇偶更新 `distinct_even` 或 `distinct_odd`。
  - 若 `distinct_even == distinct_odd`，更新答案長度。

### 演算法

1. 初始化答案 `ans = 0`，建立 `seen_ver`（長度 `U + 1`，`U = 10^5`）。
2. 對每個左端點 `l`：
   - `version += 1`。
   - `distinct_even = 0`、`distinct_odd = 0`。
   - 右端點 `r` 由 `l` 掃到 `n - 1`。
3. 若 `nums[r]` 在當前版本首次出現：
   - 偶數就 `distinct_even += 1`；奇數就 `distinct_odd += 1`。
4. 若兩者相等，嘗試更新 `ans = max(ans, r - l + 1)`。
5. 回傳 `ans`。

### 時間與空間

- 時間：`O(n^2)`（雙層枚舉子陣列）。
- 空間：`O(U)`（`U = 10^5`，值域上界的版本陣列）。

```rust
impl Solution {
    pub fn longest_balanced_subarray(nums: Vec<i32>) -> i32 {
        const MAX_V: usize = 100_000;

        let n = nums.len();
        let mut seen_ver = vec![0i32; MAX_V + 1];
        let mut version = 0i32;
        let mut ans = 0usize;

        for l in 0..n {
            version += 1;
            let mut distinct_even = 0i32;
            let mut distinct_odd = 0i32;

            for r in l..n {
                let x = nums[r] as usize;
                if seen_ver[x] != version {
                    seen_ver[x] = version;
                    if x % 2 == 0 {
                        distinct_even += 1;
                    } else {
                        distinct_odd += 1;
                    }
                }

                if distinct_even == distinct_odd {
                    let len = r - l + 1;
                    if len > ans {
                        ans = len;
                    }
                }
            }
        }

        ans as i32
    }
}
```

## 補充筆記：`O(U)` 版本標記陣列。

## 實作細節

- 由於 `nums[i] <= 10^5`，可直接用陣列索引值，不必雜湊。
- `version` 每次外層迴圈遞增即可，避免反覆清空 `seen`。
- 當 `n <= 1500` 時，`O(n^2)` 是合理且容易維護的作法。
