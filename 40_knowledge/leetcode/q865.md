---
title: q865. Smallest Subtree with all the Deepest Nodes / 具有所有最深節點的最小子樹
note_type: knowledge
domain: leetcode
tags: [leetcode, knowledge]
created: 2026-02-03
updated: 2026-02-03
status: active
source: leetcode
complexity_time: O(n)
complexity_space: O(h)
review_interval_days: 14
next_review: 2026-02-17
---
# q865. Smallest Subtree with all the Deepest Nodes / 具有所有最深節點的最小子樹
[865. Smallest Subtree with all the Deepest Nodes](https://leetcode.com/problems/smallest-subtree-with-all-the-deepest-nodes/)

Medium

Topics

![premium lock icon](https://leetcode.com/_next/static/images/lock-a6627e2c7fa0ce8bc117c109fb4e567d.svg)Companies

Given the `root` of a binary tree, the depth of each node is **the shortest distance to the root**.
給定二元樹的 `root`，每個節點的深度為到根節點的**最短距離**。

Return _the smallest subtree_ such that it contains **all the deepest nodes** in the original tree.
回傳包含原樹所有**最深節點**的**最小子樹**。

A node is called **the deepest** if it has the largest depth possible among any node in the entire tree.
若節點深度為整棵樹中最大值，則稱為**最深節點**。

The **subtree** of a node is a tree consisting of that node, plus the set of all descendants of that node.
節點的**子樹**由該節點本身與其所有後代節點所構成。

**Example 1:**

![](https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/01/sketch1.png)

**Input:** root = [3,5,1,6,2,0,8,null,null,7,4]
**Output:** [2,7,4]
**Explanation:** We return the node with value 2, colored in yellow in the diagram.
The nodes coloured in blue are the deepest nodes of the tree.
Notice that nodes 5, 3 and 2 contain the deepest nodes in the tree but node 2 is the smallest subtree among them, so we return it.
值為 2 的節點（圖中黃色）為答案。
藍色節點是最深節點。
節點 5、3、2 的子樹都包含所有最深節點，但節點 2 的子樹最小，因此回傳節點 2。

**Example 2:**

**Input:** root = [1]
**Output:** [1]
**Explanation:** The root is the deepest node in the tree.
根節點即為最深節點。

**Example 3:**

**Input:** root = [0,1,3,null,2]
**Output:** [2]
**Explanation:** The deepest node in the tree is 2, the valid subtrees are the subtrees of nodes 2, 1 and 0 but the subtree of node 2 is the smallest.
最深節點為 2，可行子樹為節點 2、1、0 的子樹，其中節點 2 的子樹最小。

**Constraints:**

- The number of nodes in the tree will be in the range `[1, 500]`.
- `0 <= Node.val <= 500`
- The values of the nodes in the tree are **unique**.
- 樹的節點數量介於 `[1, 500]`。
- `0 <= Node.val <= 500`
- 樹上節點值 **不重複**。

## 解題筆記與程式碼

通用演算法筆記：[tree_postorder_depth_lca](../algorithm/tree_postorder_depth_lca.md)
資料結構筆記：[binary_tree](../data_structure/binary_tree.md)

### 思路拆解

- 目標是找到「包含所有最深節點的最小子樹」，等價於「所有最深節點的 LCA」。
- 用後序 DFS 回傳 `(最深深度, 對應子樹答案節點)`。
- 左右子樹最深深度相同時，當前節點就是最小子樹根；否則答案在較深的一側。

### 演算法

1. 定義 `dfs(node)`：回傳 `(depth, ans_node)`。
2. 若 `node` 為空，回傳 `(0, None)`。
3. 遞迴取得左、右子樹的 `(ld, lnode)` 與 `(rd, rnode)`。
4. 若 `ld == rd`，回傳 `(ld + 1, node)`；否則回傳較深側的 `(depth + 1, ans_node)`。
5. 最終答案為 `dfs(root).1`。

### 時間與空間

- 時間：`O(n)`，每個節點只訪問一次。
- 空間：`O(h)`，遞迴堆疊深度，`h` 為樹高。

```rust
// Definition for a binary tree node.
// #[derive(Debug, PartialEq, Eq)]
// pub struct TreeNode {
//   pub val: i32,
//   pub left: Option<Rc<RefCell<TreeNode>>>,
//   pub right: Option<Rc<RefCell<TreeNode>>>,
// }
//
// impl TreeNode {
//   #[inline]
//   pub fn new(val: i32) -> Self {
//     TreeNode {
//       val,
//       left: None,
//       right: None
//     }
//   }
// }

use std::rc::Rc;
use std::cell::RefCell;

impl Solution {
    pub fn subtree_with_all_deepest(root: Option<Rc<RefCell<TreeNode>>>) -> Option<Rc<RefCell<TreeNode>>> {
        fn dfs(node: Option<Rc<RefCell<TreeNode>>>) -> (i32, Option<Rc<RefCell<TreeNode>>>) {
            if node.is_none() {
                return (0, None);
            }

            let rc = node.unwrap();
            let (left, right) = {
                let n = rc.borrow();
                (n.left.clone(), n.right.clone())
            };
            let (ld, lnode) = dfs(left);
            let (rd, rnode) = dfs(right);

            if ld == rd {
                (ld + 1, Some(rc))
            } else if ld > rd {
                (ld + 1, lnode)
            } else {
                (rd + 1, rnode)
            }
        }

        dfs(root).1
    }
}
```
