---
title: q108. Convert Sorted Array to Binary Search Tree / 將有序陣列轉為二元搜尋樹
note_type: knowledge
domain: leetcode
tags: [leetcode, knowledge]
created: 2026-02-14
updated: 2026-02-14
status: active
source: leetcode
difficulty: Easy
complexity_time: O(n)
complexity_space: O(log n)
review_interval_days: 14
next_review: 2026-02-28
---

# q108. Convert Sorted Array to Binary Search Tree / 將有序陣列轉為二元搜尋樹
[108. Convert Sorted Array to Binary Search Tree](https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/)

Easy

## 解題筆記與程式碼

通用演算法筆記：[divide_conquer_build_balanced_bst](../algorithm/divide_conquer_build_balanced_bst.md)
資料結構筆記：[binary_search_tree](../data_structure/binary_search_tree.md)
資料結構筆記：[array](../data_structure/array.md)

### 思路拆解

- 每次取中點作為根節點，左右半段遞迴建樹。
- 由於輸入有序，這能保證 BST 性質且高度近似平衡。

### Rust 參考

```rust
impl Solution {
    pub fn sorted_array_to_bst(nums: Vec<i32>) -> Option<Rc<RefCell<TreeNode>>> {
        fn build(nums: &[i32]) -> Option<Rc<RefCell<TreeNode>>> {
            if nums.is_empty() { return None; }
            let mid = nums.len() / 2;
            let root = Rc::new(RefCell::new(TreeNode::new(nums[mid])));
            root.borrow_mut().left = build(&nums[..mid]);
            root.borrow_mut().right = build(&nums[mid + 1..]);
            Some(root)
        }
        build(&nums)
    }
}
```

## Related problems

- [q109](../leetcode/q109.md)
- [q1382](../leetcode/q1382.md)
- [q98](../leetcode/q98.md)
