---
title: q94. Binary Tree Inorder Traversal / 二元樹中序遍歷
note_type: knowledge
domain: leetcode
tags: [leetcode, knowledge]
created: 2026-02-14
updated: 2026-02-14
status: active
source: leetcode
difficulty: Easy
complexity_time: O(n)
complexity_space: O(h)
review_interval_days: 14
next_review: 2026-02-28
---

# q94. Binary Tree Inorder Traversal / 二元樹中序遍歷
[94. Binary Tree Inorder Traversal](https://leetcode.com/problems/binary-tree-inorder-traversal/)

Easy

## 解題筆記與程式碼

通用演算法筆記：[tree_level_order_traversal](../algorithm/tree_level_order_traversal.md)
通用演算法筆記：[bst_inorder_sorted_sequence](../algorithm/bst_inorder_sorted_sequence.md)
資料結構筆記：[binary_tree](../data_structure/binary_tree.md)

### 思路拆解

- 中序順序固定為 `left -> root -> right`。
- 可用遞迴或顯式 stack 迭代完成。

### Rust 參考

```rust
impl Solution {
    pub fn inorder_traversal(root: Option<Rc<RefCell<TreeNode>>>) -> Vec<i32> {
        fn dfs(node: &Option<Rc<RefCell<TreeNode>>>, out: &mut Vec<i32>) {
            if let Some(rc) = node {
                let (left, val, right) = {
                    let n = rc.borrow();
                    (n.left.clone(), n.val, n.right.clone())
                };
                dfs(&left, out);
                out.push(val);
                dfs(&right, out);
            }
        }
        let mut ans = Vec::new();
        dfs(&root, &mut ans);
        ans
    }
}
```

## Related problems

- [q98](../leetcode/q98.md)
- [q230](../leetcode/q230.md)
- [q1382](../leetcode/q1382.md)
