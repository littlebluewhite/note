---
title: q3625. Count Number of Trapezoids II / 統計梯形數量 II
note_type: knowledge
domain: leetcode
tags: [leetcode, knowledge]
created: 2026-02-03
updated: 2026-02-03
status: active
source: leetcode
difficulty: Hard
complexity_time: O(n^2)
complexity_space: O(n^2)
review_interval_days: 14
next_review: 2026-02-17
---
# q3625. Count Number of Trapezoids II / 統計梯形數量 II
[3625. Count Number of Trapezoids II](https://leetcode.com/problems/count-number-of-trapezoids-ii/)

Hard

Topics

![premium lock icon](https://leetcode.com/_next/static/images/lock-a6627e2c7fa0ce8bc117c109fb4e567d.svg)Companies

Hint

You are given a 2D integer array `points` where `points[i] = [xi, yi]` represents the coordinates of the `ith` point on the Cartesian plane.
給定二維整數陣列 `points`，其中 `points[i] = [xi, yi]` 表示平面上第 i 個點的座標。

Return _the number of unique_ _trapezoids_ that can be formed by choosing any four distinct points from `points`.
請回傳從 `points` 中任取四個不同點所能形成的不同梯形數量。

A **trapezoid** is a convex quadrilateral with **at least one pair** of parallel sides. Two lines are parallel if and only if they have the same slope.
**梯形** 是一個凸四邊形，至少有一對邊互相平行；兩條直線斜率相同視為平行。

**Example 1:**

**Input:** points = [ [-3,2],[3,0],[2,3],[3,2],[2,-3] ]

**Output:** 2

**Explanation:**

![](https://assets.leetcode.com/uploads/2025/04/29/desmos-graph-4.png)![](https://assets.leetcode.com/uploads/2025/04/29/desmos-graph-3.png)

There are two distinct ways to pick four points that form a trapezoid:

- The points `[-3,2], [2,3], [3,2], [2,-3]` form one trapezoid.
- The points `[2,3], [3,2], [3,0], [2,-3]` form another trapezoid.

**Example 2:**

**Input:** points = [ [0,0],[1,0],[0,1],[2,1] ]

**Output:** 1

**Explanation:**

![](https://assets.leetcode.com/uploads/2025/04/29/desmos-graph-5.png)

There is only one trapezoid which can be formed.
只有一種四點選法能形成梯形。

**Constraints:**

- `4 <= points.length <= 500`
- `–1000 <= xi, yi <= 1000`
- All points are pairwise distinct.
- `4 <= points.length <= 500`。
- `–1000 <= xi, yi <= 1000`。
- 所有點兩兩不同。

## 解題筆記與程式碼

通用演算法筆記：[combinatorics_counting](../algorithm/combinatorics_counting.md)
通用演算法筆記：[geometry_line_grouping](../algorithm/geometry_line_grouping.md)
資料結構筆記：[hash_map_set](../data_structure/hash_map_set.md)

### 核心觀察

- 若梯形有平行邊，這兩條邊必落在「兩條平行但不重合的直線」上；對同一個斜率，從不同直線各挑兩點即可形成梯形。
- 對固定斜率，設第 i 條線上點數為 `cnt_i`，可形成邊的方式 `b_i = C(cnt_i, 2)`，同斜率下的梯形數為 `sum_{i<j} b_i * b_j = ((Σ b_i)^2 - Σ b_i^2)/2`。
- 具有兩組平行邊的四邊形（平行四邊形）會被上述計數在兩個斜率各算一次，因此需額外統計平行四邊形數量並減去一次，才能得到「至少一組平行邊」的唯一計數。

### 演算法

1. 以「斜率 + 截距 (dy*x - dx*y)」為鍵，把所有點分組到對應的直線；每條線的點數 `cnt` 推得 `b = C(cnt, 2)`，對同斜率套用公式累加形成平行邊的總數 `total_parallel`。
2. 用「對角線中點」計數平行四邊形：任意兩點形成一條對角線，若兩條對角線中點相同且方向不平行，就能構成一個平行四邊形。對每個中點，總對角線對數為 `C(k, 2)`，減去同斜率（平行）對數即為有效平行四邊形數，累加得 `parallelograms`。
3. 答案為 `total_parallel - parallelograms`，僅計一次含平行邊的凸四邊形。

### 時間與空間

- 時間：O(n^2) 生成線與中點分組，額外去重與統計為線性。
- 空間：O(n^2) 儲存線上點索引與中點分組。

```rust
use std::collections::HashMap;

impl Solution {
    pub fn count_trapezoids(points: Vec<Vec<i32>>) -> i32 {
        fn gcd(mut a: i64, mut b: i64) -> i64 {
            while b != 0 {
                let r = a % b;
                a = b;
                b = r;
            }
            a.abs()
        }

        fn normalize(dx: i64, dy: i64) -> (i32, i32) {
            let mut dx = dx;
            let mut dy = dy;
            let g = gcd(dx.abs(), dy.abs());
            dx /= g;
            dy /= g;
            if dx < 0 || (dx == 0 && dy < 0) {
                dx = -dx;
                dy = -dy;
            }
            (dx as i32, dy as i32)
        }

        let n = points.len();
        let pts: Vec<(i64, i64)> = points
            .iter()
            .map(|p| (p[0] as i64, p[1] as i64))
            .collect();

        // 斜率 -> 截距 -> 該直線上的點索引列表
        let mut lines: HashMap<(i32, i32), HashMap<i64, Vec<usize>>> = HashMap::new();
        for i in 0..n {
            for j in (i + 1)..n {
                let dx = pts[j].0 - pts[i].0;
                let dy = pts[j].1 - pts[i].1;
                let (sx, sy) = normalize(dx, dy);
                let c = sy as i64 * pts[i].0 - sx as i64 * pts[i].1;
                let entry = lines.entry((sx, sy)).or_default();
                let vec = entry.entry(c).or_default();
                vec.push(i);
                vec.push(j);
            }
        }

        // 去重後計算同斜率、不同直線的邊選法
        for slope_map in lines.values_mut() {
            for pts_on_line in slope_map.values_mut() {
                pts_on_line.sort_unstable();
                pts_on_line.dedup();
            }
        }

        let mut total_parallel: i64 = 0;
        for slope_map in lines.values() {
            let mut sum_b: i64 = 0;
            let mut sum_b2: i64 = 0;
            for pts_on_line in slope_map.values() {
                let cnt = pts_on_line.len() as i64;
                if cnt >= 2 {
                    let b = cnt * (cnt - 1) / 2;
                    sum_b += b;
                    sum_b2 += b * b;
                }
            }
            total_parallel += (sum_b * sum_b - sum_b2) / 2;
        }

        // 以中點分組計算平行四邊形（需扣掉重複計數）
        let mut midpoint_map: HashMap<(i64, i64), Vec<(i32, i32)>> = HashMap::new();
        for i in 0..n {
            for j in (i + 1)..n {
                let dx = pts[j].0 - pts[i].0;
                let dy = pts[j].1 - pts[i].1;
                let dir = normalize(dx, dy);
                let mid = (pts[i].0 + pts[j].0, pts[i].1 + pts[j].1);
                midpoint_map.entry(mid).or_default().push(dir);
            }
        }

        let mut parallelograms: i64 = 0;
        for dirs in midpoint_map.values() {
            let k = dirs.len() as i64;
            if k < 2 {
                continue;
            }
            let total_pairs = k * (k - 1) / 2;
            let mut dir_count: HashMap<(i32, i32), i64> = HashMap::new();
            for &d in dirs {
                *dir_count.entry(d).or_insert(0) += 1;
            }
            let mut parallel_pairs: i64 = 0;
            for &c in dir_count.values() {
                if c >= 2 {
                    parallel_pairs += c * (c - 1) / 2;
                }
            }
            parallelograms += total_pairs - parallel_pairs;
        }

        let ans = total_parallel - parallelograms;
        ans as i32
    }
}
```


## 補充筆記：兩條平行且不重合的直線，各取兩點天然形成凸四邊形；平行四邊形重複計數則用中點法修正。
