---
title: q712. Minimum ASCII Delete Sum for Two Strings / 兩字串的最小 ASCII 刪除總和
note_type: knowledge
domain: leetcode
tags: [leetcode, knowledge]
created: 2026-02-03
updated: 2026-02-03
status: active
source: leetcode
complexity_time: O(mn)
complexity_space: O(mn)
review_interval_days: 14
next_review: 2026-02-17
canonical: leetcode/q712.md
---
# q712. Minimum ASCII Delete Sum for Two Strings / 兩字串的最小 ASCII 刪除總和
[712. Minimum ASCII Delete Sum for Two Strings](https://leetcode.com/problems/minimum-ascii-delete-sum-for-two-strings/)

Medium

Topics

![premium lock icon](https://leetcode.com/_next/static/images/lock-a6627e2c7fa0ce8bc117c109fb4e567d.svg)Companies

Hint

Given two strings `s1` and `s2`, return _the lowest **ASCII** sum of deleted characters to make two strings equal_.
給定兩個字串 `s1` 與 `s2`，請回傳讓兩字串相等時「被刪除字元的 **ASCII** 總和」最小值。

**Example 1:**

**Input:** s1 = "sea", s2 = "eat"
**Output:** 231
**Explanation:** Deleting "s" from "sea" adds the ASCII value of "s" (115) to the sum.
Deleting "t" from "eat" adds 116 to the sum.
At the end, both strings are equal, and 115 + 116 = 231 is the minimum sum possible to achieve this.
**解釋：** 從 "sea" 刪掉 "s" 會加上 ASCII 115。
從 "eat" 刪掉 "t" 會加上 ASCII 116。
最後兩字串相等，115 + 116 = 231 為最小可能總和。

**Example 2:**

**Input:** s1 = "delete", s2 = "leet"
**Output:** 403
**Explanation:** Deleting "dee" from "delete" to turn the string into "let",
adds 100[d] + 101[e] + 101[e] to the sum.
Deleting "e" from "leet" adds 101[e] to the sum.
At the end, both strings are equal to "let", and the answer is 100+101+101+101 = 403.
If instead we turned both strings into "lee" or "eet", we would get answers of 433 or 417, which are higher.
**解釋：** 從 "delete" 刪掉 "dee" 變成 "let"，
會加上 100[d] + 101[e] + 101[e]。
從 "leet" 刪掉 "e" 會加上 101[e]。
最後兩字串相等為 "let"，答案是 100+101+101+101 = 403。
若改成 "lee" 或 "eet"，總和會是 433 或 417，較大。

**Constraints:**

- `1 <= s1.length, s2.length <= 1000`
- `s1` and `s2` consist of lowercase English letters.
- `1 <= s1.length, s2.length <= 1000`。
- `s1` 與 `s2` 只包含小寫英文字母。

## 解題筆記與程式碼

通用演算法筆記：[edit_distance_dp](../algorithm/edit_distance_dp.md)
通用演算法筆記：[dp_dynamic_programming](../algorithm/dp_dynamic_programming.md)
資料結構筆記：[dp_2d_array](../data_structure/dp_2d_array.md)

### 思路拆解

- 僅允許刪除字元，使兩字串相等的最小 ASCII 總和，可視為「只允許刪除」的編輯距離 DP。
- 定義 `dp[i][j]`：讓 `s1[0..i)` 與 `s2[0..j)` 相等所需的最小刪除總和。
- 若 `s1[i-1] == s2[j-1]`，可直接對齊，不需刪除，沿用 `dp[i-1][j-1]`。
- 若不同，只能刪除其中一邊：取 `dp[i-1][j] + s1[i-1]` 或 `dp[i][j-1] + s2[j-1]` 的較小值。

### 轉移方程

令 `a = s1[i-1]`、`b = s2[j-1]`：

```
dp[i][j] =
  if a == b:
    dp[i-1][j-1]
  else:
    min(
      dp[i-1][j] + ascii(a),
      dp[i][j-1] + ascii(b)
    )
```

### 演算法

1. 建立 `(m+1) x (n+1)` 的 `dp`，`dp[i][0]` 與 `dp[0][j]` 為刪除前綴的 ASCII 總和。
2. 依序計算 `dp[i][j]`，匹配則沿用斜對角，不匹配則取刪除兩側的最小值。
3. 回傳 `dp[m][n]`。

### 時間與空間

- 時間：`O(mn)`。
- 空間：`O(mn)`，可壓縮到 `O(n)`。

```rust
impl Solution {
    pub fn minimum_delete_sum(s1: String, s2: String) -> i32 {
        let a = s1.as_bytes();
        let b = s2.as_bytes();
        let m = a.len();
        let n = b.len();

        let mut dp = vec![vec![0i32; n + 1]; m + 1];

        for i in 1..=m {
            dp[i][0] = dp[i - 1][0] + a[i - 1] as i32;
        }
        for j in 1..=n {
            dp[0][j] = dp[0][j - 1] + b[j - 1] as i32;
        }

        for i in 1..=m {
            for j in 1..=n {
                if a[i - 1] == b[j - 1] {
                    dp[i][j] = dp[i - 1][j - 1];
                } else {
                    let del_a = dp[i - 1][j] + a[i - 1] as i32;
                    let del_b = dp[i][j - 1] + b[j - 1] as i32;
                    dp[i][j] = del_a.min(del_b);
                }
            }
        }

        dp[m][n]
    }
}
```

## 實作細節

- `dp` 使用 `m+1, n+1` 的 padding 方便處理 `0` 長度前綴。
- base row/column 是刪除整段前綴的 ASCII 累加。
- 若要節省記憶體，可用滾動陣列保留上一列。
