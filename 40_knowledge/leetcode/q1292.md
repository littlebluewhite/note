---
title: q1292. Maximum Side Length of a Square with Sum Less than or Equal to Threshold / 元素和小於等於閾值的正方形的最大邊長
note_type: knowledge
domain: leetcode
tags: [leetcode, knowledge]
created: 2026-02-03
updated: 2026-02-03
status: active
source: leetcode
difficulty: Medium
complexity_time: O(mn log(min(m, n)))
complexity_space: O(mn)
review_interval_days: 14
next_review: 2026-02-17
---
# q1292. Maximum Side Length of a Square with Sum Less than or Equal to Threshold / 元素和小於等於閾值的正方形的最大邊長
[1292. Maximum Side Length of a Square with Sum Less than or Equal to Threshold](https://leetcode.com/problems/maximum-side-length-of-a-square-with-sum-less-than-or-equal-to-threshold/)

Medium

Topics

![premium lock icon](https://leetcode.com/_next/static/images/lock-a6627e2c7fa0ce8bc117c109fb4e567d.svg)Companies

Hint

Given a `m x n` matrix `mat` and an integer `threshold`, return _the maximum side-length of a square with a sum less than or equal to_ `threshold` _or return_ `0` _if there is no such square_.
給定 `m x n` 的矩陣 `mat` 與整數 `threshold`，請回傳「元素總和小於等於 `threshold`」的正方形 **最大邊長**；若不存在，回傳 `0`。

**Example 1:**

![](https://assets.leetcode.com/uploads/2019/12/05/e1.png)

**Input:** mat = [ [1,1,3,2,4,3,2],[1,1,3,2,4,3,2],[1,1,3,2,4,3,2] ], threshold = 4
**Output:** 2
**Explanation:** The maximum side length of square with sum less than 4 is 2 as shown.
**輸入：** mat = [ [1,1,3,2,4,3,2],[1,1,3,2,4,3,2],[1,1,3,2,4,3,2] ], threshold = 4
**輸出：** 2
**說明：** 總和小於 4 的正方形最大邊長為 2，如圖所示。

**Example 2:**

**Input:** mat = [ [2,2,2,2,2],[2,2,2,2,2],[2,2,2,2,2],[2,2,2,2,2],[2,2,2,2,2] ], threshold = 1
**Output:** 0
**輸入：** mat = [ [2,2,2,2,2],[2,2,2,2,2],[2,2,2,2,2],[2,2,2,2,2],[2,2,2,2,2] ], threshold = 1
**輸出：** 0

**Constraints:**

- `m == mat.length`
- `n == mat[i].length`
- `1 <= m, n <= 300`
- `0 <= mat[i][j] <= 10^4`
- `0 <= threshold <= 10^5`
- `m == mat.length`。
- `n == mat[i].length`。
- `1 <= m, n <= 300`。
- `0 <= mat[i][j] <= 10^4`。
- `0 <= threshold <= 10^5`。

## 解題筆記與程式碼

通用演算法筆記：[prefix_sum_2d](../algorithm/prefix_sum_2d.md)
通用演算法筆記：[binary_search_lower_bound](../algorithm/binary_search_lower_bound.md)
資料結構筆記：[dp_2d_array](../data_structure/dp_2d_array.md)

### 思路拆解

- 所有元素非負，因此「可行邊長」具有單調性：若存在邊長 `L` 的正方形和 `<= threshold`，則同一個正方形內的任意更小邊長也一定可行。
- 用 2D 前綴和在 `O(1)` 計算任意 `L x L` 正方形的總和；固定 `L` 時掃描所有左上角即可檢查是否可行。
- 以二分搜尋找最大可行邊長。

### 演算法

1. 建立 2D 前綴和 `pref`，大小 `(m + 1) x (n + 1)`。
2. 定義 `exists(L)`：掃描所有 `L x L` 子矩陣，若任何總和 `<= threshold` 回傳 `true`。
3. 於 `L` 範圍 `[0, min(m, n)]` 二分搜尋最大可行值。

### 時間與空間

- 時間：`O(mn log(min(m, n)))`，每次 `exists` 為 `O(mn)`。
- 空間：`O(mn)` 儲存 2D 前綴和。

```rust
impl Solution {
    fn exists_square(len: usize, pref: &Vec<Vec<i64>>, threshold: i64) -> bool {
        if len == 0 {
            return true;
        }
        let m = pref.len() - 1;
        let n = pref[0].len() - 1;
        for r in 0..=m - len {
            for c in 0..=n - len {
                let sum = pref[r + len][c + len]
                    - pref[r][c + len]
                    - pref[r + len][c]
                    + pref[r][c];
                if sum <= threshold {
                    return true;
                }
            }
        }
        false
    }

    pub fn max_side_length(mat: Vec<Vec<i32>>, threshold: i32) -> i32 {
        let m = mat.len();
        let n = mat[0].len();
        let mut pref = vec![vec![0i64; n + 1]; m + 1];
        for i in 0..m {
            for j in 0..n {
                pref[i + 1][j + 1] = pref[i][j + 1]
                    + pref[i + 1][j]
                    - pref[i][j]
                    + mat[i][j] as i64;
            }
        }

        let threshold = threshold as i64;
        let mut l = 0usize;
        let mut r = m.min(n);
        while l < r {
            let mid = (l + r + 1) / 2;
            if Self::exists_square(mid, &pref, threshold) {
                l = mid;
            } else {
                r = mid - 1;
            }
        }
        l as i32
    }
}
```
