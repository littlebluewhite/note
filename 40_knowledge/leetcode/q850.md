---
title: q850. Rectangle Area II / 矩形面積 II
note_type: knowledge
domain: leetcode
tags: [leetcode, knowledge]
created: 2026-02-03
updated: 2026-02-08
status: active
source: leetcode
complexity_time: O(n^2)
complexity_space: O(n)
review_interval_days: 14
next_review: 2026-02-22
canonical: leetcode/q850.md
---
# q850. Rectangle Area II / 矩形面積 II

[850. Rectangle Area II](https://leetcode.com/problems/rectangle-area-ii/)

Hard

You are given a 2D array of axis-aligned `rectangles`. Each `rectangle[i] = [xi1, yi1, xi2, yi2]` denotes the `ith` rectangle where `(xi1, yi1)` are the coordinates of the **bottom-left corner**, and `(xi2, yi2)` are the coordinates of the **top-right corner**.
給定一個二維陣列 `rectangles`，代表一組平行於座標軸的矩形。每個 `rectangle[i] = [xi1, yi1, xi2, yi2]` 表示第 `i` 個矩形，其中 `(xi1, yi1)` 為**左下角**座標，`(xi2, yi2)` 為**右上角**座標。

Calculate the **total area** covered by all `rectangles` in the plane. Any area covered by two or more rectangles should only be **counted once**.
計算所有矩形在平面上覆蓋的**總面積**。任何被兩個或多個矩形覆蓋的區域只計算**一次**。

Return _the total area_. Since the answer may be too large, return it **modulo** `10^9 + 7`.
回傳總面積。由於答案可能很大，請回傳結果對 `10^9 + 7` **取模**後的值。

**Example 1:**

**Input:** rectangles = [[0,0,2,2],[1,0,2,3],[1,0,3,1]]
**Output:** 6
**Explanation:** A total area of 6 is covered by all three rectangles, as illustrated in the picture.
**輸入：** rectangles = [[0,0,2,2],[1,0,2,3],[1,0,3,1]]
**輸出：** 6
**說明：** 三個矩形共覆蓋面積 6。

**Example 2:**

**Input:** rectangles = [[0,0,1000000000,1000000000]]
**Output:** 49
**Explanation:** The answer is 10^18 modulo (10^9 + 7), which is 49.
**輸入：** rectangles = [[0,0,1000000000,1000000000]]
**輸出：** 49
**說明：** 答案為 10^18 對 (10^9 + 7) 取模，結果為 49。

**Constraints:**

- `1 <= rectangles.length <= 200`
- `rectangles[i].length == 4`
- `0 <= xi1, yi1, xi2, yi2 <= 10^9`
- `xi1 < xi2` and `yi1 < yi2`

## 解題筆記與程式碼

通用演算法筆記：[coordinate_compression](../algorithm/coordinate_compression.md), [scanline_union_area_segment_tree](../algorithm/scanline_union_area_segment_tree.md)
資料結構筆記：[segment_tree_lazy](../data_structure/segment_tree_lazy.md)

### 思路拆解

- 這是計算矩形聯集面積的經典問題，座標範圍極大（最大 10^9），但矩形數量不多（最多 200）。
- 關鍵技巧：**座標壓縮 (Coordinate Compression)** 和 **掃描線 (Scanline)** 演算法。
- 將所有 x 座標與 y 座標分別收集並排序去重，得到離散化的座標網格。
- 使用掃描線技術，按 x 座標從左到右掃描，在每個 x 位置計算當前 y 方向的覆蓋區間長度，乘上 x 方向的寬度累積面積。

### 演算法

1. **座標壓縮**：
   - 收集所有矩形的 x 座標（x1, x2）和 y 座標（y1, y2）。
   - 分別對 x 和 y 座標排序去重，建立座標映射。

2. **掃描線處理**：
   - 將每個矩形拆分為兩個垂直線事件：
     - 在 x1 處標記「開始」，記錄 y 區間 [y1, y2]。
     - 在 x2 處標記「結束」，記錄 y 區間 [y1, y2]。
   - 按 x 座標排序所有事件。

3. **計算覆蓋面積**：
   - 從左到右處理事件：
     - 維護當前 y 方向的活動區間集合。
     - 計算 y 方向的聯集長度（可用差分陣列或線段樹）。
     - 面積累加：`當前 y 覆蓋長度 × (下一個 x - 當前 x)`。

4. **結果取模**：回傳面積對 `10^9 + 7` 取模。

### 時間與空間

- 時間：`O(n^2)`，其中 n 為矩形數量。座標壓縮 O(n log n)，掃描線處理每個事件時計算 y 區間聯集為 O(n)。
- 空間：`O(n)`，儲存座標與事件。

```rust
impl Solution {
    pub fn rectangle_area(rectangles: Vec<Vec<i32>>) -> i32 {
        const MOD: i64 = 1_000_000_007;
        let mut xs = std::collections::BTreeSet::new();

        // Coordinate compression for x
        for rect in &rectangles {
            xs.insert(rect[0]);
            xs.insert(rect[2]);
        }
        let xs: Vec<i32> = xs.into_iter().collect();

        let mut area = 0i64;

        // Sweep line algorithm
        for i in 0..xs.len() - 1 {
            let x1 = xs[i];
            let x2 = xs[i + 1];
            let width = (x2 - x1) as i64;

            // Collect all y intervals for this x range
            let mut intervals = Vec::new();
            for rect in &rectangles {
                if rect[0] <= x1 && x2 <= rect[2] {
                    intervals.push((rect[1], rect[3]));
                }
            }

            // Sort and merge y intervals
            if intervals.is_empty() {
                continue;
            }
            intervals.sort_unstable();

            let mut height = 0i64;
            let mut last_y1 = intervals[0].0;
            let mut last_y2 = intervals[0].1;

            for &(y1, y2) in &intervals {
                if y1 > last_y2 {
                    // No overlap, add previous interval
                    height += (last_y2 - last_y1) as i64;
                    last_y1 = y1;
                    last_y2 = y2;
                } else {
                    // Overlap or adjacent, merge
                    last_y2 = last_y2.max(y2);
                }
            }
            height += (last_y2 - last_y1) as i64;

            area = (area + width * height) % MOD;
        }

        area as i32
    }
}
```

## 補充筆記

### 核心技巧

- **座標壓縮**：將大範圍座標映射到小範圍索引，降低空間與時間複雜度。
- **掃描線**：將二維問題轉化為一維問題，按某一維度掃描，在另一維度維護狀態。
- **區間聯集**：計算 y 區間的聯集長度，可用排序合併、差分陣列或線段樹實現。

### 注意事項

- 座標可達 10^9，必須壓縮後處理，不可直接建立二維陣列。
- 答案需對 10^9 + 7 取模，注意中間計算使用 i64 避免溢位。
- 矩形保證非退化（x1 < x2, y1 < y2）。

Sources:
- [LeetCode 850](https://leetcode.com/problems/rectangle-area-ii/)
- [algo.monster explanation](https://algo.monster/liteproblems/850)
