---
title: q2977. Minimum Cost to Convert String II / 轉換字串的最小成本 II
note_type: knowledge
domain: leetcode
tags: [leetcode, knowledge]
created: 2026-02-03
updated: 2026-02-03
status: active
source: leetcode
complexity_time: O(K^3 + n * Lmax)
complexity_space: O(K^2 + n)
review_interval_days: 14
next_review: 2026-02-17
canonical: leetcode/q2977.md
---
# q2977. Minimum Cost to Convert String II / 轉換字串的最小成本 II
[2977. Minimum Cost to Convert String II](https://leetcode.com/problems/minimum-cost-to-convert-string-ii/)

Hard

Topics

![premium lock icon](https://leetcode.com/_next/static/images/lock-a6627e2c7fa0ce8bc117c109fb4e567d.svg)Companies

Hint

You are given two **0-indexed** strings `source` and `target`, both of length `n` and consisting of **lowercase** English characters. You are also given two **0-indexed** string arrays `original` and `changed`, and an integer array `cost`, where `cost[i]` represents the cost of converting the string `original[i]` to the string `changed[i]`.
給定兩個 **0-indexed** 字串 `source` 與 `target`，長度皆為 `n`，且只包含 **小寫** 英文字母。另給兩個 **0-indexed** 字串陣列 `original`、`changed`，以及整數陣列 `cost`，其中 `cost[i]` 表示把 `original[i]` 轉成 `changed[i]` 的成本。

You start with the string `source`. In one operation, you can pick a **substring** `x` from the string, and change it to `y` at a cost of `z` **if** there exists **any** index `j` such that `cost[j] == z`, `original[j] == x`, and `changed[j] == y`. You are allowed to do **any** number of operations, but any pair of operations must satisfy **either** of these two conditions:
一開始字串為 `source`。一次操作中，你可選擇一段 **子字串** `x`，並以成本 `z` 把它改成 `y`，**前提是** 存在某個索引 `j` 使得 `cost[j] == z`、`original[j] == x` 且 `changed[j] == y`。你可以做 **任意多次** 操作，但任兩次操作必須滿足 **以下之一**：

- The substrings picked in the operations are `source[a..b]` and `source[c..d]` with either `b < c` **or** `d < a`. In other words, the indices picked in both operations are **disjoint**.
- The substrings picked in the operations are `source[a..b]` and `source[c..d]` with `a == c` **and** `b == d`. In other words, the indices picked in both operations are **identical**.
- 兩次操作選到的子字串為 `source[a..b]` 與 `source[c..d]`，且 `b < c` **或** `d < a`，也就是兩段索引 **不重疊**。
- 兩次操作選到的子字串為 `source[a..b]` 與 `source[c..d]`，且 `a == c` **且** `b == d`，也就是兩段索引 **完全相同**。

Return the **minimum** cost to convert the string `source` to the string `target` using **any** number of operations. If it is impossible to convert `source` to `target`, return `-1`.
請回傳用 **任意次** 操作把 `source` 轉成 `target` 的 **最小** 成本；若無法轉換，回傳 `-1`。

**Note** that there may exist indices `i`, `j` such that `original[j] == original[i]` and `changed[j] == changed[i]`.
**注意** 可能存在 `i`, `j` 使得 `original[j] == original[i]` 且 `changed[j] == changed[i]`。

**Example 1:**

**Input:** source = "abcd", target = "acbe", original = ["a","b","c","c","e","d"], changed = ["b","c","b","e","b","e"], cost = [2,5,5,1,2,20]
**Output:** 28
**Explanation:** To convert "abcd" to "acbe", do the following operations:
- Change substring source[1..1] from "b" to "c" at a cost of 5.
- Change substring source[2..2] from "c" to "e" at a cost of 1.
- Change substring source[2..2] from "e" to "b" at a cost of 2.
- Change substring source[3..3] from "d" to "e" at a cost of 20.
The total cost incurred is 5 + 1 + 2 + 20 = 28.
It can be shown that this is the minimum possible cost.
**說明：** 要把 "abcd" 轉成 "acbe"，可做以下操作：
- 將 source[1..1] 的 "b" 改成 "c"，成本 5。
- 將 source[2..2] 的 "c" 改成 "e"，成本 1。
- 將 source[2..2] 的 "e" 改成 "b"，成本 2。
- 將 source[3..3] 的 "d" 改成 "e"，成本 20。
總成本為 5 + 1 + 2 + 20 = 28。
可證明 28 為最小可能成本。

**Example 2:**

**Input:** source = "abcdefgh", target = "acdeeghh", original = ["bcd","fgh","thh"], changed = ["cde","thh","ghh"], cost = [1,3,5]
**Output:** 9
**Explanation:** To convert "abcdefgh" to "acdeeghh", do the following operations:
- Change substring source[1..3] from "bcd" to "cde" at a cost of 1.
- Change substring source[5..7] from "fgh" to "thh" at a cost of 3. We can do this operation because indices [5,7] are disjoint with indices picked in the first operation.
- Change substring source[5..7] from "thh" to "ghh" at a cost of 5. We can do this operation because indices [5,7] are disjoint with indices picked in the first operation, and identical with indices picked in the second operation.
The total cost incurred is 1 + 3 + 5 = 9.
It can be shown that this is the minimum possible cost.
**說明：** 要把 "abcdefgh" 轉成 "acdeeghh"，可做以下操作：
- 將 source[1..3] 的 "bcd" 改成 "cde"，成本 1。
- 將 source[5..7] 的 "fgh" 改成 "thh"，成本 3。此操作與第一個操作的索引 [5,7] **不重疊**。
- 將 source[5..7] 的 "thh" 改成 "ghh"，成本 5。此操作與第一個操作不重疊，且與第二個操作索引 **完全相同**。
總成本為 1 + 3 + 5 = 9。
可證明 9 為最小可能成本。

**Example 3:**

**Input:** source = "abcdefgh", target = "addddddd", original = ["bcd","defgh"], changed = ["ddd","ddddd"], cost = [100,1578]
**Output:** -1
**Explanation:** It is impossible to convert "abcdefgh" to "addddddd".
If you select substring source[1..3] as the first operation to change "abcdefgh" to "adddefgh", you cannot select substring source[3..7] as the second operation because it has a common index, 3, with the first operation.
If you select substring source[3..7] as the first operation to change "abcdefgh" to "abcddddd", you cannot select substring source[1..3] as the second operation because it has a common index, 3, with the first operation.
**說明：** 無法把 "abcdefgh" 轉成 "addddddd"。
若先選 source[1..3] 把 "abcdefgh" 變成 "adddefgh"，第二次就不能選 source[3..7]，因為索引 3 與第一次操作 **重疊**。
若先選 source[3..7] 把 "abcdefgh" 變成 "abcddddd"，第二次也不能選 source[1..3]，同樣因為索引 3 **重疊**。

**Constraints:**

- `1 <= source.length == target.length <= 1000`
- `source`, `target` consist only of lowercase English characters.
- `1 <= cost.length == original.length == changed.length <= 100`
- `1 <= original[i].length == changed[i].length <= source.length`
- `original[i]`, `changed[i]` consist only of lowercase English characters.
- `original[i] != changed[i]`
- `1 <= cost[i] <= 10^6`
- `1 <= source.length == target.length <= 1000`。
- `source`、`target` 只包含小寫英文字母。
- `1 <= cost.length == original.length == changed.length <= 100`。
- `1 <= original[i].length == changed[i].length <= source.length`。
- `original[i]`、`changed[i]` 只包含小寫英文字母。
- `original[i] != changed[i]`。
- `1 <= cost[i] <= 10^6`。
---
## 解題筆記與程式碼

通用演算法筆記：[floyd_warshall_all_pairs_shortest_path](../algorithm/floyd_warshall_all_pairs_shortest_path.md)
通用演算法筆記：[dp_dynamic_programming](../algorithm/dp_dynamic_programming.md)
資料結構筆記：[hash_map_set](../data_structure/hash_map_set.md)
資料結構筆記：[dp_1d_array](../data_structure/dp_1d_array.md)

### 思路拆解

- 每次操作的子字串要嘛 **不重疊**，要嘛 **完全相同**。因此真正會連續套用多次的操作，只會發生在同一段索引上，可視為「同一段字串上的多步轉換」。
- 單次操作不改變長度，連續多次操作也不改變長度，所以所有可達轉換都限制在 **相同長度** 的字串之間。
- 把 `original`/`changed` 出現過的字串視為節點，對每個長度獨立建圖並做 **全點對最短路徑**，得到任意兩個字串間的最小轉換成本。
- 最後用一維 DP 切割字串：對每個位置 `i`，要嘛不動（`source[i] == target[i]`），要嘛選一段長度 `L` 的子字串做一次「最短轉換」。

### 為什麼可以用「最短路徑 + 切割 DP」

- 「相同索引」允許你在同一段上重複操作，等價於在該段字串圖上走一條路徑；最省成本就是最短路徑。
- 「不重疊」限制讓每段操作互不干擾，因此全局最小成本可以由左到右切割並用 DP 累積。

### 演算法

1. 收集 `original` 與 `changed` 的所有不同字串，依長度分組並編號。
2. 對每個長度建立距離矩陣 `dist`：
   - `dist[i][i] = 0`
   - 對每條規則 `original -> changed`，取最小成本更新 `dist`
   - 以 Floyd-Warshall 算出最短路徑
3. 一維 DP：`dp[i]` 表示轉換 `source[0..i-1]` 的最小成本。
   - 若 `source[i] == target[i]`，可不操作：`dp[i+1] = min(dp[i+1], dp[i])`
   - 對每個可用長度 `L`：
     - 若 `source[i..i+L)` 與 `target[i..i+L)` 都在字典中且最短距離有限，更新 `dp[i+L]`
4. 若 `dp[n]` 有限，回傳 `dp[n]`，否則回傳 `-1`。

### 時間與空間

- 時間：`O(K^3 + n * Lmax)`
- 空間：`O(K^2 + n)`

- 設 `K` 為不同字串總數（`K <= 200`），`n` 為字串長度（`n <= 1000`）。
- Floyd-Warshall：`O(sum K_L^3) <= O(K^3)`。
- DP：`O(n * Lmax)`，其中 `Lmax` 為規則中字串最大長度（`<= 1000`，通常 `<= 100`）。

```rust
use std::collections::HashMap;

impl Solution {
    pub fn minimum_cost(
        source: String,
        target: String,
        original: Vec<String>,
        changed: Vec<String>,
        cost: Vec<i32>,
    ) -> i64 {
        let n = source.len();
        let inf: i64 = i64::MAX / 4;

        let mut id_map: HashMap<usize, HashMap<String, usize>> = HashMap::new();
        let mut strings_by_len: HashMap<usize, Vec<String>> = HashMap::new();

        for s in original.iter().chain(changed.iter()) {
            let len = s.len();
            let entry = id_map.entry(len).or_insert_with(HashMap::new);
            if !entry.contains_key(s) {
                let id = entry.len();
                entry.insert(s.clone(), id);
                strings_by_len.entry(len).or_insert_with(Vec::new).push(s.clone());
            }
        }

        let mut dist_by_len: HashMap<usize, Vec<Vec<i64>>> = HashMap::new();
        for (len, map) in id_map.iter() {
            let m = map.len();
            let mut dist = vec![vec![inf; m]; m];
            for i in 0..m {
                dist[i][i] = 0;
            }
            dist_by_len.insert(*len, dist);
        }

        for i in 0..cost.len() {
            let len = original[i].len();
            let map = &id_map[&len];
            let u = map[&original[i]];
            let v = map[&changed[i]];
            let dist = dist_by_len.get_mut(&len).unwrap();
            let c = cost[i] as i64;
            if c < dist[u][v] {
                dist[u][v] = c;
            }
        }

        for (_len, dist) in dist_by_len.iter_mut() {
            let m = dist.len();
            for k in 0..m {
                for i in 0..m {
                    let ik = dist[i][k];
                    if ik == inf {
                        continue;
                    }
                    for j in 0..m {
                        let kj = dist[k][j];
                        if kj == inf {
                            continue;
                        }
                        let nd = ik + kj;
                        if nd < dist[i][j] {
                            dist[i][j] = nd;
                        }
                    }
                }
            }
        }

        let source_bytes = source.as_bytes();
        let target_bytes = target.as_bytes();
        let mut lengths: Vec<usize> = id_map.keys().cloned().collect();
        lengths.sort_unstable();

        let mut dp = vec![inf; n + 1];
        dp[0] = 0;

        for i in 0..n {
            if dp[i] == inf {
                continue;
            }
            if source_bytes[i] == target_bytes[i] {
                if dp[i] < dp[i + 1] {
                    dp[i + 1] = dp[i];
                }
            }

            for &len in &lengths {
                if i + len > n {
                    break;
                }
                let s_sub = std::str::from_utf8(&source_bytes[i..i + len]).unwrap();
                let t_sub = std::str::from_utf8(&target_bytes[i..i + len]).unwrap();
                let map = &id_map[&len];
                let sid = match map.get(s_sub) {
                    Some(&v) => v,
                    None => continue,
                };
                let tid = match map.get(t_sub) {
                    Some(&v) => v,
                    None => continue,
                };
                let dist = dist_by_len[&len][sid][tid];
                if dist == inf {
                    continue;
                }
                let nd = dp[i] + dist;
                if nd < dp[i + len] {
                    dp[i + len] = nd;
                }
            }
        }

        if dp[n] >= inf {
            -1
        } else {
            dp[n]
        }
    }
}
```

### 程式碼逐步解析

1. **初始化與資料結構**
   - `n`：`source` 長度。
   - `inf`：代表不可達的超大值。
   - `id_map[len][string] = id`：依「長度」分組後的字串編號表。
   - `strings_by_len`：收集同長度字串（此版本未再使用，保留無妨）。

2. **蒐集所有可用字串並編號**
   - 掃過 `original` 與 `changed`，把出現過的字串加入 `id_map`。
   - 只要是轉換規則出現過的字串，就會成為圖上的節點。

3. **建立每個長度的距離矩陣**
   - 對每個長度 `len` 建 `m x m` 的 `dist`。
   - `dist[i][i] = 0`，其餘設為 `inf`。

4. **寫入直接轉換邊**
   - 針對每條規則 `original[i] -> changed[i]`，更新 `dist[u][v]` 為最小成本。

5. **Floyd-Warshall：同長度字串的最短轉換成本**
   - 允許在同一段索引上多次操作，因此等價於在圖上走多步。
   - 計算任意兩字串間的最短路徑成本。

6. **DP 初始化**
   - `dp[i]` 表示把 `source[0..i)` 轉成 `target[0..i)` 的最小成本。
   - `dp[0] = 0`，其餘為 `inf`。
   - 收集並排序所有規則長度 `lengths`，方便提前 `break`。

7. **DP 主迴圈（從左到右切割）**
   - 若 `source[i] == target[i]`，可不操作：`dp[i+1] = min(dp[i+1], dp[i])`。
   - 枚舉每個可用長度 `len`：
     - 若 `i+len > n`，停止（長度已過界）。
     - 取 `source[i..i+len)` 與 `target[i..i+len)`。
     - 兩者都需在字典中，且最短距離 `dist` 有限。
     - 更新 `dp[i+len] = min(dp[i+len], dp[i] + dist)`。

8. **回傳答案**
   - 若 `dp[n]` 仍為 `inf`，代表不可達，回傳 `-1`。
   - 否則回傳 `dp[n]`。

### DP 小例子流程（簡化示意）

以 `source = "abcd"`, `target = "acbe"` 為例，假設最短轉換成本已算好且：
- 長度 1 的字串可轉換：`b->c` 成本 5、`c->e` 成本 1、`e->b` 成本 2、`d->e` 成本 20。
- 其他長度沒有可用轉換（為了示意簡化）。

初始化：`dp = [0, inf, inf, inf, inf]`

1. `i = 0`：`source[0] = 'a'`, `target[0] = 'a'` 相同  
   - 不操作：`dp[1] = 0`

   此時：`dp = [0, 0, inf, inf, inf]`

2. `i = 1`：`source[1] = 'b'`, `target[1] = 'c'` 不同  
   - 長度 1 轉換 `b -> c` 成本 5  
   - `dp[2] = min(dp[2], dp[1] + 5) = 5`

   此時：`dp = [0, 0, 5, inf, inf]`

3. `i = 2`：`source[2] = 'c'`, `target[2] = 'b'` 不同  
   - 先走 `c -> e` 成本 1，再 `e -> b` 成本 2  
   - 最短路徑成本 = 3  
   - `dp[3] = min(dp[3], dp[2] + 3) = 8`

   此時：`dp = [0, 0, 5, 8, inf]`

4. `i = 3`：`source[3] = 'd'`, `target[3] = 'e'` 不同  
   - 直接轉換 `d -> e` 成本 20  
   - `dp[4] = min(dp[4], dp[3] + 20) = 28`

最終：`dp[4] = 28`，即最小成本 28。

### DP 小例子（含長度 > 1 子字串）

以 `source = "abcdefgh"`, `target = "acdeeghh"` 為例，假設最短轉換成本已算好且：
- 長度 3：`bcd -> cde` 成本 1
- 長度 3：`fgh -> thh` 成本 3
- 長度 3：`thh -> ghh` 成本 5
- 其他長度皆不可用（簡化示意）

初始化：`dp[0] = 0`，其餘為 `inf`

1. `i = 0`：`a -> a` 相同  
   - 不操作：`dp[1] = 0`

2. `i = 1`：看長度 3 子字串  
   - `source[1..4) = "bcd"`, `target[1..4) = "cde"`  
   - 可轉換成本 1  
   - `dp[4] = min(dp[4], dp[1] + 1) = 1`

3. `i = 4`：`source[4] = 'e'`, `target[4] = 'e'` 相同  
   - 不操作：`dp[5] = 1`

4. `i = 5`：看長度 3 子字串  
   - `source[5..8) = "fgh"`, `target[5..8) = "ghh"`  
   - 需走 `fgh -> thh -> ghh`，成本 `3 + 5 = 8`  
   - `dp[8] = min(dp[8], dp[5] + 8) = 9`

最終：`dp[8] = 9`，對應到例題輸出 9。

### 為什麼不能重疊（反例示意）

以 `source = "abcdefgh"`, `target = "addddddd"` 為例，假設規則只有：
- `bcd -> ddd`（長度 3）
- `defgh -> ddddd`（長度 5）

兩段規則對應到索引區間：
- `bcd` 對應 `source[1..4)`（索引 1,2,3）
- `defgh` 對應 `source[3..8)`（索引 3,4,5,6,7）

這兩段 **重疊在索引 3**，因此不能同時選用。  
不管你先做哪一段，另一段就會因重疊而違規，所以整體無法完成轉換，答案為 `-1`。  

### 時間與空間複雜度（詳細推導）

設：
- `n = source.length`（`n <= 1000`）
- 規則數 `R = cost.length`（`R <= 100`）
- 不同字串總數 `K`（由 `original` 與 `changed` 去重得到，`K <= 2R`）
- 將字串按長度分組後，各組大小為 `K_L`，滿足 `sum K_L = K`

**1) 建圖與初始化**
- 收集字串與編號：`O(K)`
- 建立距離矩陣：`O(sum K_L^2)`

**2) Floyd-Warshall**
- 對每個長度獨立跑最短路徑：`O(sum K_L^3)`
- 最壞情況把所有字串都在同長度：`O(K^3)`
- 由於 `K <= 200`，此部分可接受

**3) DP 切割**
- 外層位置 `i` 有 `n` 個
- 內層枚舉規則長度數量 `Lcnt`（最多為不同長度的種類數）
- 每次擷取子字串與查表為 `O(1)`（切片 + HashMap 查找）
- 總計 `O(n * Lcnt)`
- 在極端情況下 `Lcnt <= K`，但實務上通常遠小於 `n`

**總時間複雜度**
- `O(K^3 + n * Lcnt)`
- 上界可視為 `O(K^3 + n * K)`

**空間複雜度**
- 距離矩陣：`O(sum K_L^2) <= O(K^2)`
- DP 陣列：`O(n)`
- 總計 `O(K^2 + n)`

### 為什麼最短路徑是正確的（精簡證明）

**命題 1：同一段索引上的多次操作等價於圖上的一條路徑**  
對固定長度 `L`，把所有出現過的長度 `L` 字串視為節點，規則 `x -> y` 視為有向邊，邊權為成本。  
若在同一段索引上做連續轉換 `x -> ... -> y`，其成本為路徑上邊權總和，正是圖上一條路徑的代價。

**推論：最小成本等於最短路徑**  
所有可行的多步轉換都對應到某條路徑，因此最小成本就是該圖上 `x` 到 `y` 的最短路徑成本。

**命題 2：不重疊限制使得整體成本可切割累加**  
不同操作段必須不重疊，表示一段的決策不會影響另一段的可行性或成本。  
因此全局最小成本可由左到右切割為多段子問題，總成本是各段最小成本之和。

**結論：**  
先用 Floyd-Warshall 求得每個長度內任意兩字串的最小轉換成本，  
再用一維 DP 做切割累加，即得到全局最小成本。  