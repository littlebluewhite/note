---
title: q3714. Longest Balanced Substring II / 最長平衡子字串 II
note_type: knowledge
domain: leetcode
tags: [leetcode, knowledge]
created: 2026-02-13
updated: 2026-02-13
status: active
source: leetcode
difficulty: Medium
complexity_time: O(n)
complexity_space: O(n)
review_interval_days: 14
next_review: 2026-02-27
---
# q3714. Longest Balanced Substring II / 最長平衡子字串 II
[3714. Longest Balanced Substring II](https://leetcode.com/problems/longest-balanced-substring-ii/)

Medium

Topics

Companies

Hint

You are given a string `s` consisting only of the characters `'a'`, `'b'`, and `'c'`.
給定一個字串 `s`，且 `s` 只包含字元 `'a'`、`'b'`、`'c'`。

A substring of `s` is called balanced if all distinct characters in the substring appear the same number of times.
如果某個子字串中所有「有出現」的不同字元，其出現次數都相同，則稱該子字串為平衡（balanced）。

Return the length of the longest balanced substring of `s`.
請回傳 `s` 中最長平衡子字串的長度。

### Example 1:

**Input:** `s = "abbac"`
**Output:** `4`
**Explanation:**
The longest balanced substring is `"abba"` because both distinct characters `'a'` and `'b'` each appear exactly 2 times.
最長平衡子字串是 `"abba"`，因為不同字元 `'a'` 與 `'b'` 都各出現 2 次。

### Example 2:

**Input:** `s = "aabcc"`
**Output:** `3`
**Explanation:**
The longest balanced substring is `"abc"` because all distinct characters `'a'`, `'b'` and `'c'` each appear exactly 1 time.
最長平衡子字串是 `"abc"`，因為不同字元 `'a'`、`'b'`、`'c'` 都各出現 1 次。

### Example 3:

**Input:** `s = "aba"`
**Output:** `2`
**Explanation:**
One of the longest balanced substrings is `"ab"` because both distinct characters `'a'` and `'b'` each appear exactly 1 time. Another longest balanced substring is `"ba"`.
其中一個最長平衡子字串是 `"ab"`，因為不同字元 `'a'` 與 `'b'` 都各出現 1 次；另一個同長度答案是 `"ba"`。

### Constraints:

- `1 <= s.length <= 10^5`
- `s` contains only `'a'`, `'b'`, and `'c'`.
- `1 <= s.length <= 10^5`。
- `s` 只包含 `'a'`、`'b'`、`'c'`。

## 解題筆記與程式碼

通用演算法筆記：[prefix_difference_state_matching](../algorithm/prefix_difference_state_matching.md)  
資料結構筆記：[earliest_index_state_hash_map](../data_structure/earliest_index_state_hash_map.md)  
資料結構筆記：[hash_map_set](../data_structure/hash_map_set.md)

### 思路拆解

- 目標是找最長子字串，且「子字串內有出現的字元」次數都相等。
- 字母只有 `a/b/c`，所以可把條件拆成 7 種字元集合（`a`、`b`、`c`、`ab`、`ac`、`bc`、`abc`）。
- 對每種集合，轉成「兩個前綴狀態相同 => 中間區間合法」的問題，用雜湊表記錄該狀態首次出現位置，即可在 `O(1)` 平均時間更新答案。

### 狀態轉換（前綴差分）

設前綴計數為 `(A, B, C)`：

- 只用 `a`：`(B, C)` 相同。
- 只用 `b`：`(A, C)` 相同。
- 只用 `c`：`(A, B)` 相同。
- 用 `a,b` 且 `c` 不出現：`(A - B, C)` 相同。
- 用 `a,c` 且 `b` 不出現：`(A - C, B)` 相同。
- 用 `b,c` 且 `a` 不出現：`(B - C, A)` 相同。
- 用 `a,b,c` 且三者等頻：`(A - B, A - C)` 相同。

每讀到一個新字元（前綴位置 `i`），計算上述 7 個 key：
- 若某 key 曾在位置 `j` 出現，則 `s[j..i-1]` 為合法候選，長度 `i - j`。
- 否則把當前位置記成該 key 的最早位置。

### 演算法

1. 建立 7 個 `HashMap<(i32, i32), usize>`，分別對應 7 種條件。
2. 前綴位置 `0`（空前綴）先寫入全部 map，最早位置設為 `0`。
3. 線性掃描字串並更新 `(A, B, C)`。
4. 每一步計算 7 個狀態 key，對每個 map 做：
   - 若 key 已存在：更新答案 `ans = max(ans, i - first_pos)`。
   - 若 key 不存在：記錄最早位置。
5. 回傳 `ans`。

### 時間與空間

- 時間：`O(7n)`，即 `O(n)`。
- 空間：`O(7n)`，即 `O(n)`（7 個 map 的狀態總量為線性級）。

```rust
use std::collections::HashMap;

impl Solution {
    fn states(a: i32, b: i32, c: i32) -> [(i32, i32); 7] {
        [
            (b, c),         // only a
            (a, c),         // only b
            (a, b),         // only c
            (a - b, c),     // a,b
            (a - c, b),     // a,c
            (b - c, a),     // b,c
            (a - b, a - c), // a,b,c
        ]
    }

    pub fn longest_balanced(s: String) -> i32 {
        let bytes = s.as_bytes();
        let mut cnt = [0i32; 3]; // a, b, c
        let mut ans = 0i32;

        let mut maps: Vec<HashMap<(i32, i32), usize>> =
            (0..7).map(|_| HashMap::new()).collect();

        let init_states = Self::states(0, 0, 0);
        for t in 0..7 {
            maps[t].insert(init_states[t], 0);
        }

        for (idx, &ch) in bytes.iter().enumerate() {
            match ch {
                b'a' => cnt[0] += 1,
                b'b' => cnt[1] += 1,
                b'c' => cnt[2] += 1,
                _ => unreachable!(),
            }

            let i = idx + 1; // prefix length
            let cur_states = Self::states(cnt[0], cnt[1], cnt[2]);

            for t in 0..7 {
                if let Some(&first_pos) = maps[t].get(&cur_states[t]) {
                    ans = ans.max((i - first_pos) as i32);
                } else {
                    maps[t].insert(cur_states[t], i);
                }
            }
        }

        ans
    }
}
```

## 補充筆記

- 這題關鍵不是枚舉子字串，而是把「等頻」轉成「前綴狀態相等」。
- 因為字母種類固定為 3，狀態維度固定，能在 `O(n)` 完成。

## Related problems / 相關題目

- [q3713](./q3713.md)
