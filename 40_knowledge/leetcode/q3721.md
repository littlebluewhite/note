---
title: q3721. Longest Balanced Subarray II / 最長平衡子陣列 II
note_type: knowledge
domain: leetcode
tags: [leetcode, knowledge]
created: 2026-02-11
updated: 2026-02-11
status: active
source: leetcode
difficulty: Hard
complexity_time: O(n log n)
complexity_space: O(n)
review_interval_days: 14
next_review: 2026-02-25
---
# q3721. Longest Balanced Subarray II / 最長平衡子陣列 II
[3721. Longest Balanced Subarray II](https://leetcode.com/problems/longest-balanced-subarray-ii/)

Hard

Topics

Companies

Hint

You are given an integer array `nums`.
給定一個整數陣列 `nums`。

A **subarray** is called **balanced** if the number of **distinct even** numbers in the subarray is equal to the number of **distinct odd** numbers.
若某個 **子陣列** 中，**不同偶數** 的個數等於 **不同奇數** 的個數，則稱其為 **balanced**（平衡）。

Return the length of the **longest** balanced subarray.
回傳最長平衡子陣列的長度。

**Example 1:**

**Input:** `nums = [2,5,4,3]`
**Output:** `4`
**Explanation:**
The longest balanced subarray is `[2,5,4,3]`.
最長平衡子陣列是 `[2,5,4,3]`。
It has 2 distinct even numbers `[2,4]` and 2 distinct odd numbers `[5,3]`.
其中不同偶數有 2 個（`[2,4]`），不同奇數有 2 個（`[5,3]`）。

**Example 2:**

**Input:** `nums = [3,2,2,5,4]`
**Output:** `5`
**Explanation:**
The longest balanced subarray is `[3,2,2,5,4]`.
最長平衡子陣列是 `[3,2,2,5,4]`。
It has 2 distinct even numbers `[2,4]` and 2 distinct odd numbers `[3,5]`.
其中不同偶數有 2 個（`[2,4]`），不同奇數有 2 個（`[3,5]`）。

**Example 3:**

**Input:** `nums = [1,2,3,2]`
**Output:** `3`
**Explanation:**
The longest balanced subarray is `[2,3,2]`.
最長平衡子陣列是 `[2,3,2]`。
It has 1 distinct even number `[2]` and 1 distinct odd number `[3]`.
其中不同偶數有 1 個（`[2]`），不同奇數有 1 個（`[3]`）。

**Constraints:**

- `1 <= nums.length <= 10^5`
- `nums.length` 範圍為 `1..=10^5`。
- `1 <= nums[i] <= 10^5`
- `nums[i]` 範圍為 `1..=10^5`。

## 解題筆記與程式碼

通用演算法筆記：[prefix_sum_dynamic_balance_transform](../algorithm/prefix_sum_dynamic_balance_transform.md)
資料結構筆記：[segment_tree_lazy_min_max_target_search](../data_structure/segment_tree_lazy_min_max_target_search.md)
資料結構筆記：[hashmap_vecdeque_occurrence_queue](../data_structure/hashmap_vecdeque_occurrence_queue.md)

### 思路拆解

- 對每個值只看它在當前子陣列中的「第一次出現」：若是偶數記 `+1`，奇數記 `-1`，重複出現記 `0`。  
  這樣子陣列平衡（不同偶數數量 = 不同奇數數量）就等價於區間總和為 `0`。
- 固定左邊界 `l` 時，可用前綴和 `S` 找右邊界 `r`：  
  `sum(l..r) = 0` 等價 `S[r] == 0`（此處的 `S` 是相對於目前左邊界動態調整後的版本）。
- 右邊界要找「最右的 `S[r] = 0`」，可用線段樹維護每段的 `min/max`。  
  查詢時先看右子樹是否可能含 `0`（`min <= 0 <= max`），若可能就往右找，否則往左找，得到最右答案。
- 左邊界從 `l` 移到 `l+1` 時，要移除 `nums[l]` 的貢獻。  
  若 `nums[l]` 下一次出現在 `next`，那麼這次被移除的貢獻會影響前綴和區間 `[l+1, next-1]`，做一次區間加即可（lazy propagation）。
- 用 `HashMap<i32, VecDeque<usize>>` 維護每個值的所有出現位置，便能 `O(1)` 找到 `next`。

### 演算法

1. 先建立初始前綴和（左邊界 `l = 0`）：每個值第一次出現時加上 `+1/-1`。
2. 把前綴和陣列建成線段樹，節點存 `min/max` 與 lazy tag（區間加）。
3. 枚舉左邊界 `l`：
   - 從 `l + current_best` 開始查找最右 `prefix == 0` 的位置，更新答案。
   - 從該值的位置佇列彈出當前位置，讀取下一個位置 `next`。
   - 對區間 `[l+1, next-1]` 做 `-sign(nums[l])` 的區間加，完成前綴和動態校正。
4. 回傳全域最長長度。

### 時間與空間

- 時間：`O(n log n)`（每個左邊界常數次線段樹操作）。
- 空間：`O(n)`（前綴和、線段樹、位置佇列）。

```rust
use std::collections::{HashMap, VecDeque};

#[derive(Debug, Clone, Copy)]
struct LazyTag {
    add: i32,
}

impl LazyTag {
    fn new() -> Self {
        Self { add: 0 }
    }

    fn is_empty(&self) -> bool {
        self.add == 0
    }

    fn combine(&mut self, other: &LazyTag) {
        self.add += other.add;
    }

    fn clear(&mut self) {
        self.add = 0;
    }
}

#[derive(Debug, Clone)]
struct Node {
    min_val: i32,
    max_val: i32,
    lazy: LazyTag,
}

impl Node {
    fn new() -> Self {
        Self {
            min_val: 0,
            max_val: 0,
            lazy: LazyTag::new(),
        }
    }
}

struct SegmentTree {
    n: usize,
    tree: Vec<Node>,
}

impl SegmentTree {
    fn new(data: &[i32]) -> Self {
        let n = data.len();
        let mut seg = Self {
            n,
            tree: vec![Node::new(); n * 4 + 5],
        };
        seg.build(data, 1, n, 1);
        seg
    }

    fn build(&mut self, data: &[i32], l: usize, r: usize, idx: usize) {
        if l == r {
            self.tree[idx].min_val = data[l - 1];
            self.tree[idx].max_val = data[l - 1];
            return;
        }
        let mid = (l + r) / 2;
        self.build(data, l, mid, idx * 2);
        self.build(data, mid + 1, r, idx * 2 + 1);
        self.push_up(idx);
    }

    fn push_up(&mut self, idx: usize) {
        self.tree[idx].min_val = self.tree[idx * 2].min_val.min(self.tree[idx * 2 + 1].min_val);
        self.tree[idx].max_val = self.tree[idx * 2].max_val.max(self.tree[idx * 2 + 1].max_val);
    }

    fn apply(&mut self, idx: usize, tag: &LazyTag) {
        self.tree[idx].min_val += tag.add;
        self.tree[idx].max_val += tag.add;
        self.tree[idx].lazy.combine(tag);
    }

    fn push_down(&mut self, idx: usize) {
        if self.tree[idx].lazy.is_empty() {
            return;
        }
        let tag = self.tree[idx].lazy;
        self.apply(idx * 2, &tag);
        self.apply(idx * 2 + 1, &tag);
        self.tree[idx].lazy.clear();
    }

    fn range_add(&mut self, l: usize, r: usize, val: i32) {
        if l > r || l > self.n || r < 1 {
            return;
        }
        let tag = LazyTag { add: val };
        self.update(l, r, &tag, 1, self.n, 1);
    }

    fn update(&mut self, ql: usize, qr: usize, tag: &LazyTag, l: usize, r: usize, idx: usize) {
        if ql > r || qr < l {
            return;
        }
        if ql <= l && r <= qr {
            self.apply(idx, tag);
            return;
        }
        self.push_down(idx);
        let mid = (l + r) / 2;
        if ql <= mid {
            self.update(ql, qr, tag, l, mid, idx * 2);
        }
        if qr > mid {
            self.update(ql, qr, tag, mid + 1, r, idx * 2 + 1);
        }
        self.push_up(idx);
    }

    fn find_last_value(&mut self, start: usize, target: i32) -> i32 {
        if start > self.n {
            return -1;
        }
        self.find(start, self.n, target, 1, self.n, 1)
    }

    fn find(&mut self, ql: usize, qr: usize, target: i32, l: usize, r: usize, idx: usize) -> i32 {
        if l > qr || r < ql || self.tree[idx].min_val > target || self.tree[idx].max_val < target {
            return -1;
        }
        if l == r {
            return l as i32;
        }
        self.push_down(idx);
        let mid = (l + r) / 2;
        let right = self.find(ql, qr, target, mid + 1, r, idx * 2 + 1);
        if right != -1 {
            return right;
        }
        self.find(ql, qr, target, l, mid, idx * 2)
    }
}

impl Solution {
    pub fn longest_balanced(nums: Vec<i32>) -> i32 {
        let n = nums.len();
        if n == 0 {
            return 0;
        }

        fn parity_sign(x: i32) -> i32 {
            if x % 2 == 0 {
                1
            } else {
                -1
            }
        }

        let mut prefix_sum = vec![0; n];
        let mut positions: HashMap<i32, VecDeque<usize>> = HashMap::new();

        for i in 0..n {
            if i > 0 {
                prefix_sum[i] = prefix_sum[i - 1];
            }
            let q = positions.entry(nums[i]).or_insert_with(VecDeque::new);
            if q.is_empty() {
                prefix_sum[i] += parity_sign(nums[i]);
            }
            q.push_back(i + 1);
        }

        let mut seg = SegmentTree::new(&prefix_sum);
        let mut best = 0i32;

        for left in 0..n {
            let search_start = left + best as usize + 1;
            if search_start <= n {
                let right = seg.find_last_value(search_start, 0);
                if right != -1 {
                    best = best.max(right - left as i32);
                }
            }

            let x = nums[left];
            let next_pos = positions
                .get_mut(&x)
                .and_then(|q| {
                    q.pop_front();
                    q.front().copied()
                })
                .unwrap_or(n + 2);

            let delta = -parity_sign(x);
            let l = left + 1;
            let r = next_pos - 1;
            if l <= r {
                seg.range_add(l, r, delta);
            }
        }

        best
    }
}
```

## 補充筆記：利用「前綴和 + lazy 線段樹 + 出現位置佇列」處理動態左邊界。

## 實作細節

- 線段樹索引採 `1-based`，前綴和 `prefix_sum[i]` 對應到位置 `i+1`。
- `find_last_value` 右子樹優先，保證回傳最右位置。
- 左邊界平移時的更新區間一定是 `[left+1, next_pos-1]`，不要寫成 `[left, next_pos-1]`。
