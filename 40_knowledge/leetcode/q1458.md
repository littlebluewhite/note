---
title: q1458. Max Dot Product of Two Subsequences / 兩個子序列的最大點積
note_type: knowledge
domain: leetcode
tags: [leetcode, knowledge]
created: 2026-02-03
updated: 2026-02-03
status: active
source: leetcode
difficulty: Hard
complexity_time: O(mn)
complexity_space: O(mn)
review_interval_days: 14
next_review: 2026-02-17
---
# q1458. Max Dot Product of Two Subsequences / 兩個子序列的最大點積
[1458. Max Dot Product of Two Subsequences](https://leetcode.com/problems/max-dot-product-of-two-subsequences/)

Hard

Topics

![premium lock icon](https://leetcode.com/_next/static/images/lock-a6627e2c7fa0ce8bc117c109fb4e567d.svg)Companies

Hint

Given two arrays `nums1` and `nums2`.
給定兩個陣列 `nums1` 與 `nums2`。

Return the maximum dot product between **non-empty** subsequences of nums1 and nums2 with the same length.
請回傳 `nums1` 與 `nums2` 之中取出長度相同且 **非空** 子序列後的最大內積。

A subsequence of a array is a new array which is formed from the original array by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, `[2,3,5]` is a subsequence of `[1,2,3,4,5]` while `[1,5,3]` is not).
子序列是從原陣列刪除部分元素（可不刪）但不改變相對順序的新陣列（例如 `[2,3,5]` 是 `[1,2,3,4,5]` 的子序列，但 `[1,5,3]` 不是）。

**Example 1:**

**Input:** nums1 = [2,1,-2,5], nums2 = [3,0,-6]
**Output:** 18
**Explanation:** Take subsequence [2,-2] from nums1 and subsequence [3,-6] from nums2.
Their dot product is (2*3 + (-2)*(-6)) = 18.
**解釋：** 從 nums1 取子序列 [2,-2]，從 nums2 取子序列 [3,-6]。
它們的內積為 (2*3 + (-2)*(-6)) = 18。

**Example 2:**

**Input:** nums1 = [3,-2], nums2 = [2,-6,7]
**Output:** 21
**Explanation:** Take subsequence [3] from nums1 and subsequence [7] from nums2.
Their dot product is (3*7) = 21.
**解釋：** 從 nums1 取子序列 [3]，從 nums2 取子序列 [7]。
它們的內積為 (3*7) = 21。

**Example 3:**

**Input:** nums1 = [-1,-1], nums2 = [1,1]
**Output:** -1
**Explanation:** Take subsequence [-1] from nums1 and subsequence [1] from nums2.
Their dot product is -1.
**解釋：** 從 nums1 取子序列 [-1]，從 nums2 取子序列 [1]。
它們的內積為 -1。

**Constraints:**

- `1 <= nums1.length, nums2.length <= 500`
- `-1000 <= nums1[i], nums2[i] <= 1000`
- `1 <= nums1.length, nums2.length <= 500`。
- `-1000 <= nums1[i], nums2[i] <= 1000`。

## 解題筆記與程式碼

通用演算法筆記：[two_sequence_dp](../algorithm/two_sequence_dp.md)
通用演算法筆記：[dp_dynamic_programming](../algorithm/dp_dynamic_programming.md)
資料結構筆記：[dp_2d_array](../data_structure/dp_2d_array.md)

### 思路拆解

- 這是典型的雙序列 DP：在兩個前綴上決定是否配對 `nums1[i]` 與 `nums2[j]`。
- 定義 `dp[i][j]` 為使用 `nums1[0..i]` 與 `nums2[0..j]` 的 **非空** 子序列最大內積。
- 轉移時同時考慮「跳過其中一邊」、「直接以 (i,j) 開始新子序列」、「在既有結果上延伸」。
- 因為答案可能為負數，必須保留「只選一對元素」的候選，避免被 0 取代。

### 轉移方程

令 `prod = nums1[i] * nums2[j]`，則：

```
dp[i][j] = max(
  dp[i-1][j],        // 跳過 nums1[i]
  dp[i][j-1],        // 跳過 nums2[j]
  prod,              // 只選 (i,j) 開始
  prod + dp[i-1][j-1]// 延伸既有子序列
)
```

邊界 `i == 0` 或 `j == 0` 時，只保留合法的項目即可。

### 演算法

1. 令 `m = nums1.len()`、`n = nums2.len()`，建立 `m x n` 的 `dp`。
2. 依序走訪 `(i, j)`，用上式更新 `dp[i][j]`。
3. 回傳 `dp[m-1][n-1]`。

### 時間與空間

- 時間：`O(mn)`。
- 空間：`O(mn)`，可視需求壓縮到 `O(n)`。

```rust
impl Solution {
    pub fn max_dot_product(nums1: Vec<i32>, nums2: Vec<i32>) -> i32 {
        let m = nums1.len();
        let n = nums2.len();
        let mut dp = vec![vec![0; n]; m];

        for i in 0..m {
            for j in 0..n {
                let prod = nums1[i] * nums2[j];
                let mut best = prod;

                if i > 0 {
                    best = best.max(dp[i - 1][j]);
                }
                if j > 0 {
                    best = best.max(dp[i][j - 1]);
                }
                if i > 0 && j > 0 {
                    best = best.max(prod + dp[i - 1][j - 1]);
                }
                dp[i][j] = best;
            }
        }

        dp[m - 1][n - 1]
    }
}
```

### 空間壓縮版本（O(n)）

若要把空間降到 `O(n)`，可用滾動陣列保留上一列：

```rust
impl Solution {
    pub fn max_dot_product(nums1: Vec<i32>, nums2: Vec<i32>) -> i32 {
        let m = nums1.len();
        let n = nums2.len();
        let mut prev = vec![0; n];
        let mut cur = vec![0; n];

        for i in 0..m {
            for j in 0..n {
                let prod = nums1[i] * nums2[j];
                let mut best = prod;

                if i > 0 {
                    best = best.max(prev[j]);
                }
                if j > 0 {
                    best = best.max(cur[j - 1]);
                }
                if i > 0 && j > 0 {
                    best = best.max(prod + prev[j - 1]);
                }
                cur[j] = best;
            }
            std::mem::swap(&mut prev, &mut cur);
        }

        prev[n - 1]
    }
}
```

## 實作細節

- `dp[i][j]` 一律代表 **非空** 子序列，來源要不是 `prod`，要不是前一步的有效結果。
- 由於數值可能全為負，不能讓 0 當作空序列的結果混入比較。
