---
title: q66. Plus One / 加一
note_type: knowledge
domain: leetcode
tags: [leetcode, knowledge]
created: 2026-02-03
updated: 2026-02-03
status: active
source: leetcode
complexity_time: O(n)
complexity_space: O(1)
review_interval_days: 14
next_review: 2026-02-17
canonical: leetcode/q66.md
---
# q66. Plus One / 加一
[66. Plus One](https://leetcode.com/problems/plus-one/)

Easy

Topics

![premium lock icon](https://leetcode.com/_next/static/images/lock-a6627e2c7fa0ce8bc117c109fb4e567d.svg)Companies

You are given a **large integer** represented as an integer array `digits`, where each `digits[i]` is the `ith` digit of the integer. The digits are ordered from most significant to least significant in left-to-right order. The large integer does not contain any leading `0`'s.
給定一個以整數陣列 `digits` 表示的 **大整數**，其中 `digits[i]` 是整數的第 `i` 位數字。陣列由左至右為「最高位到最低位」，且不含前導 `0`。

Increment the large integer by one and return _the resulting array of digits_.
請將此大整數加一，回傳結果的數字陣列。

**Example 1:**

**Input:** digits = [1,2,3]
**Output:** [1,2,4]
**Explanation:** The array represents the integer 123.
Incrementing by one gives 123 + 1 = 124.
Thus, the result should be [1,2,4].
**輸入：** digits = [1,2,3]
**輸出：** [1,2,4]
**說明：** 陣列代表整數 123。
加一後為 123 + 1 = 124。
因此結果為 [1,2,4]。

**Example 2:**

**Input:** digits = [4,3,2,1]
**Output:** [4,3,2,2]
**Explanation:** The array represents the integer 4321.
Incrementing by one gives 4321 + 1 = 4322.
Thus, the result should be [4,3,2,2].
**輸入：** digits = [4,3,2,1]
**輸出：** [4,3,2,2]
**說明：** 陣列代表整數 4321。
加一後為 4321 + 1 = 4322。
因此結果為 [4,3,2,2]。

**Example 3:**

**Input:** digits = [9]
**Output:** [1,0]
**Explanation:** The array represents the integer 9.
Incrementing by one gives 9 + 1 = 10.
Thus, the result should be [1,0].
**輸入：** digits = [9]
**輸出：** [1,0]
**說明：** 陣列代表整數 9。
加一後為 9 + 1 = 10。
因此結果為 [1,0]。

**Constraints:**

- `1 <= digits.length <= 100`
- `0 <= digits[i] <= 9`
- `digits` does not contain any leading `0`'s.
- `1 <= digits.length <= 100`。
- `0 <= digits[i] <= 9`。
- `digits` 不含前導 `0`。

## 解題筆記與程式碼

通用演算法筆記：[carry_propagation_addition](../algorithm/carry_propagation_addition.md)
資料結構筆記：[dynamic_array_vec](../algorithm/dynamic_array_vec.md)

### 思路拆解

- 數字由高位到低位排列，做加一時應從尾端（最低位）開始處理。
- 若某一位小於 9，該位加一即可結束；若為 9，則該位變 0 並把進位往前傳。
- 若所有位數都是 9，會產生新的一位 `1`，其餘為 `0`。

### 演算法

1. 從最後一位往前掃描：
   - 若 `digits[i] < 9`，則 `digits[i] += 1`，直接回傳。
   - 否則設為 `0`，繼續往前。
2. 若掃完整個陣列都沒有回傳，代表全為 `9`，建立新陣列 `[1, 0, 0, ...]` 回傳。

### 時間與空間

- 時間：`O(n)`，最多掃過一次陣列。
- 空間：一般情況 `O(1)` 額外空間；全為 `9` 時需建立新陣列，為 `O(n)`。

```rust
impl Solution {
    pub fn plus_one(mut digits: Vec<i32>) -> Vec<i32> {
        for i in (0..digits.len()).rev() {
            if digits[i] < 9 {
                digits[i] += 1;
                return digits;
            }
            digits[i] = 0;
        }

        let mut res = Vec::with_capacity(digits.len() + 1);
        res.push(1);
        res.extend(digits);
        res
    }
}
```
