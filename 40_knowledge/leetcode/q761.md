---
title: q761. Special Binary String / 特殊二進位字串
note_type: knowledge
domain: leetcode
tags: [leetcode, knowledge]
created: 2026-02-20
updated: 2026-02-20
status: active
source: leetcode
difficulty: Hard
complexity_time: O(n^2 log n)
complexity_space: O(n^2)
review_interval_days: 14
next_review: 2026-03-06
---
# q761. Special Binary String / 特殊二進位字串
[761. Special Binary String](https://leetcode.com/problems/special-binary-string/)

Hard

A binary string is special if the following conditions are met:
若一個二進位字串符合以下條件，則稱為特殊字串：

- The number of `'0'`s is equal to the number of `'1'`s.
- `'0'` 的數量等於 `'1'` 的數量。
- Every prefix of the binary string has at least as many `'1'`s as `'0'`s.
- 對任一前綴，`'1'` 的數量都不少於 `'0'`。

You are given a special binary string `s`.
給定一個特殊二進位字串 `s`。

A move consists of choosing two consecutive, non-empty, special substrings of `s`, and swapping them.
一次操作可選擇 `s` 中兩個相鄰且非空的特殊子字串，並交換其順序。

Return the lexicographically largest string possible after applying any number of moves.
請回傳在可進行任意次操作後，字典序最大的字串。

**Example 1:**

**Input:** s = "11011000"
**Output:** "11100100"
**Explanation:** One valid sequence of moves is:
- Split as `1 [10][1100] 0`, swap middle two blocks -> `11100100`.
A more explicit view is to recursively optimize each primitive special block and then sort them descending.
**輸入：** s = "11011000"
**輸出：** "11100100"
**說明：** 一種合法操作序列是先找出相鄰特殊區塊後交換；等價地可視為把每個基礎特殊區塊遞迴最佳化後，依字典序降序重排，得到 `"11100100"`。

**Example 2:**

**Input:** s = "10"
**Output:** "10"
**輸入：** s = "10"
**輸出：** "10"

**Constraints:**

- `1 <= s.length <= 50`
- `s[i]` is either `'0'` or `'1'`.
- `s` is guaranteed to be a special binary string.
- `1 <= s.length <= 50`
- `s[i]` 只會是 `'0'` 或 `'1'`。
- 保證 `s` 本身是特殊字串。

## 解題筆記與程式碼

通用演算法筆記：[balanced_prefix_decomposition_recursive_sort](../algorithm/balanced_prefix_decomposition_recursive_sort.md)
通用演算法筆記：[sorting_custom_order](../algorithm/sorting_custom_order.md)
資料結構筆記：[string_block_vector](../data_structure/string_block_vector.md)
資料結構筆記：[array](../data_structure/array.md)

### 思路拆解

- 把 `'1'` 視為上坡、`'0'` 視為下坡，特殊字串等價於一段「不跌破起點且最後回到起點」的路徑。
- 掃描字串並用 `balance`（`'1'` +1、`'0'` -1）切出最外層 primitive blocks：每次 `balance == 0` 就得到一個頂層特殊區塊。
- 每個區塊形如 `1 + inner + 0`，其中 `inner` 仍是特殊字串集合的串接；可遞迴求其最佳結果。
- 把同一層所有最佳化後區塊做字典序降序排序，再串接，因為越大的區塊放前面會讓整體字典序最大。

### A/B 實作方向（對照）

- A（偏效能）
  - 用位元組索引遞迴處理區間，盡量延後 `String` 實體化，降低切片與複製常數。
  - 在合併邊界才建立 owned `String`，排序採 `sort_unstable_by(|a, b| b.cmp(a))`。
- B（偏穩定、可讀）
  - 直接以 `&str` 做遞迴分解：切塊、遞迴 inner、重建 block、排序、`concat`。
  - 在 `n <= 50` 下足夠通過，且最容易檢查正確性。

以下採 B 作為最終提交版本（簡潔且穩定）。

### 演算法

1. 定義 `dfs(t)` 回傳 `t` 可達到的字典序最大特殊字串。
2. 線性掃描 `t`，用 `balance` 找出每個頂層 block 範圍 `[start..=i]`。
3. 對 block 的內層 `t[start+1..i]` 遞迴：`best = "1" + dfs(inner) + "0"`。
4. 收集本層所有 `best` 到 `Vec<String>`，降序排序後 `concat`。
5. 回傳 `dfs(s)`。

### 時間與空間

- 時間：`O(n^2 log n)`（遞迴層內排序與字串操作累積）。
- 空間：`O(n^2)`（遞迴與字串建構總量）。

```rust
impl Solution {
    pub fn make_largest_special(s: String) -> String {
        fn dfs(t: &str) -> String {
            let b = t.as_bytes();
            let mut balance = 0i32;
            let mut start = 0usize;
            let mut blocks: Vec<String> = Vec::new();

            for i in 0..b.len() {
                if b[i] == b'1' {
                    balance += 1;
                } else {
                    balance -= 1;
                }

                if balance == 0 {
                    let inner = if i > start + 1 {
                        dfs(&t[start + 1..i])
                    } else {
                        String::new()
                    };

                    let mut block = String::with_capacity(i - start + 1);
                    block.push('1');
                    block.push_str(&inner);
                    block.push('0');
                    blocks.push(block);
                    start = i + 1;
                }
            }

            blocks.sort_unstable_by(|a, b| b.cmp(a));
            blocks.concat()
        }

        dfs(&s)
    }
}
```

## 補充筆記

- 正確性核心：
  - 頂層 block 之間互不重疊且皆為特殊字串，任意操作本質上是在同層重排這些 block。
  - 每個 block 內部的最佳化彼此獨立，先遞迴最佳化再排序即可達全域最優。
- 實務細節：
  - 本題輸入只含 ASCII `'0'/'1'`，以 byte index 切片是安全的。
  - `sort_unstable_by` 較輕量，且本題不需要穩定排序。

References:
- [LeetCode 761](https://leetcode.com/problems/special-binary-string/)
- [LeetCode hint/editorial page](https://leetcode.com/problems/special-binary-string/editorial/)
- [Doocs mirror explanation](https://leetcode.doocs.org/en/lc/761/)
