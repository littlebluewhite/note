---
title: q67. Add Binary / 二進位加總
note_type: knowledge
domain: leetcode
tags: [leetcode, knowledge]
created: 2026-02-15
updated: 2026-02-15
status: active
source: leetcode
difficulty: Easy
complexity_time: O(max(n, m))
complexity_space: O(max(n, m))
review_interval_days: 14
next_review: 2026-03-01
---
# q67. Add Binary / 二進位加總
[67. Add Binary](https://leetcode.com/problems/add-binary/)

Easy

Topics

![premium lock icon](https://leetcode.com/_next/static/images/lock-a6627e2c7fa0ce8bc117c109fb4e567d.svg)Companies

Given two binary strings `a` and `b`, return their sum as a binary string.
給定兩個二進位字串 `a` 與 `b`，請回傳它們的加總結果（二進位字串）。

**Example 1:**

**Input:** a = "11", b = "1"
**Output:** "100"
**輸入：** a = "11", b = "1"
**輸出：** "100"

**Example 2:**

**Input:** a = "1010", b = "1011"
**Output:** "10101"
**輸入：** a = "1010", b = "1011"
**輸出：** "10101"

**Constraints:**

- `1 <= a.length, b.length <= 10^4`
- `a` and `b` consist only of `'0'` or `'1'` characters.
- Each string does not contain leading zeros except for the zero itself.
- `1 <= a.length, b.length <= 10^4`。
- `a` 與 `b` 只包含 `'0'` 或 `'1'`。
- 除了數值 `0` 本身外，字串不含前導零。

## 解題筆記與程式碼

通用演算法筆記：[carry_propagation_addition](../algorithm/carry_propagation_addition.md)
資料結構筆記：[array](../data_structure/array.md)

### 思路拆解

- 這題本質是手算直式加法，只是進位基底是 2。
- 從兩字串尾端（最低位）往前走，用 `carry` 紀錄進位。
- 每一位的規則固定：
  - `sum = bit_a + bit_b + carry`
  - 當前答案位 `sum % 2`
  - 新進位 `sum / 2`
- 因為我們從低位往高位計算，答案先 append 會是反向，需要最後 reverse。

### 演算法

1. 設兩個指標 `i = a.len()-1`、`j = b.len()-1`，以及 `carry = 0`。
2. 當 `i >= 0` 或 `j >= 0` 或 `carry > 0` 時重複：
   - 取 `a[i]`、`b[j]` 的位元值（若越界則視為 `0`）。
   - 計算 `sum = bit_a + bit_b + carry`。
   - 將 `(sum % 2)` 對應成字元 `'0'`/`'1'` push 到結果陣列。
   - 更新 `carry = sum / 2`，指標左移。
3. 將結果陣列 reverse 後轉回字串並回傳。

### 時間與空間

- 時間：`O(max(n, m))`，每個字元最多處理一次。
- 空間：`O(max(n, m))`，用來存放答案字串（若不計輸出本身，額外空間可視為 `O(1)`）。

```rust
impl Solution {
    pub fn add_binary(a: String, b: String) -> String {
        let ab = a.as_bytes();
        let bb = b.as_bytes();
        let mut i = ab.len() as i32 - 1;
        let mut j = bb.len() as i32 - 1;
        let mut carry = 0;
        let mut out: Vec<u8> = Vec::with_capacity(ab.len().max(bb.len()) + 1);

        while i >= 0 || j >= 0 || carry > 0 {
            let da = if i >= 0 { (ab[i as usize] - b'0') as i32 } else { 0 };
            let db = if j >= 0 { (bb[j as usize] - b'0') as i32 } else { 0 };
            let sum = da + db + carry;

            out.push((sum % 2) as u8 + b'0');
            carry = sum / 2;
            i -= 1;
            j -= 1;
        }

        out.reverse();
        String::from_utf8(out).unwrap()
    }
}
```

## 補充筆記

- 這個寫法可直接泛化為任意進位 `base` 的字串加法，只要把 `% 2`、`/ 2` 改為 `% base`、`/ base`。
- 與 [q66](./q66.md) 的差別是：q66 只有一個數字加一；q67 是兩個字串逐位相加。
