---
title: q3634. Minimum Removals to Balance Array / 平衡陣列的最少移除次數
note_type: knowledge
domain: leetcode
tags: [leetcode, knowledge]
created: 2026-02-06
updated: 2026-02-06
status: active
source: leetcode
complexity_time: O(n log n)
complexity_space: O(1)
review_interval_days: 14
next_review: 2026-02-20
---
# q3634. Minimum Removals to Balance Array / 平衡陣列的最少移除次數
[3634. Minimum Removals to Balance Array](https://leetcode.com/problems/minimum-removals-to-balance-array/)

Medium

Topics

## 題目原文 (EN) + 翻譯 (ZH)

You are given an integer array `nums` and an integer `k`.
給定整數陣列 `nums` 與整數 `k`。

An array is considered **balanced** if the value of its **maximum** element is **at most** `k` times the **minimum** element.
如果陣列的 **最大值** 不超過 **最小值的 `k` 倍**，則稱該陣列為 **balanced**。

You may remove **any** number of elements from `nums` without making it **empty**.
你可以從 `nums` 移除任意數量的元素，但移除後不能為空。

Return the **minimum** number of elements to remove so that the remaining array is balanced.
請回傳使剩餘陣列 balanced 所需移除的 **最少** 元素數量。

Note: An array of size 1 is considered balanced as its maximum and minimum are equal, and the condition always holds true.
注意：長度為 1 的陣列一定 balanced（最大值=最小值）。

**Example 1:**

**Input:** `nums = [2,1,5], k = 2`
**Output:** `1`

**Explanation:**
**說明：**

- Remove `nums[2] = 5` to get `nums = [2, 1]`.
- 移除 `5`，得到 `nums = [2, 1]`。
- Now `max = 2`, `min = 1` and `max <= min * k` as `2 <= 1 * 2`.
- 此時 `max = 2`, `min = 1`，且 `2 <= 1 * 2`，條件成立。

**Example 2:**

**Input:** `nums = [1,6,2,9], k = 3`
**Output:** `2`

**Explanation:**
**說明：**

- Remove `nums[0] = 1` and `nums[3] = 9` to get `nums = [6, 2]`.
- 移除 `1` 與 `9`，得到 `nums = [6, 2]`。
- Now `max = 6`, `min = 2` and `max <= min * k` as `6 <= 2 * 3`.
- 此時 `max = 6`, `min = 2`，且 `6 <= 2 * 3`，條件成立。

**Example 3:**

**Input:** `nums = [4,6], k = 2`
**Output:** `0`

**Explanation:**
**說明：**

- Since `nums` is already balanced as `6 <= 4 * 2`, no elements need to be removed.
- 因為已滿足 `6 <= 4 * 2`，不需要移除。

**Constraints:**

- `1 <= nums.length <= 10^5`
- `1 <= nums[i] <= 10^9`
- `1 <= k <= 10^5`

## 解題筆記與程式碼

通用演算法筆記：
- [two_pointers](../algorithm/two_pointers.md)
- [sliding_window](../algorithm/sliding_window.md)

資料結構筆記：
- [sorted_array](../data_structure/sorted_array.md)

### 核心想法（一句話）

排序後用雙指標找最長區間使 `a[r] <= a[l] * k`，答案就是 `n - maxLen`。

### 思路拆解

若排序後為 `a`（非遞減）：
- 對於任何保留的元素集合，若它 balanced，則其 `min` 與 `max` 必然是排序後某段區間的兩端。
- 因此我們要找「最大的子序列大小」使得 `max <= min * k`；等價於在排序後找最長的連續區間 `[l, r]` 滿足 `a[r] <= a[l] * k`。
- 要移除最少元素，就是保留最多元素：`ans = n - (r-l+1)` 的最小值，即 `n - maxLen`。

### 演算法

1. 將 `nums` 升冪排序為 `a`。
2. 用雙指標：
   - 固定左端 `l`，右端 `r` 盡量往右擴張，直到條件不成立。
   - 每次更新 `maxLen = max(maxLen, r-l+1)`。
3. 回傳 `n - maxLen`。

### 正確性要點

- 排序後，對固定 `l`，當 `r` 往右移時 `a[r]` 單調不減，因此條件 `a[r] <= a[l] * k` 對 `r` 具有「可擴張直到失敗」的單調性，可以用 two pointers 線性掃。

### 時間與空間

- 時間：`O(n log n)`（排序） + `O(n)`（雙指標）。
- 空間：`O(1)` 額外空間（就地排序），不含輸入。

```rust
impl Solution {
    pub fn minimum_removals_to_balance_array(mut nums: Vec<i32>, k: i32) -> i32 {
        nums.sort_unstable();
        let n = nums.len();

        let k = k as i128;
        let mut best: usize = 1;
        let mut r: usize = 0;

        for l in 0..n {
            if r < l {
                r = l;
            }
            while r + 1 < n {
                let minv = nums[l] as i128;
                let next = nums[r + 1] as i128;
                if next <= minv * k {
                    r += 1;
                } else {
                    break;
                }
            }
            best = best.max(r - l + 1);
        }

        (n - best) as i32
    }
}
```

## Related problems / 相關題目

- 類似「排序 + 雙指標找最大合法區間」：
  - [q1984](q1984.md)
