---
title: q868. Binary Gap / 二進位間距
note_type: knowledge
domain: leetcode
tags: [leetcode, knowledge]
created: 2026-02-22
updated: 2026-02-22
status: active
source: leetcode
difficulty: Easy
complexity_time: O(log n)
complexity_space: O(1)
review_interval_days: 14
next_review: 2026-03-08
---
# q868. Binary Gap / 二進位間距
[868. Binary Gap](https://leetcode.com/problems/binary-gap/)

Easy

Topics

Companies

Given a positive integer `n`, find and return the **longest distance** between any two **adjacent** `1`'s in the binary representation of `n`. If there are no two adjacent `1`'s, return `0`.
給定一個正整數 `n`，請找出並回傳其二進位表示中，任兩個**相鄰** `1` 之間的**最長距離**。若不存在兩個相鄰的 `1`，回傳 `0`。

Two `1`'s are **adjacent** if there are only `0`'s separating them (possibly no `0`'s). The distance between two `1`'s is the absolute difference between their bit positions. For example, the two `1`'s in `"1001"` have a distance of `3`.
所謂兩個 `1` **相鄰**，表示它們中間只能有 `0`（也可能沒有 `0`）。兩個 `1` 的距離定義為位元位置索引的絕對差。例如 `"1001"` 中兩個 `1` 的距離是 `3`。

**Example 1:**

**Input:** n = 22
**Output:** 2
**Explanation:** 22 in binary is `"10110"`. The first adjacent pair of `1`'s has distance `2`; the second adjacent pair has distance `1`. The maximum is `2`.
**說明：** `22` 的二進位是 `"10110"`。第一組相鄰 `1` 的距離是 `2`；第二組相鄰 `1` 的距離是 `1`。取最大值後答案為 `2`。

**Example 2:**

**Input:** n = 8
**Output:** 0
**Explanation:** 8 in binary is `"1000"`. There is only one `1`, so no adjacent pair exists.
**說明：** `8` 的二進位是 `"1000"`。只有一個 `1`，不存在相鄰 `1` 配對，因此答案是 `0`。

**Example 3:**

**Input:** n = 5
**Output:** 2
**Explanation:** 5 in binary is `"101"`, and the two adjacent `1`'s are 2 positions apart.
**說明：** `5` 的二進位是 `"101"`，兩個相鄰 `1` 的距離為 `2`。

**Constraints:**

- `1 <= n <= 10^9`
- `1 <= n <= 10^9`。

## 解題筆記與程式碼

通用演算法筆記：[bit_position_gap_scan](../algorithm/bit_position_gap_scan.md)  
資料結構筆記：[fixed_width_bitmask_integer](../data_structure/fixed_width_bitmask_integer.md)

### 思路拆解

- 用位移掃描 `n` 的每一個 bit，從最低位到最高位。
- 記錄目前掃描到的位元索引 `pos`，以及上一個看到 `1` 的索引 `last_one`。
- 每次遇到新的 `1`：
  - 如果 `last_one` 存在，候選距離是 `pos - last_one`。
  - 更新答案 `ans = max(ans, pos - last_one)`。
  - 再把 `last_one` 更新為當前 `pos`。
- 掃描結束後回傳 `ans`。

### 為什麼這樣做正確

- 題目只關心「相鄰的 `1`」，也就是在位元序列中連續出現的兩個 `1`。
- 逐位掃描時，當前 `1` 的前一個 `1` 必定就是與它相鄰的 `1`；因此只要記錄最近一次 `1` 的位置即可，不需要額外儲存所有 `1` 的索引。
- 對每一對相鄰 `1` 都計算一次距離並取最大值，得到的就是答案。

### 演算法

1. `ans = 0`，`pos = 0`，`last_one = None`。
2. 當 `n > 0`：
   - 若 `(n & 1) == 1`：
     - 若 `last_one` 有值，更新 `ans`。
     - 設 `last_one = Some(pos)`。
   - `n >>= 1`，`pos += 1`。
3. 回傳 `ans`。

### 時間與空間

- 時間：`O(log n)`，掃描位數約為 `floor(log2(n)) + 1`。
- 空間：`O(1)`，只用常數個變數。

```rust
impl Solution {
    pub fn binary_gap(n: i32) -> i32 {
        let mut x = n as u32;
        let mut pos = 0i32;
        let mut last_one: Option<i32> = None;
        let mut ans = 0i32;

        while x > 0 {
            if (x & 1) == 1 {
                if let Some(prev) = last_one {
                    ans = ans.max(pos - prev);
                }
                last_one = Some(pos);
            }
            x >>= 1;
            pos += 1;
        }

        ans
    }
}
```

## 補充筆記

- `n <= 10^9`，最高只到第 29~30 位，固定字長下實務可視為常數時間。
- 若改成字串做法（先轉二進位字串）也可行，但位移掃描更直接且不需額外配置字串空間。

## Related problems / 相關題目

- [q693](./q693.md)
- [q190](./q190.md)
- [191. Number of 1 Bits](https://leetcode.com/problems/number-of-1-bits/)
