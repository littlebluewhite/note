---
title: q85. Maximal Rectangle / 最大矩形
note_type: knowledge
domain: leetcode
tags: [leetcode, knowledge]
created: 2026-02-03
updated: 2026-02-03
status: active
source: leetcode
difficulty: Hard
complexity_time: O(rows * cols)
complexity_space: O(cols)
review_interval_days: 14
next_review: 2026-02-17
---
# q85. Maximal Rectangle / 最大矩形
[85. Maximal Rectangle](https://leetcode.com/problems/maximal-rectangle/)

Hard

Topics

![premium lock icon](https://leetcode.com/_next/static/images/lock-a6627e2c7fa0ce8bc117c109fb4e567d.svg)Companies

Given a `rows x cols` binary `matrix` filled with `0`'s and `1`'s, find the largest rectangle containing only `1`'s and return its area.
給定 `rows x cols` 的二元矩陣 `matrix`，由 `0` 與 `1` 組成，請找出只包含 `1` 的最大矩形，回傳其面積。

**Example 1:**

![](https://assets.leetcode.com/uploads/2020/09/14/maximal.jpg)

**Input:** matrix = [ ["1","0","1","0","0"],["1","0","1","1","1"],["1","1","1","1","1"],["1","0","0","1","0"] ]
**Output:** 6
**Explanation:** The maximal rectangle is shown in the above picture.
輸入：matrix = [ ["1","0","1","0","0"],["1","0","1","1","1"],["1","1","1","1","1"],["1","0","0","1","0"] ]
輸出：6
說明：最大矩形如圖所示。

**Example 2:**

**Input:** matrix = [ ["0"] ]
**Output:** 0
輸入：matrix = [ ["0"] ]
輸出：0

**Example 3:**

**Input:** matrix = [ ["1"] ]
**Output:** 1
輸入：matrix = [ ["1"] ]
輸出：1

**Constraints:**

- `rows == matrix.length`
- `cols == matrix[i].length`
- `1 <= rows, cols <= 200`
- `matrix[i][j]` is `'0'` or `'1'`.
- `rows == matrix.length`。
- `cols == matrix[i].length`。
- `1 <= rows, cols <= 200`。
- `matrix[i][j]` 為 `'0'` 或 `'1'`。

## 解題筆記與程式碼

通用演算法筆記：[largest_rectangle_histogram](../algorithm/largest_rectangle_histogram.md)
通用資料結構筆記：[stack](../data_structure/stack.md)

### 思路拆解

- 把每一列視為直方圖的底邊：維護 `heights[c]`，連續的 `1` 高度累加，遇到 `0` 歸零。
- 對每列的 `heights` 套用「直方圖最大矩形」的單調遞增堆疊算法，更新答案。
- 每列只需 `O(cols)`，總時間 `O(rows * cols)`。

### 更細的直觀解釋（為什麼可轉直方圖）

- 任意一個只含 `1` 的矩形，都有「最下面那一列」作為底邊。
- 固定某一列當底邊時，往上連續的 `1` 就是柱子的高度，形成直方圖 `heights`。
- 這個直方圖的「最大矩形」就是「底邊在此列」的最大 1 矩形。
- 所有矩形一定會被某一列當作底邊捕捉到，所以逐列掃描可找到全域最大值。

### 小例子（逐列 heights）

以題目矩陣為例：

```
row0: 1 0 1 0 0  -> heights: [1,0,1,0,0]  max=1
row1: 1 0 1 1 1  -> heights: [2,0,2,1,1]  max=3
row2: 1 1 1 1 1  -> heights: [3,1,3,2,2]  max=6  <-- 全域最大
row3: 1 0 0 1 0  -> heights: [4,0,0,3,0]  max=4
```

可以看到答案 `6` 出現在 `row2` 這列對應的直方圖。

### 為什麼單調堆疊可用

- 當某個柱高 `h` 被彈出時，它左右兩側第一個更小的柱子已確定，矩形寬度為 `right - left - 1`。
- 每個索引只會進堆疊、出堆疊各一次，線性時間成立。

### 單調堆疊如何決定寬度（更細節）

- 對每根柱子，以「它作為最小高度」的最大矩形為目標。
- 當遇到更矮的柱子 `cur` 時，堆疊頂端柱子 `top` 的「右界」被固定為 `i - 1`。
- 彈出後的新堆疊頂端是左側第一個更矮柱子，左界是 `left + 1`。
- 因此寬度是 `i - left - 1`，面積是 `height[top] * width`。

### 小追蹤（以 row2 的 heights）

`heights = [3,1,3,2,2]`，加上哨兵 `0`：

```
extended = [3,1,3,2,2,0]
```

- i=1, cur=1 < 3，彈 3：left=-1，width=1，area=3
- i=3, cur=2 < 3，彈 3：left=1，width=1，area=3
- i=5, cur=0，依序彈 2、2、1：
  - 彈 2：left=3，width=1，area=2
  - 彈 2：left=1，width=3，area=6  <-- 最大值
  - 彈 1：left=-1，width=5，area=5

最大值 `6` 正是題目的答案。

### 演算法

1. 初始化 `heights` 長度為 `cols`，全為 0。
2. 逐列掃描：
   - 若 `matrix[r][c] == '1'`，`heights[c] += 1`；否則 `heights[c] = 0`。
   - 用單調遞增堆疊計算當前 `heights` 的最大矩形面積，更新全域答案。
3. 回傳最大面積。

### 時間與空間

- 時間：`O(rows * cols)`。
- 空間：`O(cols)`，高度陣列與堆疊。

```rust
impl Solution {
    pub fn maximal_rectangle(matrix: Vec<Vec<char>>) -> i32 {
        if matrix.is_empty() || matrix[0].is_empty() {
            return 0;
        }
        let rows = matrix.len();
        let cols = matrix[0].len();
        let mut heights = vec![0i32; cols];
        let mut ans = 0i32;

        for r in 0..rows {
            for c in 0..cols {
                if matrix[r][c] == '1' {
                    heights[c] += 1;
                } else {
                    heights[c] = 0;
                }
            }
            ans = ans.max(Self::largest_histogram(&heights));
        }
        ans
    }

    fn largest_histogram(heights: &Vec<i32>) -> i32 {
        let mut stack: Vec<usize> = Vec::new();
        let mut max_area = 0i32;
        let mut extended = heights.clone();
        extended.push(0);

        for i in 0..extended.len() {
            let cur = extended[i];
            while let Some(&top) = stack.last() {
                if extended[top] <= cur {
                    break;
                }
                let h = extended[top];
                stack.pop();
                let width = match stack.last() {
                    Some(&left) => i - left - 1,
                    None => i,
                };
                let area = h * width as i32;
                if area > max_area {
                    max_area = area;
                }
            }
            stack.push(i);
        }
        max_area
    }
}
```
