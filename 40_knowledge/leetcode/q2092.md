---
title: q2092. Find All People With Secret / 找出知曉秘密的所有專家
note_type: knowledge
domain: leetcode
tags: [leetcode, knowledge]
created: 2026-02-03
updated: 2026-02-03
status: active
source: leetcode
complexity_time: O(m α(n))
complexity_space: O(n)
review_interval_days: 14
next_review: 2026-02-17
canonical: leetcode/q2092.md
---
# q2092. Find All People With Secret / 找出知曉秘密的所有專家
[2092. Find All People With Secret](https://leetcode.com/problems/find-all-people-with-secret/)

Hard

Topics

![premium lock icon](https://leetcode.com/_next/static/images/lock-a6627e2c7fa0ce8bc117c109fb4e567d.svg)Companies

Hint

You are given an integer `n` indicating there are `n` people numbered from `0` to `n - 1`. You are also given a **0-indexed** 2D integer array `meetings` where `meetings[i] = [xi, yi, timei]` indicates that person `xi` and person `yi` have a meeting at `timei`. A person may attend **multiple meetings** at the same time. Finally, you are given an integer `firstPerson`.
給定整數 `n` 代表有 `0..n-1` 的人。還給定 **0-indexed** 二維陣列 `meetings`，`meetings[i] = [xi, yi, timei]` 表示 `xi` 與 `yi` 在 `timei` 會面；同一時間一個人可以參加 **多場** 會議。再給一個整數 `firstPerson`。

Person `0` has a **secret** and initially shares the secret with a person `firstPerson` at time `0`. This secret is then shared every time a meeting takes place with a person that has the secret. More formally, for every meeting, if a person `xi` has the secret at `timei`, then they will share the secret with person `yi`, and vice versa.
0 號一開始握有 **祕密**，並在時間 `0` 與 `firstPerson` 分享。之後只要會議中有知道祕密的人，會立即分享給另一方。形式化地說：對於每場會議，若有人 `xi` 在 `timei` 時已知祕密，就會把祕密告訴 `yi`，反之亦然。

The secrets are shared **instantaneously**. That is, a person may receive the secret and share it with people in other meetings within the same time frame.
祕密的傳遞是 **即時** 的：同一時間內，一個人收到祕密後可以在其他同步進行的會議中再分享出去。

Return _a list of all the people that have the secret after all the meetings have taken place._ You may return the answer in **any order**.
請回傳在所有會議結束後，最終知道祕密的所有人清單，順序不限。

**Example 1:**

**Input:** n = 6, meetings = [ [1,2,5],[2,3,8],[1,5,10] ], firstPerson = 1
**Output:** [0,1,2,3,5]
**Explanation:**
At time 0, person 0 shares the secret with person 1.
時間 0：0 號把祕密告訴 1 號。
At time 5, person 1 shares the secret with person 2.
時間 5：1 號把祕密告訴 2 號。
At time 8, person 2 shares the secret with person 3.
時間 8：2 號把祕密告訴 3 號。
At time 10, person 1 shares the secret with person 5.​​​​
時間 10：1 號把祕密告訴 5 號。
Thus, people 0, 1, 2, 3, and 5 know the secret after all the meetings.
所以最終 0、1、2、3、5 號知道祕密。

**Example 2:**

**Input:** n = 4, meetings = [ [3,1,3],[1,2,2],[0,3,3] ], firstPerson = 3
**Output:** [0,1,3]
**Explanation:**
At time 0, person 0 shares the secret with person 3.
時間 0：0 號把祕密告訴 3 號。
At time 2, neither person 1 nor person 2 know the secret.
時間 2：1、2 號都不知道祕密。
At time 3, person 3 shares the secret with person 0 and person 1.
時間 3：3 號把祕密告訴 0、1 號。
Thus, people 0, 1, and 3 know the secret after all the meetings.
所以最終 0、1、3 號知道祕密。

**Example 3:**

**Input:** n = 5, meetings = [ [3,4,2],[1,2,1],[2,3,1] ], firstPerson = 1
**Output:** [0,1,2,3,4]
**Explanation:**
At time 0, person 0 shares the secret with person 1.
時間 0：0 號把祕密告訴 1 號。
At time 1, person 1 shares the secret with person 2, and person 2 shares the secret with person 3.
時間 1：1 號把祕密告訴 2 號，2 號同時把祕密告訴 3 號。
Note that person 2 can share the secret at the same time as receiving it.
注意 2 號在同一時間收到祕密也能立即分享。
At time 2, person 3 shares the secret with person 4.
時間 2：3 號把祕密告訴 4 號。
Thus, people 0, 1, 2, 3, and 4 know the secret after all the meetings.
所以最終 0、1、2、3、4 號知道祕密。

**Constraints:**

- `2 <= n <= 105`
- `1 <= meetings.length <= 105`
- `meetings[i].length == 3`
- `0 <= xi, yi <= n - 1`
- `xi != yi`
- `1 <= timei <= 105`
- `1 <= firstPerson <= n - 1`
- `2 <= n <= 10^5`。
- `1 <= meetings.length <= 10^5`。
- `meetings[i].length == 3`。
- `0 <= xi, yi <= n - 1`。
- `xi != yi`。
- `1 <= timei <= 10^5`。
- `1 <= firstPerson <= n - 1`。

## 解題筆記與程式碼

通用演算法筆記：[event_sorting_sweep](../algorithm/event_sorting_sweep.md)
資料結構筆記：[union_find_dsu](../data_structure/union_find_dsu.md)
資料結構筆記：[hash_map_set](../data_structure/hash_map_set.md)

### 思路拆解

- 同一時間的多場會議被視為「同步」：只要批次內有人知道祕密，就能在該批次內傳遍所有相連的人；但過了這個時間點，沒有接到祕密的連通塊應該被切斷，避免祕密被未來的會議錯誤傳遞。
- 用並查集（DSU）處理連通性，初始先把 0 與 `firstPerson` 連在一起（時間 0 分享）。
- 依會議時間排序，逐一處理「相同時間」的會議批次：先把該批次的所有 `(xi, yi)` 都 union 起來；批次處理完之後，只有與節點 0 連通的集合可留下，其他參與者都要 reset 回各自獨立（因為當下沒拿到祕密，連結不應留到下一個時間）。
- 批次 reset 只需針對本批次參與過的節點，不動其他人即可。

### 為什麼要「同時間批次 + DSU reset」

- 祕密可在同一時間內即時傳遞，因此必須在檢查誰拿到祕密前，先把該時間的邊全部 union。
- 若不把「當批沒有接到祕密」的節點斷開，這些節點的連結會錯誤地延續到未來時間，導致祕密外洩。

### 演算法

1. 將會議按時間升冪排序，並將 `0` 與 `firstPerson` union，代表時間 0 的初始分享。
2. 迭代每個時間批次：
   - 收集該批次的所有邊 `(x, y)` 以及涉入的節點集合 `V`。
   - 將批次內的所有邊 union，完成同步傳遞。
   - 取得 `root0 = find(0)`，對 `V` 中節點逐一檢查；若與 `root0` 不連通，執行 reset（parent 指回自己，size=1）。
3. 全部批次處理完後，蒐集所有與節點 0 連通的節點即為答案。

### 時間與空間

- 時間：`O(m α(n))`，`m` 為會議數，並查集近乎常數時間。
- 空間：`O(n)`，儲存 parent/size 以及批次參與者集合。

```rust
use std::collections::HashSet;

struct DSU {
    parent: Vec<usize>,
    size: Vec<usize>,
}

impl DSU {
    fn new(n: usize) -> Self {
        DSU {
            parent: (0..n).collect(),
            size: vec![1; n],
        }
    }

    fn find(&mut self, x: usize) -> usize {
        if self.parent[x] != x {
            let root = self.find(self.parent[x]);
            self.parent[x] = root;
        }
        self.parent[x]
    }

    fn union(&mut self, a: usize, b: usize) {
        let mut ra = self.find(a);
        let mut rb = self.find(b);
        if ra == rb {
            return;
        }
        if self.size[ra] < self.size[rb] {
            std::mem::swap(&mut ra, &mut rb);
        }
        self.parent[rb] = ra;
        self.size[ra] += self.size[rb];
    }

    fn reset(&mut self, x: usize) {
        self.parent[x] = x;
        self.size[x] = 1;
    }
}

impl Solution {
    pub fn find_all_people(n: i32, mut meetings: Vec<Vec<i32>>, first_person: i32) -> Vec<i32> {
        let n = n as usize;
        meetings.sort_by_key(|m| m[2]);

        let mut dsu = DSU::new(n);
        dsu.union(0, first_person as usize);

        let mut i = 0usize;
        while i < meetings.len() {
            let time = meetings[i][2];
            let mut batch: Vec<(usize, usize)> = Vec::new();
            let mut involved: HashSet<usize> = HashSet::new();
            while i < meetings.len() && meetings[i][2] == time {
                let x = meetings[i][0] as usize;
                let y = meetings[i][1] as usize;
                batch.push((x, y));
                involved.insert(x);
                involved.insert(y);
                i += 1;
            }

            for &(x, y) in &batch {
                dsu.union(x, y);
            }

            let root0 = dsu.find(0);
            for &p in involved.iter() {
                if dsu.find(p) != root0 {
                    dsu.reset(p);
                }
            }
        }

        let root0 = dsu.find(0);
        let mut ans = Vec::new();
        for person in 0..n {
            if dsu.find(person) == root0 {
                ans.push(person as i32);
            }
        }
        ans
    }
}
```


## 補充筆記：`O(n)`，並查集與批次涉入節點集合。

## 實作細節

- reset 只對「該批有參與的節點」執行，避免破壞其他時間已建立的祕密連結。
- `HashSet` 去重收集涉入節點，確保 reset 的時間與空間開銷合理。
- 由於祕密在同一時間即時傳遞，必須先 union 本批全部邊，再判斷哪些分量真正拿到祕密。***
