---
title: q109. Convert Sorted List to Binary Search Tree / 將有序鏈結串列轉為二元搜尋樹
note_type: knowledge
domain: leetcode
tags: [leetcode, knowledge]
created: 2026-02-14
updated: 2026-02-14
status: active
source: leetcode
difficulty: Medium
complexity_time: O(n)
complexity_space: O(log n)
review_interval_days: 14
next_review: 2026-02-28
---

# q109. Convert Sorted List to Binary Search Tree / 將有序鏈結串列轉為二元搜尋樹
[109. Convert Sorted List to Binary Search Tree](https://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/)

Medium

## 解題筆記與程式碼

通用演算法筆記：[divide_conquer_build_balanced_bst](../algorithm/divide_conquer_build_balanced_bst.md)
資料結構筆記：[binary_search_tree](../data_structure/binary_search_tree.md)
資料結構筆記：[doubly_linked_list](../data_structure/doubly_linked_list.md)

### 思路拆解

- 常見解法 1：先把 linked list 轉陣列，再套 `q108` 分治模板。
- 常見解法 2：快慢指標找中點直接分割（實作較繁瑣）。

### Rust 參考（轉陣列）

```rust
impl Solution {
    pub fn sorted_list_to_bst(head: Option<Box<ListNode>>) -> Option<Rc<RefCell<TreeNode>>> {
        let mut vals = Vec::new();
        let mut cur = head.as_ref();
        while let Some(node) = cur {
            vals.push(node.val);
            cur = node.next.as_ref();
        }
        fn build(nums: &[i32]) -> Option<Rc<RefCell<TreeNode>>> {
            if nums.is_empty() { return None; }
            let mid = nums.len() / 2;
            let root = Rc::new(RefCell::new(TreeNode::new(nums[mid])));
            root.borrow_mut().left = build(&nums[..mid]);
            root.borrow_mut().right = build(&nums[mid + 1..]);
            Some(root)
        }
        build(&vals)
    }
}
```

## Related problems

- [q108](../leetcode/q108.md)
- [q1382](../leetcode/q1382.md)
