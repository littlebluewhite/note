---
title: q3650. Minimum Cost Path with Edge Reversals / 帶邊反轉的最小成本路徑
note_type: knowledge
domain: leetcode
tags: [leetcode, knowledge]
created: 2026-02-03
updated: 2026-02-03
status: active
source: leetcode
difficulty: Medium
complexity_time: O((n + m) log n)
complexity_space: O(n + m)
review_interval_days: 14
next_review: 2026-02-17
---
# q3650. Minimum Cost Path with Edge Reversals / 帶邊反轉的最小成本路徑
[3650. Minimum Cost Path with Edge Reversals](https://leetcode.com/problems/minimum-cost-path-with-edge-reversals/)

Medium

Topics

![premium lock icon](https://leetcode.com/_next/static/images/lock-a6627e2c7fa0ce8bc117c109fb4e567d.svg)Companies

Hint

You are given a directed, weighted graph with `n` nodes labeled from 0 to `n - 1`, and an array `edges` where `edges[i] = [ui, vi, wi]` represents a directed edge from node `ui` to node `vi` with cost `wi`.
給定一張有向加權圖，節點編號 `0..n-1`，陣列 `edges` 中 `edges[i] = [ui, vi, wi]` 代表一條從 `ui` 指向 `vi`、成本為 `wi` 的有向邊。

Each node `ui` has a switch that can be used **at most once**: when you arrive at `ui` and have not yet used its switch, you may activate it on one of its incoming edges `vi → ui`, reverse that edge to `ui → vi` and **immediately** traverse it.
每個節點 `ui` 有一個**最多只能用一次**的開關：當你抵達 `ui` 且尚未使用過它的開關時，可以對一條入邊 `vi → ui` 啟動反轉，讓該邊變為 `ui → vi`，並**立即**走過去。

The reversal is only valid for that single move, and using a reversed edge costs `2 * wi`.
反轉只對這一次移動有效，使用反轉邊的成本為 `2 * wi`。

Return the **minimum** total cost to travel from node 0 to node `n - 1`. If it is not possible, return -1.
請回傳從節點 0 到節點 `n - 1` 的**最小**總成本；若無法到達則回傳 -1。

**Example 1:**

**Input:** n = 4, edges = [ [0,1,3],[3,1,1],[2,3,4],[0,2,2] ]
**Output:** 5

**Explanation:**

**![](https://assets.leetcode.com/uploads/2025/05/07/e1drawio.png)**

- Use the path `0 → 1` (cost 3).
- 使用路徑 `0 → 1`（成本 3）。
- At node 1 reverse the original edge `3 → 1` into `1 → 3` and traverse it at cost `2 * 1 = 2`.
- 在節點 1 反轉原邊 `3 → 1` 成 `1 → 3`，並以成本 `2 * 1 = 2` 走過去。
- Total cost is `3 + 2 = 5`.
- 總成本為 `3 + 2 = 5`。

**Example 2:**

**Input:** n = 4, edges = [ [0,2,1],[2,1,1],[1,3,1],[2,3,3] ]
**Output:** 3

**Explanation:**

- No reversal is needed. Take the path `0 → 2` (cost 1), then `2 → 1` (cost 1), then `1 → 3` (cost 1).
- 不需要反轉。走 `0 → 2`（成本 1），再 `2 → 1`（成本 1），最後 `1 → 3`（成本 1）。
- Total cost is `1 + 1 + 1 = 3`.
- 總成本為 `1 + 1 + 1 = 3`。

**Constraints:**

- `2 <= n <= 5 * 10^4`
- `1 <= edges.length <= 10^5`
- `edges[i] = [ui, vi, wi]`
- `0 <= ui, vi <= n - 1`
- `1 <= wi <= 1000`
- `2 <= n <= 5 * 10^4`
- `1 <= edges.length <= 10^5`
- `edges[i] = [ui, vi, wi]`
- `0 <= ui, vi <= n - 1`
- `1 <= wi <= 1000`

## 解題筆記與程式碼

通用演算法筆記：[dijkstra_shortest_path](../algorithm/dijkstra_shortest_path.md)
資料結構筆記：[adjacency_list](../data_structure/adjacency_list.md)
資料結構筆記：[priority_queue_binary_heap](../data_structure/priority_queue_binary_heap.md)

### 思路拆解

- 反轉邊的規則等價於：對每條原邊 `u → v (w)`，在圖中再加入一條「可反轉」邊 `v → u`，成本為 `2w`。
- 因為所有邊權皆為正，最短路徑一定可以視為**不重複節點的簡單路徑**，因此在同一節點只會離開一次，天然符合「開關最多用一次」的限制。
- 問題轉換成「在擴充後的有向加權圖上找最短路徑」，可直接用 Dijkstra。

### 為什麼可以把反轉邊視為一般邊

- 任何包含迴圈的路徑都可以移除該迴圈而變得更便宜（權重皆為正）。
- 因此最短路徑不會重訪節點，開關在該節點只會被使用一次或不使用。
- 這使得「從節點 `v` 可選擇一條入邊反轉並立刻走出」等價於「在 `v` 多了一批可選的出邊」，不需額外狀態。

### 演算法

1. 建立鄰接表。
   - 原邊 `u → v` 成本 `w`：加入 `(u, v, w)`。
   - 反轉邊 `v → u` 成本 `2w`：加入 `(v, u, 2w)`。
2. 在此擴充圖上以 Dijkstra 求 0 到 `n-1` 的最短距離。
3. 若最短距離為無限大，回傳 `-1`；否則回傳距離。

### 時間與空間

- 時間：`O((n + m) log n)`，`m` 為邊數。
- 空間：`O(n + m)`，儲存鄰接表與距離陣列。

```rust
use std::cmp::Reverse;
use std::collections::BinaryHeap;

impl Solution {
    pub fn min_cost(n: i32, edges: Vec<Vec<i32>>) -> i64 {
        let n = n as usize;
        let mut adj: Vec<Vec<(usize, i64)>> = vec![Vec::new(); n];
        for e in edges.iter() {
            let u = e[0] as usize;
            let v = e[1] as usize;
            let w = e[2] as i64;
            adj[u].push((v, w));
            adj[v].push((u, 2 * w));
        }

        let inf = i64::MAX / 4;
        let mut dist = vec![inf; n];
        dist[0] = 0;
        let mut heap = BinaryHeap::new();
        heap.push((Reverse(0_i64), 0_usize));

        while let Some((Reverse(d), u)) = heap.pop() {
            if d != dist[u] {
                continue;
            }
            if u == n - 1 {
                break;
            }
            for &(v, w) in &adj[u] {
                let nd = d + w;
                if nd < dist[v] {
                    dist[v] = nd;
                    heap.push((Reverse(nd), v));
                }
            }
        }

        if dist[n - 1] >= inf {
            -1
        } else {
            dist[n - 1]
        }
    }
}
```
