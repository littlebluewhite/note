---
title: q1382. Balance a Binary Search Tree / 平衡二元搜尋樹
note_type: knowledge
domain: leetcode
tags: [leetcode, knowledge]
created: 2026-02-03
updated: 2026-02-09
status: active
source: leetcode
complexity_time: O(n)
complexity_space: O(n)
review_interval_days: 14
next_review: 2026-02-23
---
# q1382. Balance a Binary Search Tree / 平衡二元搜尋樹
[1382. Balance a Binary Search Tree](https://leetcode.com/problems/balance-a-binary-search-tree/)

Medium

Topics

![premium lock icon](https://leetcode.com/_next/static/images/lock-a6627e2c7fa0ce8bc117c109fb4e567d.svg)Companies

Given the `root` of a binary search tree, return a balanced binary search tree with the same node values. If there is more than one answer, return any of them.
給定一棵二元搜尋樹的 `root`，請回傳一棵包含相同節點值且平衡的二元搜尋樹。若答案不只一種，回傳任一種即可。

A binary search tree is balanced if the depth of the two subtrees of every node never differs by more than `1`.
若二元搜尋樹中每個節點的左右子樹深度差都不超過 `1`，則此樹為平衡樹。

**Example 1:****  
![](https://assets.leetcode.com/uploads/2021/08/10/balance1-tree.jpg)

**Input:** `root = [1,null,2,null,3,null,4,null,null]`
**Output:** `[2,1,3,null,null,null,4]`
**Explanation:** This is not the only correct answer, `[3,1,4,null,2]` is also correct.
**說明：**這不是唯一正解，`[3,1,4,null,2]` 也同樣正確。

**Example 2:**  
![](https://assets.leetcode.com/uploads/2021/08/10/balanced2-tree.jpg)

**Input:** `root = [2,1,3]`
**Output:** `[2,1,3]`
**Explanation:** The original tree is already balanced.
**說明：**原本的樹已經是平衡樹。

**Constraints:**

- The number of nodes in the tree is in the range `[1, 10^4]`.
- `1 <= Node.val <= 10^5`
- 樹中節點數量介於 `[1, 10^4]`。
- `1 <= Node.val <= 10^5`。

## 解題筆記與程式碼

通用演算法筆記：[bst_inorder_sorted_sequence](../algorithm/bst_inorder_sorted_sequence.md)
通用演算法筆記：[divide_conquer_build_balanced_bst](../algorithm/divide_conquer_build_balanced_bst.md)
資料結構筆記：[binary_search_tree](../data_structure/binary_search_tree.md)
資料結構筆記：[binary_tree](../data_structure/binary_tree.md)
資料結構筆記：[array](../data_structure/array.md)

### 思路拆解

- BST 的中序遍歷會得到遞增序列，先把所有節點值收集成排序陣列。
- 要讓樹平衡，最自然的做法是每次選中點當根節點，左右半段分別遞迴建立左、右子樹。
- 題目只要求「值相同且平衡」，不要求沿用原本節點，因此可直接重建新樹。

### 演算法

1. 對原 BST 做中序遍歷，取得遞增陣列 `vals`。
2. 定義 `build(vals)`：
   - 若 `vals` 為空，回傳 `None`。
   - 取 `mid = vals.len() / 2` 作為根值。
   - 遞迴用 `vals[..mid]` 建左子樹、`vals[mid+1..]` 建右子樹。
3. 回傳 `build(&vals)`。

### 時間與空間

- 時間：`O(n)`，每個節點在中序遍歷與重建階段各處理一次。
- 空間：`O(n)`，`vals` 需要 `O(n)`，遞迴額外堆疊為 `O(h)`（重建時約 `O(log n)`）。

```rust
// Definition for a binary tree node.
// #[derive(Debug, PartialEq, Eq)]
// pub struct TreeNode {
//   pub val: i32,
//   pub left: Option<Rc<RefCell<TreeNode>>>,
//   pub right: Option<Rc<RefCell<TreeNode>>>,
// }
//
// impl TreeNode {
//   #[inline]
//   pub fn new(val: i32) -> Self {
//     TreeNode {
//       val,
//       left: None,
//       right: None
//     }
//   }
// }

use std::cell::RefCell;
use std::rc::Rc;

impl Solution {
    pub fn balance_bst(root: Option<Rc<RefCell<TreeNode>>>) -> Option<Rc<RefCell<TreeNode>>> {
        fn inorder(node: &Option<Rc<RefCell<TreeNode>>>, vals: &mut Vec<i32>) {
            if let Some(rc) = node {
                let (left, val, right) = {
                    let n = rc.borrow();
                    (n.left.clone(), n.val, n.right.clone())
                };
                inorder(&left, vals);
                vals.push(val);
                inorder(&right, vals);
            }
        }

        fn build(vals: &[i32]) -> Option<Rc<RefCell<TreeNode>>> {
            if vals.is_empty() {
                return None;
            }

            let mid = vals.len() / 2;
            let root = Rc::new(RefCell::new(TreeNode::new(vals[mid])));
            let left = build(&vals[..mid]);
            let right = build(&vals[mid + 1..]);

            {
                let mut n = root.borrow_mut();
                n.left = left;
                n.right = right;
            }

            Some(root)
        }

        let mut vals = Vec::new();
        inorder(&root, &mut vals);
        build(&vals)
    }
}
```

## 補充筆記

- 同一組值可能對應多棵合法平衡 BST，所以答案不唯一。
- 此題可視為「BST 中序排序化 + 由排序序列建平衡 BST」兩個通用模板的組合。

## Related problems

- [q108](../leetcode/q108.md)
- [q109](../leetcode/q109.md)
- [q1382](../leetcode/q1382.md)
