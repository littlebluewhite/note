---
title: q98. Validate Binary Search Tree / 驗證二元搜尋樹
note_type: knowledge
domain: leetcode
tags: [leetcode, knowledge]
created: 2026-02-14
updated: 2026-02-14
status: active
source: leetcode
difficulty: Medium
complexity_time: O(n)
complexity_space: O(h)
review_interval_days: 14
next_review: 2026-02-28
---

# q98. Validate Binary Search Tree / 驗證二元搜尋樹
[98. Validate Binary Search Tree](https://leetcode.com/problems/validate-binary-search-tree/)

Medium

## 解題筆記與程式碼

通用演算法筆記：[bst_inorder_sorted_sequence](../algorithm/bst_inorder_sorted_sequence.md)
資料結構筆記：[binary_search_tree](../data_structure/binary_search_tree.md)
資料結構筆記：[binary_tree](../data_structure/binary_tree.md)

### 思路拆解

- 驗證 BST 最穩定方法之一：中序遍歷結果必須嚴格遞增。
- 另一路徑是 DFS 帶上下界 `(-inf, +inf)`。

### Rust 參考

```rust
impl Solution {
    pub fn is_valid_bst(root: Option<Rc<RefCell<TreeNode>>>) -> bool {
        fn dfs(node: &Option<Rc<RefCell<TreeNode>>>, prev: &mut Option<i64>) -> bool {
            if let Some(rc) = node {
                let (left, val, right) = {
                    let n = rc.borrow();
                    (n.left.clone(), n.val as i64, n.right.clone())
                };
                if !dfs(&left, prev) { return false; }
                if prev.is_some() && prev.unwrap() >= val { return false; }
                *prev = Some(val);
                dfs(&right, prev)
            } else {
                true
            }
        }
        dfs(&root, &mut None)
    }
}
```

## Related problems

- [q94](../leetcode/q94.md)
- [q230](../leetcode/q230.md)
- [q108](../leetcode/q108.md)
