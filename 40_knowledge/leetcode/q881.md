---
title: q881. Boats to Save People / 救生艇載人
note_type: knowledge
domain: leetcode
tags: [leetcode, knowledge]
created: 2026-02-03
updated: 2026-02-08
status: active
source: leetcode
complexity_time: O(n log n)
complexity_space: O(1)
review_interval_days: 14
next_review: 2026-02-22
canonical: leetcode/q881.md
---
# q881. Boats to Save People / 救生艇載人

[881. Boats to Save People](https://leetcode.com/problems/boats-to-save-people/)

Medium

You are given an array `people` where `people[i]` is the weight of the `ith` person, and an **infinite number of boats** where each boat can carry a maximum weight of `limit`. Each boat carries at most **two people** at the same time, provided the sum of the weight of those people is at most `limit`.
給定一個陣列 `people`，其中 `people[i]` 表示第 `i` 個人的體重，以及**無限數量的船隻**，每艘船的最大載重為 `limit`。每艘船**最多載兩人**，且這兩人的體重總和不可超過 `limit`。

Return _the minimum number of boats to carry every given person_.
回傳載完所有人所需的**最少船隻數量**。

**Example 1:**

**Input:** people = [1,2], limit = 3
**Output:** 1
**Explanation:** 1 boat (1, 2)
**輸入：** people = [1,2], limit = 3
**輸出：** 1
**說明：** 1 艘船 (1, 2)

**Example 2:**

**Input:** people = [3,2,2,1], limit = 3
**Output:** 3
**Explanation:** 3 boats (1, 2), (2) and (3)
**輸入：** people = [3,2,2,1], limit = 3
**輸出：** 3
**說明：** 3 艘船 (1, 2)、(2) 和 (3)

**Example 3:**

**Input:** people = [3,5,3,4], limit = 5
**Output:** 4
**Explanation:** 4 boats (3), (3), (4), (5)
**輸入：** people = [3,5,3,4], limit = 5
**輸出：** 4
**說明：** 4 艘船 (3)、(3)、(4)、(5)

**Constraints:**

- `1 <= people.length <= 5 * 10^4`
- `1 <= people[i] <= limit <= 3 * 10^4`

## 解題筆記與程式碼

通用演算法筆記：[greedy_pairing_extremes](../algorithm/greedy_pairing_extremes.md), [two_pointers](../algorithm/two_pointers.md)
資料結構筆記：[sorted_array](../data_structure/sorted_array.md)

### 思路拆解

- 每艘船最多載兩人，目標是最小化船隻數量。
- 貪心策略：排序後用雙指標，最輕的人與最重的人配對。
  - 若兩人體重和不超過 `limit`，則共乘一艘，兩指標同時移動。
  - 否則最重的人單獨坐一艘，右指標左移。
- 此策略保證最重的人盡可能與最輕的人配對，若無法配對則單獨一艘。

### 演算法

1. 將 `people` 陣列排序。
2. 初始化左指標 `l = 0`，右指標 `r = n - 1`，船數 `boats = 0`。
3. 當 `l <= r` 時：
   - 若 `people[l] + people[r] <= limit`，則 `l++`（最輕與最重共乘）。
   - 否則只有最重的人上船。
   - `r--`，`boats++`。
4. 回傳 `boats`。

### 時間與空間

- 時間：`O(n log n)`，排序為主要成本。
- 空間：`O(1)`，不計排序所需空間。

```rust
impl Solution {
    pub fn num_rescue_boats(mut people: Vec<i32>, limit: i32) -> i32 {
        people.sort_unstable();
        let mut l = 0;
        let mut r = people.len() - 1;
        let mut boats = 0;

        while l <= r {
            // Try to pair lightest with heaviest
            if people[l] + people[r] <= limit {
                l += 1; // Both can fit
            }
            r -= 1; // Heaviest person takes a boat
            boats += 1;

            if l > r {
                break;
            }
        }

        boats
    }
}
```

## 補充筆記

### 核心觀察

- 排序後的貪心配對是最優策略：
  - 最重的人若無法與最輕的人配對，則無法與任何人配對，必須單獨一艘。
  - 最輕的人優先與最重的人配對，若配對成功則兩人都完成救援。
- 時間複雜度由排序決定，雙指標遍歷為線性。

### 注意事項

- 題目保證每個人的體重不超過 `limit`，因此每人至少能單獨坐一艘船。
- 每艘船最多載兩人，不可能三人或更多同船。
- 雙指標需注意邊界條件，當 `l == r` 時最後一人單獨一艘。

Sources:
- [LeetCode 881](https://leetcode.com/problems/boats-to-save-people/)
- [GitHub doocs/leetcode solution](https://github.com/doocs/leetcode/blob/main/solution/0800-0899/0881.Boats%20to%20Save%20People/README_EN.md)
- [algo.monster explanation](https://algo.monster/liteproblems/881)
