---
title: q3713. Longest Balanced Substring I / 最長平衡子字串 I
note_type: knowledge
domain: leetcode
tags: [leetcode, knowledge]
created: 2026-02-12
updated: 2026-02-12
status: active
source: leetcode
difficulty: Medium
complexity_time: O(n^2)
complexity_space: O(26)
review_interval_days: 14
next_review: 2026-02-26
---
# q3713. Longest Balanced Substring I / 最長平衡子字串 I
[3713. Longest Balanced Substring I](https://leetcode.com/problems/longest-balanced-substring-i/?envType=daily-question&envId=2026-02-12)

Medium

Topics

Companies

Hint

You are given a string `s` consisting of lowercase English letters.
給定一個只包含小寫英文字母的字串 `s`。

A **substring** of `s` is called **balanced** if all **distinct** characters in the **substring** appear the **same** number of times.
若 `s` 的某個 **子字串** 中，所有 **不同字元** 的出現次數都相同，則這個子字串稱為 **balanced**（平衡）。

Return the **length** of the **longest balanced substring** of `s`.
請回傳 `s` 中最長平衡子字串的 **長度**。

### Example 1:

**Input:** `s = "abbac"`
**Output:** `4`
**Explanation:**
The longest balanced substring is `"abba"` because both distinct characters `'a'` and `'b'` each appear exactly 2 times.
最長平衡子字串是 `"abba"`，因為不同字元 `'a'` 與 `'b'` 都各出現 2 次。

### Example 2:

**Input:** `s = "zzabccy"`
**Output:** `4`
**Explanation:**
The longest balanced substring is `"zabc"` because the distinct characters `'z'`, `'a'`, `'b'`, and `'c'` each appear exactly 1 time.
最長平衡子字串是 `"zabc"`，因為不同字元 `'z'`、`'a'`、`'b'`、`'c'` 都各出現 1 次。

### Example 3:

**Input:** `s = "aba"`
**Output:** `2`
**Explanation:**
One of the longest balanced substrings is `"ab"` because both distinct characters `'a'` and `'b'` each appear exactly 1 time. Another longest balanced substring is `"ba"`.
其中一個最長平衡子字串是 `"ab"`，因為不同字元 `'a'` 與 `'b'` 都各出現 1 次；另一個同長度答案是 `"ba"`。

### Constraints:

- `1 <= s.length <= 1000`
- `s.length` 範圍為 `1..=1000`。
- `s` consists of lowercase English letters.
- `s` 只包含小寫英文字母。

## 解題筆記與程式碼

通用演算法筆記：[substring_enumeration_uniform_frequency_check](../algorithm/substring_enumeration_uniform_frequency_check.md)
資料結構筆記：[fixed_alphabet_frequency_array](../data_structure/fixed_alphabet_frequency_array.md)

### 思路拆解

- `n <= 1000`，可接受 `O(n^2)` 枚舉所有子字串。
- 固定左端點 `l`，右端點 `r` 逐步往右擴張，維護 3 個量：
  - `freq[c]`：字元 `c` 在目前 `s[l..r]` 的出現次數。
  - `distinct`：目前有幾種不同字元（`freq[c] > 0` 的個數）。
  - `max_freq`：目前最高出現次數。
- 設目前子字串長度為 `len`。若平衡，所有出現過的字元次數都應該一樣，等於某個 `k`，因此 `len = distinct * k`。
- 由於 `max_freq` 是所有字元次數的最大值，總有 `len <= distinct * max_freq`。只有在每個出現過的字元都等於 `max_freq` 時，才會有 `len == distinct * max_freq`。
- 所以可以用條件 `len == distinct * max_freq` 直接判斷是否平衡，不用每次掃一遍 26 個字元比較次數。

### 演算法

1. 令答案 `ans = 0`。
2. 枚舉左端點 `l`：
   - 重設 `freq[26] = 0`、`distinct = 0`、`max_freq = 0`。
   - 枚舉右端點 `r` 從 `l` 到 `n-1`：
     - 將 `s[r]` 對應的頻率加一。
     - 若該字元頻率從 0 變 1，`distinct += 1`。
     - 更新 `max_freq = max(max_freq, freq[s[r]])`。
     - `len = r - l + 1`；若 `len == distinct * max_freq`，更新 `ans`。
3. 回傳 `ans`。

### 時間與空間

- 時間：`O(n^2)`。
- 空間：`O(26)`（固定字母表）。

```rust
impl Solution {
    pub fn longest_balanced(s: String) -> i32 {
        let bytes = s.as_bytes();
        let n = bytes.len();
        let mut ans = 0i32;

        for l in 0..n {
            let mut freq = [0usize; 26];
            let mut distinct = 0usize;
            let mut max_freq = 0usize;

            for r in l..n {
                let idx = (bytes[r] - b'a') as usize;
                freq[idx] += 1;
                if freq[idx] == 1 {
                    distinct += 1;
                }
                if freq[idx] > max_freq {
                    max_freq = freq[idx];
                }

                let len = r - l + 1;
                if len == distinct * max_freq {
                    ans = ans.max(len as i32);
                }
            }
        }

        ans
    }
}
```

## 補充筆記

- 這題是固定字母表版本（26 種），因此頻率陣列比 `HashMap` 更快、更省常數。
- 若字元集合很大（例如完整 Unicode），則可改成雜湊表，但時間常數會提高。
