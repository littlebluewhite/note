---
title: q1970. Last Day Where You Can Still Cross / 你能穿越矩陣的最後一天
note_type: knowledge
domain: leetcode
tags: [leetcode, knowledge]
created: 2026-02-03
updated: 2026-02-03
status: active
source: leetcode
complexity_time: O((row * col) * log(row * col))
complexity_space: O(row * col)
review_interval_days: 14
next_review: 2026-02-17
---
# q1970. Last Day Where You Can Still Cross / 你能穿越矩陣的最後一天
[1970. Last Day Where You Can Still Cross](https://leetcode.com/problems/last-day-where-you-can-still-cross/)

Hard

Topics

![premium lock icon](https://leetcode.com/_next/static/images/lock-a6627e2c7fa0ce8bc117c109fb4e567d.svg)Companies

Hint

There is a **1-based** binary matrix where `0` represents land and `1` represents water. You are given integers `row` and `col` representing the number of rows and columns in the matrix, respectively.
有一個 **1-based** 的二元矩陣，`0` 代表陸地、`1` 代表水。給定整數 `row` 與 `col` 分別表示矩陣的列與欄。

Initially on day `0`, the **entire** matrix is **land**. However, each day a new cell becomes flooded with **water**. You are given a **1-based** 2D array `cells`, where `cells[i] = [ri, ci]` represents that on the `ith` day, the cell on the `rith` row and `cith` column (**1-based** coordinates) will be covered with **water** (i.e., changed to `1`).
在第 `0` 天，**整個** 矩陣都是 **陸地**。之後每天會有一格變成 **水**。給定 **1-based** 的二維陣列 `cells`，其中 `cells[i] = [ri, ci]` 表示在第 `i` 天，座標 `(ri, ci)`（**1-based**）的格子會被淹成 **水**（變為 `1`）。

You want to find the **last** day that it is possible to walk from the **top** to the **bottom** by only walking on land cells. You can start from **any** cell in the top row and end at **any** cell in the bottom row. You can only travel in the **four** cardinal directions (left, right, up, and down).
你要找出 **最後** 一天，仍可只走陸地從 **最上排** 走到 **最下排**。起點可在最上排任意格，終點可在最下排任意格。你只能走 **四方向**（上、下、左、右）。

Return the **last** day where it is possible to walk from the **top** to the **bottom** by only walking on land cells.
回傳可以只走陸地從 **最上排** 到 **最下排** 的 **最後一天**。

**Example 1:**

![](https://assets.leetcode.com/uploads/2021/07/27/1.png)

**Input:** row = 2, col = 2, cells = [ [1,1],[2,1],[1,2],[2,2] ]
**Output:** 2
**Explanation:** The above image depicts how the matrix changes each day starting from day 0.
The last day where it is possible to cross from top to bottom is on day 2.
**輸入：** row = 2, col = 2, cells = [ [1,1],[2,1],[1,2],[2,2] ]
**輸出：** 2
**說明：** 圖中展示矩陣從第 0 天開始的變化。
最後還能從上到下穿越的日子是第 2 天。

**Example 2:**

![](https://assets.leetcode.com/uploads/2021/07/27/2.png)

**Input:** row = 2, col = 2, cells = [ [1,1],[1,2],[2,1],[2,2] ]
**Output:** 1
**Explanation:** The above image depicts how the matrix changes each day starting from day 0.
The last day where it is possible to cross from top to bottom is on day 1.
**輸入：** row = 2, col = 2, cells = [ [1,1],[1,2],[2,1],[2,2] ]
**輸出：** 1
**說明：** 圖中展示矩陣從第 0 天開始的變化。
最後還能從上到下穿越的日子是第 1 天。

**Example 3:**

![](https://assets.leetcode.com/uploads/2021/07/27/3.png)

**Input:** row = 3, col = 3, cells = [ [1,2],[2,1],[3,3],[2,2],[1,1],[1,3],[2,3],[3,2],[3,1] ]
**Output:** 3
**Explanation:** The above image depicts how the matrix changes each day starting from day 0.
The last day where it is possible to cross from top to bottom is on day 3.
**輸入：** row = 3, col = 3, cells = [ [1,2],[2,1],[3,3],[2,2],[1,1],[1,3],[2,3],[3,2],[3,1] ]
**輸出：** 3
**說明：** 圖中展示矩陣從第 0 天開始的變化。
最後還能從上到下穿越的日子是第 3 天。

**Constraints:**

- `2 <= row, col <= 2 * 10^4`
- `4 <= row * col <= 2 * 10^4`
- `cells.length == row * col`
- `1 <= ri <= row`
- `1 <= ci <= col`
- All the values of `cells` are **unique**
- `2 <= row, col <= 2 * 10^4`。
- `4 <= row * col <= 2 * 10^4`。
- `cells.length == row * col`。
- `1 <= ri <= row`。
- `1 <= ci <= col`。
- `cells` 中所有值都 **唯一**。

## 解題筆記與程式碼

通用演算法筆記：[binary_search_lower_bound](../algorithm/binary_search_lower_bound.md)
通用演算法筆記：[graph_bfs](../algorithm/graph_bfs.md)
資料結構筆記：[deque_vecdeque](../data_structure/deque_vecdeque.md)

### 思路拆解

- 可行性具有單調性：如果第 `d` 天可以走過去，那麼第 `d-1` 天也一定可以；反之如果第 `d` 天不行，第 `d+1` 天也不行。
- 用二分搜尋找「最後一個可行的日子」。
- 對於某一天 `d`，先把前 `d` 天的淹水格子標記為水，再用 BFS 從最上排所有陸地格出發，看能否到達最下排。

### 為什麼可用二分搜尋

- 天數增加只會讓陸地變少，可行性是單調遞減，因此可用二分搜尋找最後一個 `true`。

### 演算法

1. 二分搜尋 `day` 於 `[0, cells.len()]`。
2. `can_cross(day)`：
   - 建立 `water` 陣列，將前 `day` 個 `cells` 標記為水。
   - 從所有最上排的陸地格做 BFS，若抵達最下排則回傳 `true`。
3. 用上取中位數避免無窮迴圈，最後回傳 `l`。

### 時間與空間

- 時間：`O((row * col) * log(row * col))`，每次檢查是 BFS 線性掃描。
- 空間：`O(row * col)`，存 `water`、`visited` 與佇列。

```rust
use std::collections::VecDeque;

impl Solution {
    fn can_cross(day: usize, row: usize, col: usize, cells: &Vec<Vec<i32>>) -> bool {
        let total = row * col;
        let mut water = vec![false; total];
        for i in 0..day {
            let r = cells[i][0] as usize - 1;
            let c = cells[i][1] as usize - 1;
            water[r * col + c] = true;
        }

        let mut visited = vec![false; total];
        let mut q: VecDeque<(usize, usize)> = VecDeque::new();
        for c in 0..col {
            if !water[c] {
                visited[c] = true;
                q.push_back((0, c));
            }
        }

        let dirs = [(1_i32, 0_i32), (-1, 0), (0, 1), (0, -1)];
        while let Some((r, c)) = q.pop_front() {
            if r == row - 1 {
                return true;
            }
            for (dr, dc) in dirs.iter() {
                let nr = r as i32 + dr;
                let nc = c as i32 + dc;
                if nr < 0 || nc < 0 {
                    continue;
                }
                let nr = nr as usize;
                let nc = nc as usize;
                if nr >= row || nc >= col {
                    continue;
                }
                let idx = nr * col + nc;
                if water[idx] || visited[idx] {
                    continue;
                }
                visited[idx] = true;
                q.push_back((nr, nc));
            }
        }

        false
    }

    pub fn latest_day_to_cross(row: i32, col: i32, cells: Vec<Vec<i32>>) -> i32 {
        let row = row as usize;
        let col = col as usize;
        let mut l = 0usize;
        let mut r = cells.len();
        while l < r {
            let mid = (l + r + 1) / 2;
            if Self::can_cross(mid, row, col, &cells) {
                l = mid;
            } else {
                r = mid - 1;
            }
        }
        l as i32
    }
}
```
