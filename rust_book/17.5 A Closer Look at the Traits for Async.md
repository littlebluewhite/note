---
title: "17.5 A Closer Look at the Traits for Async"
category: rust_book
tags: [rust_book]
created: 2026-02-03
updated: 2026-02-03
difficulty: n/a
source: note
status: active
---
# 17.5 A Closer Look at the Traits for Async

## [A Closer Look at the Traits for Async](https://doc.rust-lang.org/book/ch17-05-traits-for-async.html#a-closer-look-at-the-traits-for-async)

## 深入探討非同步的特徵

Throughout the chapter, we've used the `Future`, `Pin`, `Unpin`, `Stream`, and `StreamExt` traits in various ways. So far, though, we've avoided getting too far into the details of how they work or how they fit together, which is fine most of the time for your day-to-day Rust work. Sometimes, though, you'll encounter situations where you'll need to understand a few more of these details. In this section, we'll dig in just enough to help in those scenarios, still leaving the _really_ deep dive for other documentation.

在整個章節中，我們以各種方式使用了 `Future`、`Pin`、`Unpin`、`Stream` 和 `StreamExt` 特徵。然而到目前為止，我們避免深入探討它們如何運作或如何結合在一起的細節，這對於你日常的 Rust 工作來說大多數時候是沒問題的。但有時候，你會遇到需要理解更多這些細節的情況。在本節中，我們將深入探討足以在這些場景中提供幫助的內容，但仍將真正深入的探討留給其他文檔。

### [The `Future` Trait](https://doc.rust-lang.org/book/ch17-05-traits-for-async.html#the-future-trait)

### `Future` 特徵

Let's start by taking a closer look at how the `Future` trait works. Here's how Rust defines it:

讓我們從更仔細地看看 `Future` 特徵如何運作開始。以下是 Rust 如何定義它：

```rust
#![allow(unused)]
fn main() {
use std::pin::Pin;
use std::task::{Context, Poll};

pub trait Future {
    type Output;

    fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output>;
}
}
```

That trait definition includes a bunch of new types and also some syntax we haven't seen before, so let's walk through the definition piece by piece.

這個特徵定義包含一堆新的型別，還有一些我們之前沒見過的語法，所以讓我們逐一檢視這個定義。

First, `Future`'s associated type `Output` says what the future resolves to. This is analogous to the `Item` associated type for the `Iterator` trait. Second, `Future` also has the `poll` method, which takes a special `Pin` reference for its `self` parameter and a mutable reference to a `Context` type, and returns a `Poll<Self::Output>`. We'll talk more about `Pin` and `Context` in a moment. For now, let's focus on what the method returns, the `Poll` type:

首先，`Future` 的關聯型別 `Output` 說明 future 解析成什麼。這類似於 `Iterator` 特徵的 `Item` 關聯型別。其次，`Future` 還有 `poll` 方法，它的 `self` 參數接受一個特殊的 `Pin` 引用，以及一個 `Context` 型別的可變引用，並返回一個 `Poll<Self::Output>`。我們稍後會更多地討論 `Pin` 和 `Context`。現在，讓我們專注於該方法返回什麼，即 `Poll` 型別：

```rust
#![allow(unused)]
fn main() {
enum Poll<T> {
    Ready(T),
    Pending,
}
}
```

This `Poll` type is similar to an `Option`. It has one variant that has a value, `Ready(T)`, and one which does not, `Pending`. `Poll` means something quite different from `Option`, though! The `Pending` variant indicates that the future still has work to do, so the caller will need to check again later. The `Ready` variant indicates that the future has finished its work and the `T` value is available.

這個 `Poll` 型別類似於 `Option`。它有一個包含值的變體 `Ready(T)`，以及一個不包含值的 `Pending`。然而，`Poll` 的意義與 `Option` 大不相同！`Pending` 變體表示 future 還有工作要做，所以調用者需要稍後再檢查。`Ready` 變體表示 future 已完成其工作，`T` 值可用。

Note: With most futures, the caller should not call `poll` again after the future has returned `Ready`. Many futures will panic if polled again after becoming ready. Futures that are safe to poll again will say so explicitly in their documentation. This is similar to how `Iterator::next` behaves.

注意：對於大多數 future，在 future 返回 `Ready` 後，調用者不應再次調用 `poll`。許多 future 在變為就緒後再次被輪詢會發生 panic。安全可以再次輪詢的 future 會在其文檔中明確說明。這類似於 `Iterator::next` 的行為。

When you see code that uses `await`, Rust compiles it under the hood to code that calls `poll`. If you look back at Listing 17-4, where we printed out the page title for a single URL once it resolved, Rust compiles it into something kind of (although not exactly) like this:

當你看到使用 `await` 的代碼時，Rust 在幕後將其編譯為調用 `poll` 的代碼。如果你回顧清單 17-4，我們在其中打印出單個 URL 解析後的頁面標題，Rust 會將其編譯成類似於（雖然不完全是）這樣的東西：

```rust
match page_title(url).poll() {
    Ready(page_title) => match page_title {
        Some(title) => println!("The title for {url} was {title}"),
        None => println!("{url} had no title"),
    }
    Pending => {
        // But what goes here?
    }
}
```

What should we do when the future is still `Pending`? We need some way to try again, and again, and again, until the future is finally ready. In other words, we need a loop:

當 future 仍然是 `Pending` 時我們該怎麼辦？我們需要某種方式一次又一次地嘗試，直到 future 最終就緒。換句話說，我們需要一個循環：

```rust
let mut page_title_fut = page_title(url);
loop {
    match page_title_fut.poll() {
        Ready(value) => match page_title {
            Some(title) => println!("The title for {url} was {title}"),
            None => println!("{url} had no title"),
        }
        Pending => {
            // continue
        }
    }
}
```

If Rust compiled it to exactly that code, though, every `await` would be blocking—exactly the opposite of what we were going for! Instead, Rust makes sure that the loop can hand off control to something that can pause work on this future to work on other futures and then check this one again later. As we've seen, that something is an async runtime, and this scheduling and coordination work is one of its main jobs.

然而，如果 Rust 將其編譯成完全是那樣的代碼，每個 `await` 都會阻塞——正好與我們想要的相反！相反，Rust 確保循環可以將控制權交給可以暫停處理此 future 以處理其他 future 的東西，然後稍後再次檢查此 future。正如我們所見，那個東西就是異步運行時，這種調度和協調工作是它的主要工作之一。

Earlier in the chapter, we described waiting on `rx.recv`. The `recv` call returns a future, and awaiting the future polls it. We noted that a runtime will pause the future until it's ready with either `Some(message)` or `None` when the channel closes. With our deeper understanding of the `Future` trait, and specifically `Future::poll`, we can see how that works. The runtime knows the future isn't ready when it returns `Poll::Pending`. Conversely, the runtime knows the future _is_ ready and advances it when `poll` returns `Poll::Ready(Some(message))` or `Poll::Ready(None)`.

在本章前面，我們描述了等待 `rx.recv`。`recv` 調用返回一個 future，等待 future 會輪詢它。我們注意到運行時會暫停 future，直到它準備好返回 `Some(message)` 或當通道關閉時返回 `None`。憑藉我們對 `Future` 特徵，特別是 `Future::poll` 的更深入理解，我們可以看到它是如何運作的。當它返回 `Poll::Pending` 時，運行時知道 future 還沒準備好。相反，當 `poll` 返回 `Poll::Ready(Some(message))` 或 `Poll::Ready(None)` 時，運行時知道 future 已經準備好並推進它。

The exact details of how a runtime does that are beyond the scope of this book, but the key is to see the basic mechanics of futures: a runtime _polls_ each future it is responsible for, putting the future back to sleep when it is not yet ready.

運行時如何做到這一點的確切細節超出了本書的範圍，但關鍵是要看到 future 的基本機制：運行時輪詢它負責的每個 future，當 future 尚未就緒時將其置於睡眠狀態。

### [The `Pin` and `Unpin` Traits](https://doc.rust-lang.org/book/ch17-05-traits-for-async.html#the-pin-and-unpin-traits)

### `Pin` 和 `Unpin` 特徵

When we introduced the idea of pinning in Listing 17-16, we ran into a very gnarly error message. Here is the relevant part of it again:

當我們在清單 17-16 中介紹固定（pinning）的概念時，我們遇到了一個非常複雜的錯誤訊息。以下是它的相關部分：

```
error[E0277]: `{async block@src/main.rs:10:23: 10:33}` cannot be unpinned
  --> src/main.rs:48:33
   |
48 |         trpl::join_all(futures).await;
   |                                 ^^^^^ the trait `Unpin` is not implemented for `{async block@src/main.rs:10:23: 10:33}`
   |
   = note: consider using the `pin!` macro
           consider using `Box::pin` if you need to access the pinned value outside of the current scope
   = note: required for `Box<{async block@src/main.rs:10:23: 10:33}>` to implement `Future`
note: required by a bound in `futures_util::future::join_all::JoinAll`
  --> file:///home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/futures-util-0.3.30/src/future/join_all.rs:29:8
   |
27 | pub struct JoinAll<F>
   |            ------- required by a bound in this struct
28 | where
29 |     F: Future,
   |        ^^^^^^ required by this bound in `JoinAll`
```

This error message tells us not only that we need to pin the values but also why pinning is required. The `trpl::join_all` function returns a struct called `JoinAll`. That struct is generic over a type `F`, which is constrained to implement the `Future` trait. Directly awaiting a future with `await` pins the future implicitly. That's why we don't need to use `pin!` everywhere we want to await futures.

這個錯誤訊息不僅告訴我們需要固定值，還告訴我們為什麼需要固定。`trpl::join_all` 函數返回一個名為 `JoinAll` 的結構體。該結構體對型別 `F` 是泛型的，`F` 被限制為實現 `Future` 特徵。直接用 `await` 等待 future 會隱式地固定 future。這就是為什麼我們不需要在每個想要等待 future 的地方使用 `pin!`。

However, we're not directly awaiting a future here. Instead, we construct a new future, `JoinAll`, by passing a collection of futures to the `join_all` function. The signature for `join_all` requires that the types of the items in the collection all implement the `Future` trait, and `Box<T>` implements `Future` only if the `T` it wraps is a future that implements the `Unpin` trait.

然而，我們在這裡並不是直接等待一個 future。相反，我們通過將一個 future 集合傳遞給 `join_all` 函數來構造一個新的 future `JoinAll`。`join_all` 的簽名要求集合中項目的型別都實現 `Future` 特徵，而 `Box<T>` 僅當它包裝的 `T` 是實現 `Unpin` 特徵的 future 時才實現 `Future`。

That's a lot to absorb! To really understand it, let's dive a little further into how the `Future` trait actually works, in particular around _pinning_.

這有很多要吸收的內容！要真正理解它，讓我們更深入地探討 `Future` 特徵實際上如何運作，特別是關於固定的部分。

Look again at the definition of the `Future` trait:

再次看看 `Future` 特徵的定義：

```rust
#![allow(unused)]
fn main() {
use std::pin::Pin;
use std::task::{Context, Poll};

pub trait Future {
    type Output;

    // Required method
    fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output>;
}
}
```

The `cx` parameter and its `Context` type are the key to how a runtime actually knows when to check any given future while still being lazy. Again, the details of how that works are beyond the scope of this chapter, and you generally only need to think about this when writing a custom `Future` implementation. We'll focus instead on the type for `self`, as this is the first time we've seen a method where `self` has a type annotation. A type annotation for `self` works like type annotations for other function parameters, but with two key differences:

`cx` 參數及其 `Context` 型別是運行時實際上如何知道何時檢查任何給定 future 同時仍然保持惰性的關鍵。同樣，其運作細節超出了本章的範圍，並且你通常只需要在編寫自定義 `Future` 實現時考慮這一點。我們將專注於 `self` 的型別，因為這是我們第一次看到 `self` 有型別註解的方法。`self` 的型別註解與其他函數參數的型別註解類似，但有兩個關鍵區別：

- It tells Rust what type `self` must be for the method to be called.

- It can't be just any type. It's restricted to the type on which the method is implemented, a reference or smart pointer to that type, or a `Pin` wrapping a reference to that type.

- 它告訴 Rust `self` 必須是什麼型別才能調用該方法。

- 它不能是任何型別。它僅限於實現該方法的型別、對該型別的引用或智能指針，或包裝對該型別引用的 `Pin`。

We'll see more on this syntax in [Chapter 18](https://doc.rust-lang.org/book/ch18-00-oop.html). For now, it's enough to know that if we want to poll a future to check whether it is `Pending` or `Ready(Output)`, we need a `Pin`-wrapped mutable reference to the type.

我們將在第 18 章中看到更多關於這種語法的內容。現在，只需知道如果我們想輪詢一個 future 來檢查它是 `Pending` 還是 `Ready(Output)`，我們需要一個被 `Pin` 包裝的對該型別的可變引用。

`Pin` is a wrapper for pointer-like types such as `&`, `&mut`, `Box`, and `Rc`. (Technically, `Pin` works with types that implement the `Deref` or `DerefMut` traits, but this is effectively equivalent to working only with pointers.) `Pin` is not a pointer itself and doesn't have any behavior of its own like `Rc` and `Arc` do with reference counting; it's purely a tool the compiler can use to enforce constraints on pointer usage.

`Pin` 是用於指針類型的包裝器，例如 `&`、`&mut`、`Box` 和 `Rc`。（從技術上講，`Pin` 適用於實現 `Deref` 或 `DerefMut` 特徵的型別，但這實際上等同於只使用指針。）`Pin` 本身不是指針，也沒有像 `Rc` 和 `Arc` 那樣的引用計數行為；它純粹是編譯器可以用來強制執行指針使用約束的工具。

Recalling that `await` is implemented in terms of calls to `poll` starts to explain the error message we saw earlier, but that was in terms of `Unpin`, not `Pin`. So how exactly does `Pin` relate to `Unpin`, and why does `Future` need `self` to be in a `Pin` type to call `poll`?

回想起 `await` 是根據對 `poll` 的調用來實現的，這開始解釋我們之前看到的錯誤訊息，但那是關於 `Unpin` 而不是 `Pin`。那麼 `Pin` 究竟如何與 `Unpin` 相關，為什麼 `Future` 需要 `self` 成為 `Pin` 型別才能調用 `poll`？

Remember from earlier in this chapter a series of await points in a future get compiled into a state machine, and the compiler makes sure that state machine follows all of Rust's normal rules around safety, including borrowing and ownership. To make that work, Rust looks at what data is needed between one await point and either the next await point or the end of the async block. It then creates a corresponding variant in the compiled state machine. Each variant gets the access it needs to the data that will be used in that section of the source code, whether by taking ownership of that data or by getting a mutable or immutable reference to it.

記得在本章前面，future 中的一系列等待點被編譯成狀態機，編譯器確保該狀態機遵循 Rust 所有關於安全的正常規則，包括借用和所有權。為了使其工作，Rust 會查看一個等待點到下一個等待點或異步塊結束之間需要什麼數據。然後它在編譯的狀態機中創建相應的變體。每個變體都可以訪問將在該源代碼部分中使用的數據，無論是通過取得該數據的所有權還是通過獲取對其的可變或不可變引用。

So far, so good: if we get anything wrong about the ownership or references in a given async block, the borrow checker will tell us. When we want to move around the future that corresponds to that block—like moving it into a `Vec` to pass to `join_all`—things get trickier.

到目前為止，一切都很好：如果我們在給定的異步塊中對所有權或引用有任何錯誤，借用檢查器會告訴我們。當我們想要移動對應於該塊的 future 時——比如將它移動到一個 `Vec` 中以傳遞給 `join_all`——事情變得更加棘手。

When we move a future—whether by pushing it into a data structure to use as an iterator with `join_all` or by returning it from a function—that actually means moving the state machine Rust creates for us. And unlike most other types in Rust, the futures Rust creates for async blocks can end up with references to themselves in the fields of any given variant, as shown in the simplified illustration in Figure 17-4.

當我們移動一個 future 時——無論是通過將其推入數據結構以用作 `join_all` 的迭代器，還是通過從函數返回它——這實際上意味著移動 Rust 為我們創建的狀態機。與 Rust 中的大多數其他型別不同，Rust 為異步塊創建的 future 最終可能在任何給定變體的字段中包含對自身的引用，如圖 17-4 的簡化圖所示。

![A single-column, three-row table representing a future, fut1, which has data values 0 and 1 in the first two rows and an arrow pointing from the third row back to the second row, representing an internal reference within the future.](https://doc.rust-lang.org/book/img/trpl17-04.svg)

Figure 17-4: A self-referential data type.

圖 17-4：自引用數據型別。

By default, though, any object that has a reference to itself is unsafe to move, because references always point to the actual memory address of whatever they refer to (see Figure 17-5). If you move the data structure itself, those internal references will be left pointing to the old location. However, that memory location is now invalid. For one thing, its value will not be updated when you make changes to the data structure. For another—more important—thing, the computer is now free to reuse that memory for other purposes! You could end up reading completely unrelated data later.

然而，默認情況下，任何具有對自身引用的對象都不安全移動，因為引用總是指向它們所引用的任何內容的實際記憶體位址（見圖 17-5）。如果你移動數據結構本身，這些內部引用將仍然指向舊位置。然而，該記憶體位置現在無效。一方面，當你對數據結構進行更改時，它的值不會更新。另一方面——更重要的是——計算機現在可以自由地將該記憶體用於其他目的！你最終可能會讀取完全無關的數據。

![Two tables, depicting two futures, fut1 and fut2, each of which has one column and three rows, representing the result of having moved a future out of fut1 into fut2. The first, fut1, is grayed out, with a question mark in each index, representing unknown memory. The second, fut2, has 0 and 1 in the first and second rows and an arrow pointing from its third row back to the second row of fut1, representing a pointer that is referencing the old location in memory of the future before it was moved.](https://doc.rust-lang.org/book/img/trpl17-05.svg)

Figure 17-5: The unsafe result of moving a self-referential data type

圖 17-5：移動自引用數據型別的不安全結果

Theoretically, the Rust compiler could try to update every reference to an object whenever it gets moved, but that could add a lot of performance overhead, especially if a whole web of references needs updating. If we could instead make sure the data structure in question _doesn't move in memory_, we wouldn't have to update any references. This is exactly what Rust's borrow checker requires: in safe code, it prevents you from moving any item with an active reference to it.

理論上，Rust 編譯器可以嘗試在每次移動對象時更新對該對象的每個引用，但這可能會增加大量性能開銷，特別是如果整個引用網絡需要更新。如果我們可以確保所討論的數據結構不在記憶體中移動，我們就不必更新任何引用。這正是 Rust 的借用檢查器所要求的：在安全代碼中，它防止你移動任何具有對它的活動引用的項目。

`Pin` builds on that to give us the exact guarantee we need. When we _pin_ a value by wrapping a pointer to that value in `Pin`, it can no longer move. Thus, if you have `Pin<Box<SomeType>>`, you actually pin the `SomeType` value, _not_ the `Box` pointer. Figure 17-6 illustrates this process.

`Pin` 建立在此基礎上，為我們提供了我們需要的確切保證。當我們通過將指向該值的指針包裝在 `Pin` 中來固定一個值時，它就不能再移動了。因此，如果你有 `Pin<Box<SomeType>>`，你實際上固定的是 `SomeType` 值，而不是 `Box` 指針。圖 17-6 說明了這個過程。

![Three boxes laid out side by side. The first is labeled "Pin", the second "b1", and the third "pinned". Within "pinned" is a table labeled "fut", with a single column; it represents a future with cells for each part of the data structure. Its first cell has the value "0", its second cell has an arrow coming out of it and pointing to the fourth and final cell, which has the value "1" in it, and the third cell has dashed lines and an ellipsis to indicate there may be other parts to the data structure. All together, the "fut" table represents a future which is self-referential. An arrow leaves the box labeled "Pin", goes through the box labeled "b1" and has terminates inside the "pinned" box at the "fut" table.](https://doc.rust-lang.org/book/img/trpl17-06.svg)

Figure 17-6: Pinning a `Box` that points to a self-referential future type.

圖 17-6：固定指向自引用 future 型別的 `Box`。

In fact, the `Box` pointer can still move around freely. Remember: we care about making sure the data ultimately being referenced stays in place. If a pointer moves around, _but the data it points to is in the same place_, as in Figure 17-7, there's no potential problem. As an independent exercise, look at the docs for the types as well as the `std::pin` module and try to work out how you'd do this with a `Pin` wrapping a `Box`.) The key is that the self-referential type itself cannot move, because it is still pinned.

事實上，`Box` 指針仍然可以自由移動。記住：我們關心的是確保最終被引用的數據保持在原地。如果一個指針移動，但它指向的數據在同一位置，如圖 17-7 所示，就沒有潛在的問題。作為一個獨立的練習，查看型別的文檔以及 `std::pin` 模組，並嘗試弄清楚如何使用包裝 `Box` 的 `Pin` 來做到這一點。）關鍵是自引用型別本身不能移動，因為它仍然被固定。

![Four boxes laid out in three rough columns, identical to the previous diagram with a change to the second column. Now there are two boxes in the second column, labeled "b1" and "b2", "b1" is grayed out, and the arrow from "Pin" goes through "b2" instead of "b1", indicating that the pointer has moved from "b1" to "b2", but the data in "pinned" has not moved.](https://doc.rust-lang.org/book/img/trpl17-07.svg)

Figure 17-7: Moving a `Box` which points to a self-referential future type.

圖 17-7：移動指向自引用 future 型別的 `Box`。

However, most types are perfectly safe to move around, even if they happen to be behind a `Pin` wrapper. We only need to think about pinning when items have internal references. Primitive values such as numbers and Booleans are safe because they obviously don't have any internal references. Neither do most types you normally work with in Rust. You can move around a `Vec`, for example, without worrying. Given only what we have seen so far, if you have a `Pin<Vec<String>>`, you'd have to do everything via the safe but restrictive APIs provided by `Pin`, even though a `Vec<String>` is always safe to move if there are no other references to it. We need a way to tell the compiler that it's fine to move items around in cases like this—and that's where `Unpin` comes into play.

然而，大多數型別完全可以安全地移動，即使它們恰好在 `Pin` 包裝器後面。我們只需要在項目具有內部引用時考慮固定。原始值如數字和布爾值是安全的，因為它們顯然沒有任何內部引用。你通常在 Rust 中使用的大多數型別也沒有。例如，你可以毫無顧慮地移動 `Vec`。僅根據我們到目前為止所看到的，如果你有一個 `Pin<Vec<String>>`，即使 `Vec<String>` 在沒有其他對它的引用時總是可以安全移動，你也必須通過 `Pin` 提供的安全但受限制的 API 來做所有事情。我們需要一種方式告訴編譯器在這種情況下移動項目是可以的——這就是 `Unpin` 發揮作用的地方。

`Unpin` is a marker trait, similar to the `Send` and `Sync` traits we saw in Chapter 16, and thus has no functionality of its own. Marker traits exist only to tell the compiler it's safe to use the type implementing a given trait in a particular context. `Unpin` informs the compiler that a given type does _not_ need to uphold any guarantees about whether the value in question can be safely moved.

`Unpin` 是一個標記特徵，類似於我們在第 16 章中看到的 `Send` 和 `Sync` 特徵，因此沒有自己的功能。標記特徵僅用於告訴編譯器在特定上下文中使用實現給定特徵的型別是安全的。`Unpin` 通知編譯器給定型別不需要維護關於所討論的值是否可以安全移動的任何保證。

Just as with `Send` and `Sync`, the compiler implements `Unpin` automatically for all types where it can prove it is safe. A special case, again similar to `Send` and `Sync`, is where `Unpin` is _not_ implemented for a type. The notation for this is `impl !Unpin for _SomeType_`, where `_SomeType_` is the name of a type that _does_ need to uphold those guarantees to be safe whenever a pointer to that type is used in a `Pin`.

就像 `Send` 和 `Sync` 一樣，編譯器會為所有它可以證明是安全的型別自動實現 `Unpin`。一個特殊情況，同樣類似於 `Send` 和 `Sync`，是當一個型別沒有實現 `Unpin` 時。這個符號是 `impl !Unpin for _SomeType_`，其中 `_SomeType_` 是一個確實需要維護這些保證的型別的名稱，以便在 `Pin` 中使用指向該型別的指針時是安全的。

In other words, there are two things to keep in mind about the relationship between `Pin` and `Unpin`. First, `Unpin` is the "normal" case, and `!Unpin` is the special case. Second, whether a type implements `Unpin` or `!Unpin` _only_ matters when you're using a pinned pointer to that type like `Pin<&mut _SomeType_>`.

換句話說，關於 `Pin` 和 `Unpin` 之間的關係有兩件事要記住。首先，`Unpin` 是「正常」情況，而 `!Unpin` 是特殊情況。其次，一個型別是否實現 `Unpin` 或 `!Unpin` 只在你使用指向該型別的固定指針（如 `Pin<&mut _SomeType_>`）時才重要。

To make that concrete, think about a `String`: it has a length and the Unicode characters that make it up. We can wrap a `String` in `Pin`, as seen in Figure 17-8. However, `String` automatically implements `Unpin`, as do most other types in Rust.

為了使其具體化，想想一個 `String`：它有一個長度和組成它的 Unicode 字符。我們可以將 `String` 包裝在 `Pin` 中，如圖 17-8 所示。然而，`String` 會自動實現 `Unpin`，就像 Rust 中的大多數其他型別一樣。

![Concurrent work flow](https://doc.rust-lang.org/book/img/trpl17-08.svg)

Figure 17-8: Pinning a `String`; the dotted line indicates that the `String` implements the `Unpin` trait, and thus is not pinned.

圖 17-8：固定一個 `String`；虛線表示 `String` 實現了 `Unpin` 特徵，因此沒有被固定。

As a result, we can do things that would be illegal if `String` implemented `!Unpin` instead, such as replacing one string with another at the exact same location in memory as in Figure 17-9. This doesn't violate the `Pin` contract, because `String` has no internal references that make it unsafe to move around! That is precisely why it implements `Unpin` rather than `!Unpin`.

因此，我們可以做如果 `String` 實現 `!Unpin` 就會是非法的事情，例如在記憶體中的完全相同位置用另一個字符串替換一個字符串，如圖 17-9 所示。這不會違反 `Pin` 契約，因為 `String` 沒有使其移動變得不安全的內部引用！這正是它實現 `Unpin` 而不是 `!Unpin` 的原因。

![Concurrent work flow](https://doc.rust-lang.org/book/img/trpl17-09.svg)

Figure 17-9: Replacing the `String` with an entirely different `String` in memory.

圖 17-9：在記憶體中用完全不同的 `String` 替換 `String`。

Now we know enough to understand the errors reported for that `join_all` call from back in Listing 17-17. We originally tried to move the futures produced by async blocks into a `Vec<Box<dyn Future<Output = ()>>>`, but as we've seen, those futures may have internal references, so they don't implement `Unpin`. They need to be pinned, and then we can pass the `Pin` type into the `Vec`, confident that the underlying data in the futures will _not_ be moved.

現在我們知道足夠多來理解清單 17-17 中 `join_all` 調用報告的錯誤。我們最初試圖將異步塊產生的 future 移動到 `Vec<Box<dyn Future<Output = ()>>>` 中，但正如我們所見，這些 future 可能有內部引用，所以它們不實現 `Unpin`。它們需要被固定，然後我們可以將 `Pin` 型別傳遞到 `Vec` 中，確信 future 中的底層數據不會被移動。

`Pin` and `Unpin` are mostly important for building lower-level libraries, or when you're building a runtime itself, rather than for day-to-day Rust code. When you see these traits in error messages, though, now you'll have a better idea of how to fix your code!

`Pin` 和 `Unpin` 主要對於構建低級庫或當你構建運行時本身時很重要，而不是對於日常 Rust 代碼。但是，當你在錯誤訊息中看到這些特徵時，現在你將更好地了解如何修復你的代碼！

Note: This combination of `Pin` and `Unpin` makes it possible to safely implement a whole class of complex types in Rust that would otherwise prove challenging because they're self-referential. Types that require `Pin` show up most commonly in async Rust today, but every once in a while, you might see them in other contexts, too.

注意：`Pin` 和 `Unpin` 的這種組合使得在 Rust 中安全實現整類複雜型別成為可能，否則這些型別因為是自引用的而會被證明具有挑戰性。今天，需要 `Pin` 的型別在異步 Rust 中最常出現，但偶爾你也可能在其他上下文中看到它們。

The specifics of how `Pin` and `Unpin` work, and the rules they're required to uphold, are covered extensively in the API documentation for `std::pin`, so if you're interested in learning more, that's a great place to start.

`Pin` 和 `Unpin` 如何工作的細節，以及它們需要維護的規則，在 `std::pin` 的 API 文檔中有廣泛的介紹，所以如果你有興趣學習更多，那是一個很好的起點。

If you want to understand how things work under the hood in even more detail, see Chapters [2](https://rust-lang.github.io/async-book/02_execution/01_chapter.html) and [4](https://rust-lang.github.io/async-book/04_pinning/01_chapter.html) of [_Asynchronous Programming in Rust_](https://rust-lang.github.io/async-book/).

如果你想更詳細地了解幕後工作原理，請參閱《Rust 中的異步編程》的第 2 章和第 4 章。

### [The `Stream` Trait](https://doc.rust-lang.org/book/ch17-05-traits-for-async.html#the-stream-trait)

### `Stream` 特徵

Now that you have a deeper grasp on the `Future`, `Pin`, and `Unpin` traits, we can turn our attention to the `Stream` trait. As you learned earlier in the chapter, streams are similar to asynchronous iterators. Unlike `Iterator` and `Future`, however, `Stream` has no definition in the standard library as of this writing, but there _is_ a very common definition from the `futures` crate used throughout the ecosystem.

現在你對 `Future`、`Pin` 和 `Unpin` 特徵有了更深入的理解，我們可以將注意力轉向 `Stream` 特徵。正如你在本章前面學到的，串流類似於異步迭代器。然而，與 `Iterator` 和 `Future` 不同，截至撰寫本文時，`Stream` 在標準庫中沒有定義，但在整個生態系統中使用的 `futures` crate 中有一個非常常見的定義。

Let's review the definitions of the `Iterator` and `Future` traits before looking at how a `Stream` trait might merge them together. From `Iterator`, we have the idea of a sequence: its `next` method provides an `Option<Self::Item>`. From `Future`, we have the idea of readiness over time: its `poll` method provides a `Poll<Self::Output>`. To represent a sequence of items that become ready over time, we define a `Stream` trait that puts those features together:

在看 `Stream` 特徵如何將它們合併在一起之前，讓我們回顧一下 `Iterator` 和 `Future` 特徵的定義。從 `Iterator`，我們有序列的概念：它的 `next` 方法提供一個 `Option<Self::Item>`。從 `Future`，我們有隨著時間準備就緒的概念：它的 `poll` 方法提供一個 `Poll<Self::Output>`。為了表示隨時間準備就緒的項目序列，我們定義一個 `Stream` 特徵，將這些特性結合在一起：

```rust
#![allow(unused)]
fn main() {
use std::pin::Pin;
use std::task::{Context, Poll};

trait Stream {
    type Item;

    fn poll_next(
        self: Pin<&mut Self>,
        cx: &mut Context<'_>
    ) -> Poll<Option<Self::Item>>;
}
}
```

The `Stream` trait defines an associated type called `Item` for the type of the items produced by the stream. This is similar to `Iterator`, where there may be zero to many items, and unlike `Future`, where there is always a single `Output`, even if it's the unit type `()`.

`Stream` 特徵為串流產生的項目型別定義了一個名為 `Item` 的關聯型別。這類似於 `Iterator`，其中可能有零到多個項目，與 `Future` 不同，`Future` 總是有一個單一的 `Output`，即使它是單元型別 `()`。

`Stream` also defines a method to get those items. We call it `poll_next`, to make it clear that it polls in the same way `Future::poll` does and produces a sequence of items in the same way `Iterator::next` does. Its return type combines `Poll` with `Option`. The outer type is `Poll`, because it has to be checked for readiness, just as a future does. The inner type is `Option`, because it needs to signal whether there are more messages, just as an iterator does.

`Stream` 還定義了一個獲取這些項目的方法。我們稱之為 `poll_next`，以明確它以與 `Future::poll` 相同的方式輪詢，並以與 `Iterator::next` 相同的方式產生項目序列。它的返回型別將 `Poll` 與 `Option` 結合在一起。外部型別是 `Poll`，因為它必須被檢查準備就緒狀態，就像 future 一樣。內部型別是 `Option`，因為它需要信號是否還有更多消息，就像迭代器一樣。

Something very similar to this definition will likely end up as part of Rust's standard library. In the meantime, it's part of the toolkit of most runtimes, so you can rely on it, and everything we cover next should generally apply!

與此定義非常相似的東西很可能最終成為 Rust 標準庫的一部分。與此同時，它是大多數運行時工具包的一部分，所以你可以依賴它，我們接下來涵蓋的一切通常都應該適用！

In the example we saw in the section on streaming, though, we didn't use `poll_next` _or_ `Stream`, but instead used `next` and `StreamExt`. We _could_ work directly in terms of the `poll_next` API by hand-writing our own `Stream` state machines, of course, just as we _could_ work with futures directly via their `poll` method. Using `await` is much nicer, though, and the `StreamExt` trait supplies the `next` method so we can do just that:

然而，在我們在串流部分看到的例子中，我們沒有使用 `poll_next` 或 `Stream`，而是使用了 `next` 和 `StreamExt`。當然，我們可以通過手寫我們自己的 `Stream` 狀態機直接使用 `poll_next` API，就像我們可以通過 future 的 `poll` 方法直接使用 future 一樣。然而，使用 `await` 更好，`StreamExt` 特徵提供了 `next` 方法，所以我們可以做到這一點：

```rust
#![allow(unused)]
fn main() {
use std::pin::Pin;
use std::task::{Context, Poll};

trait Stream {
    type Item;
    fn poll_next(
        self: Pin<&mut Self>,
        cx: &mut Context<'_>,
    ) -> Poll<Option<Self::Item>>;
}

trait StreamExt: Stream {
    async fn next(&mut self) -> Option<Self::Item>
    where
        Self: Unpin;

    // other methods...
}
}
```

Note: The actual definition we used earlier in the chapter looks slightly different than this, because it supports versions of Rust that did not yet support using async functions in traits. As a result, it looks like this:

注意：我們在本章前面使用的實際定義看起來與此略有不同，因為它支持尚不支持在特徵中使用異步函數的 Rust 版本。因此，它看起來像這樣：

```rust
fn next(&mut self) -> Next<'_, Self> where Self: Unpin;
```

That `Next` type is a `struct` that implements `Future` and allows us to name the lifetime of the reference to `self` with `Next<'_, Self>`, so that `await` can work with this method.

那個 `Next` 型別是一個實現 `Future` 的 `struct`，並允許我們用 `Next<'_, Self>` 命名對 `self` 的引用的生命週期，以便 `await` 可以與此方法一起工作。

The `StreamExt` trait is also the home of all the interesting methods available to use with streams. `StreamExt` is automatically implemented for every type that implements `Stream`, but these traits are defined separately to enable the community to iterate on convenience APIs without affecting the foundational trait.

`StreamExt` 特徵也是所有可用於串流的有趣方法的家。`StreamExt` 為每個實現 `Stream` 的型別自動實現，但這些特徵是分開定義的，以使社區能夠在不影響基礎特徵的情況下迭代便利 API。

In the version of `StreamExt` used in the `trpl` crate, the trait not only defines the `next` method but also supplies a default implementation of `next` that correctly handles the details of calling `Stream::poll_next`. This means that even when you need to write your own streaming data type, you _only_ have to implement `Stream`, and then anyone who uses your data type can use `StreamExt` and its methods with it automatically.

在 `trpl` crate 中使用的 `StreamExt` 版本中，該特徵不僅定義了 `next` 方法，還提供了 `next` 的默認實現，該實現正確處理調用 `Stream::poll_next` 的細節。這意味著即使你需要編寫自己的串流數據型別，你也只需實現 `Stream`，然後使用你的數據型別的任何人都可以自動使用 `StreamExt` 及其方法。

That's all we're going to cover for the lower-level details on these traits. To wrap up, let's consider how futures (including streams), tasks, and threads all fit together!

這就是我們要涵蓋的這些特徵的低級細節。最後，讓我們考慮一下 future（包括串流）、任務和線程如何結合在一起！
