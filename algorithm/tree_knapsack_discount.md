# tree_knapsack_discount

樹狀 0/1 背包，處理「父節點購買」觸發的半價折扣，求最大獲利。

## 問題摘要

- 樹根為員工 1，每個節點可選擇「買」或「不買」。  
- 若父節點買，子節點成本改為半價（向下取整）；否則用原價。  
- 總花費不得超過 `budget (<=160)`，目標最大化獲利。

## 思考過程

1. 折扣只由「直屬父」決定，與更遠祖先無關，因此每個節點只需知道「父是否買了」。  
2. 預算上限 160，不大，背包維度可直接用成本做 DP。  
3. 樹型結構天然適合 DFS 自底向上合併子樹：先計算子節點最優，再把子樹結果當成「物品組」做合併。  
4. 節點 `u` 自身的買/不買會影響子節點折扣，因此需為兩個父狀態都保留一張背包表，且在狀態內考慮 `u` 的買/不買兩種情境。

## 狀態設計

- `dp0_u[c]`：父未買（無折扣），在 `u` 子樹花費 `c` 的最大獲利。  
- `dp1_u[c]`：父已買（有折扣），在 `u` 子樹花費 `c` 的最大獲利。  
- 長度皆為 `B+1`，初始化為負無限，未使用成本視為不可行。

## 轉移邏輯

對節點 `u`，先 DFS 得到所有子節點的 `(dp0, dp1)`。接著分情境建兩張候選表，再逐成本取最大：

- **不買 `u`**：基底成本 0、收益 0；子節點只能用 `dp0`（無折扣）。逐子節點用 0/1 背包合併。  
- **買 `u`**：  
  - 父未買時，`u` 成本 = 原價，收益 = `future[u] - present[u]`，子節點用 `dp1`（享折扣）。  
  - 父已買時，`u` 成本 = 半價 `present[u]/2`，收益 = `future[u] - present[u]/2`，子節點同樣用 `dp1`。  
- `dp0` = max(不買, 買原價)；`dp1` = max(不買, 買半價) 逐成本比較。

**子合併（0/1 背包）**：給定當前表 `base` 與子表 `child`，枚舉花費 `i` in `base` 與 `j` in `child`，更新 `res[i+j] = max(res[i+j], base[i] + child[j])`。成本超界則跳過。

## 正確性直覺

- 折扣的唯一來源是父節點是否買，所以「父是否買」充分描述了對子節點的價格影響。  
- 在每個父狀態下，節點 `u` 的買與不買都被枚舉，子節點使用對應價格表，涵蓋所有合法選擇組合。  
- 背包合併保證在每個成本下取得最大收益，DFS 自底向上即得全局最優。

## 複雜度

- 時間：`O(n * B^2)`，每個節點合併子樹背包，`B = budget (<= 160)`。  
- 空間：`O(n * B)`，兩組 DP 陣列，可就地覆蓋降低常數。

## 邊界與實作細節

- 半價採整數除法 `present[u] / 2`。  
- 需保留「不買」的 0 成本 0 獲利，避免強迫買入負收益股票。  
- 用大負數初始化不可行狀態，合併時跳過不可行項。  
- 樹深最多 160，遞迴可接受；若擔心，可改顯式堆疊。  
- 根節點答案取 `dp0` 在 `0..=B` 的最大值（根沒有上層折扣）。  
- 本方法應用在：折扣/額外條件只依賴父節點、且預算維度不大時的樹上選擇/背包問題。
