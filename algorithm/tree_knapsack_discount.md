# tree_knapsack_discount

以樹狀結構的 0/1 背包計算在折扣條件下的最大獲利。

## 問題摘要

- 樹根為員工 1，每個節點可選擇「買」或「不買」。  
- 若父節點買，子節點成本改為半價（向下取整）；否則用原價。  
- 總花費不得超過 `budget (<=160)`，目標最大化獲利。

## 核心想法

- 折扣只受「父節點有無購買」影響，與更遠祖先無關，因此節點 DP 狀態用 `parentBought` 二元值即可。  
- 針對節點 `u`，同時維護 `dp0`（父未買）與 `dp1`（父已買）兩個長度 `B+1` 的陣列，`dp?[b]` 為在子樹 `u` 內花費 `b` 的最大獲利。  
- `u` 的兩種選擇：不買（成本 0，子節點用 `dp0`）、買（成本為原價或半價，子節點用 `dp1`）。對每種選擇用樹上背包合併子樹，再逐成本取較大值。

## 做法

1. 以根為 1 建立子節點清單。設定預算上限 `B = budget`。  
2. `dfs(u)`：收集所有子節點的 `(dp0, dp1)`。  
   - `build_option(base_cost, base_profit, child_state)`：從基底成本開始，逐子節點與其 `child_state` 陣列做 0/1 背包合併。  
   - 對 `dp0`：比較「不買」(`base_cost=0`, 子用 `dp0`) 與「買原價」(`base_cost=present[u]`, 子用 `dp1`)。  
   - 對 `dp1`：比較「不買」(`base_cost=0`, 子用 `dp0`) 與「買半價」(`base_cost=present[u]/2`, 子用 `dp1`)。  
3. 根節點答案為 `dp0` 在 `0..=B` 的最大值。

## 複雜度

- 時間：`O(n * B^2)`，每個節點與子樹做背包合併。  
- 空間：`O(n * B)`，儲存兩組 DP 陣列，可就地覆蓋降低常數。

## 小提醒

- 半價使用整數除法 `present[u] / 2`。  
- 需允許「不買」情況避免負獲利；基底狀態成本 0、獲利 0。  
- 樹深最多 160，遞迴在 Rust 仍可接受，或可改用顯式堆疊。
