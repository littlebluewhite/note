# tree_knapsack_discount

樹狀 0/1 背包，處理「父節點購買」觸發的半價折扣，求最大獲利。

## 問題摘要

- 樹根為員工 1，每個節點可選擇「買」或「不買」。  
- 若父節點買，子節點成本改為半價（向下取整）；否則用原價。  
- 總花費不得超過 `budget (<=160)`，目標最大化獲利。

## 樹狀 0/1 背包是什麼

- 本質：在樹上做 0/1 選擇，成本/容量維度同一般背包，額外的依賴關係由樹邊給出。  
- 適用：每個節點的決策只影響自己的子樹，兄弟子樹彼此獨立；背包容量中小（常見 B <= 5000）能接受 `O(n * B^2)` 或更佳的合併複雜度。  
- 基本流程：  
  1. DFS 從葉到根，每個節點維護一張長度 `B+1` 的 `dp[c]`。  
  2. `dp[c]` 代表在該子樹花費 `c` 的最大價值/收益（不可行用負無限）。  
  3. 先把所有子節點的 `dp` 逐一用 0/1 背包式的「表合併」卷積（枚舉 `c1 + c2`）。  
  4. 再把本節點自己的「不選 / 選」兩種情境加入，更新 `dp`。  
- 為何能做：樹形依賴讓子樹內的選擇只影響自己，合併時只需考慮成本分配；一般圖沒有這個性質就無法直接背包。  
- 複雜度：合併兩張長度 `B` 的表是 `O(B^2)`，全樹約 `O(n * B^2)`；空間 `O(n * B)` 或就地覆蓋降常數。  
- 最簡模板（無折扣、僅「父選才允許子選」的依賴可直接套用）：  

```rust
fn dfs(u: usize, g: &Vec<Vec<usize>>, w: &Vec<usize>, val: &Vec<i32>, B: usize) -> Vec<i32> {
    const NEG: i32 = -1_000_000_000;
    let mut dp = vec![NEG; B + 1];
    dp[0] = 0;
    for &ch in &g[u] {
        let child = dfs(ch, g, w, val, B);
        dp = merge(dp, child, B); // merge 是 0/1 背包式的表合併
    }
    // 選當前節點（父未選則不會進 dfs 或在外層另外控制）
    for c in (w[u]..=B).rev() {
        dp[c] = dp[c].max(dp[c - w[u]] + val[u]);
    }
    dp
}
```

- 變形：若有「父不選子不可選」以外的條件（如本題的半價折扣、強制不買等），就在 `dp` 上再開一層父狀態，或在基底成本/收益調整後再做合併。

## 思考過程

1. 折扣只由「直屬父」決定，與更遠祖先無關，因此每個節點只需知道「父是否買了」。  
2. 預算上限 160，不大，背包維度可直接用成本做 DP。  
3. 樹型結構天然適合 DFS 自底向上合併子樹：先計算子節點最優，再把子樹結果當成「物品組」做合併。  
4. 節點 `u` 自身的買/不買會影響子節點折扣，因此需為兩個父狀態都保留一張背包表，且在狀態內考慮 `u` 的買/不買兩種情境。

## 狀態設計

- `dp0_u[c]`：父未買（無折扣），在 `u` 子樹花費 `c` 的最大獲利。  
- `dp1_u[c]`：父已買（有折扣），在 `u` 子樹花費 `c` 的最大獲利。  
- 長度皆為 `B+1`，初始化為負無限，未使用成本視為不可行。

## 轉移邏輯

對節點 `u`，先 DFS 得到所有子節點的 `(dp0, dp1)`。接著分情境建兩張候選表，再逐成本取最大：

- **不買 `u`**：基底成本 0、收益 0；子節點只能用 `dp0`（無折扣）。逐子節點用 0/1 背包合併。  
- **買 `u`**：  
  - 父未買時，`u` 成本 = 原價，收益 = `future[u] - present[u]`，子節點用 `dp1`（享折扣）。  
  - 父已買時，`u` 成本 = 半價 `present[u]/2`，收益 = `future[u] - present[u]/2`，子節點同樣用 `dp1`。  
- `dp0` = max(不買, 買原價)；`dp1` = max(不買, 買半價) 逐成本比較。

**子合併（0/1 背包）**：給定當前表 `base` 與子表 `child`，枚舉花費 `i` in `base` 與 `j` in `child`，更新 `res[i+j] = max(res[i+j], base[i] + child[j])`。成本超界則跳過。

## 正確性直覺

- 折扣的唯一來源是父節點是否買，所以「父是否買」充分描述了對子節點的價格影響。  
- 在每個父狀態下，節點 `u` 的買與不買都被枚舉，子節點使用對應價格表，涵蓋所有合法選擇組合。  
- 背包合併保證在每個成本下取得最大收益，DFS 自底向上即得全局最優。

## 複雜度

- 時間：`O(n * B^2)`，每個節點合併子樹背包，`B = budget (<= 160)`。  
- 空間：`O(n * B)`，兩組 DP 陣列，可就地覆蓋降低常數。

## 邊界與實作細節

- 半價採整數除法 `present[u] / 2`。  
- 需保留「不買」的 0 成本 0 獲利，避免強迫買入負收益股票。  
- 用大負數初始化不可行狀態，合併時跳過不可行項。  
- 樹深最多 160，遞迴可接受；若擔心，可改顯式堆疊。  
- 根節點答案取 `dp0` 在 `0..=B` 的最大值（根沒有上層折扣）。  
- 本方法應用在：折扣/額外條件只依賴父節點、且預算維度不大時的樹上選擇/背包問題。

## 程式碼逐行解釋（對應 `leetcode/q3562.md` 的 Rust）

- `const NEG: i32 = -1_000_000_000;`：不可行狀態的負無限，避免溢位又不會誤成最佳。  
- `children`：根據 `hierarchy` 建子節點清單（0-based）。  
- `merge(base, child, limit)`：0/1 背包合併，枚舉 `i`（已花費）與 `j`（子花費），更新 `res[i+j]`。遇到 `NEG` 跳過。  
- `build_option(base_cost, base_profit, child_states, use_discount_state, limit)`：建一個情境的背包表。先放入基底成本/收益（買或不買 `u`），再依序合併每個子節點的狀態表；`use_discount_state` 決定取子節點的 `dp1`（有折扣）或 `dp0`（無折扣）。  
- `dfs(u, ...) -> (dp0, dp1)`：  
  - 先遞迴子節點收集 `(dp0, dp1)`。  
  - 計算 `full_cost/full_profit`（原價）與 `disc_cost/disc_profit`（半價）。  
  - `opt_no_buy`：`base_cost=0`，子用 `dp0`。  
  - `opt_buy_full`：`base_cost=present[u]`，子用 `dp1`。  
  - `dp0[i] = max(opt_no_buy[i], opt_buy_full[i])`。  
  - `opt_buy_disc`：`base_cost=present[u]/2`，子用 `dp1`。  
  - `dp1[i] = max(opt_no_buy[i], opt_buy_disc[i])`。  
  - 回傳 `(dp0, dp1)`。  
- 主程式：`let (root_dp, _) = dfs(0, ...);` 取根的 `dp0`（父不存在視為未買），在 `0..=budget` 中取最大值作答。  
- 重要邏輯：  
  - 子狀態選擇完全由 `use_discount_state` 控制，確保父買時子享折扣，父不買時子原價。  
  - `opt_no_buy` 共享於 `dp0/dp1`，代表「這個節點不買」的通用情境。  
  - 負無限初始化與跳過不可行值避免錯誤累加。  
  - 成本採 `usize` 避免負值；收益保留 `i32`，因為差值可能為負，但初始化的 `NEG` 確保不會被無效狀態覆蓋。
