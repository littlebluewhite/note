# Smooth Descent Run Count

目標：給定股價序列 `prices`，定義「平滑下降區間」為連續天數，且每日價格較前一日恰好少 1（單一天也算）。求所有平滑下降區間總數。

## 規律與核心公式

- 若某段連續下降（差值恰為 -1）的長度為 `len`，該段內的連續子區間數為 `len * (len + 1) / 2`。例：`len = 3` 時子區間為長度 1, 2, 3 共 6 個。
- 將序列切成多段「差值 = -1 的連續區間」，答案為各段貢獻和。
- 單趟掃描即可累積目前連續長度 `run`，每往後一格：
  - 若 `prices[i] == prices[i-1] - 1` 則 `run += 1`；
  - 否則重新開段 `run = 1`。
  每一步將 `run` 加入答案，即隱含了「這個位置為結尾的所有合法區間」數。

## 為什麼逐步加 `run` 就能覆蓋所有區間

- 以位置 `i` 為結尾的平滑下降區間，其長度至多為當前連續段長 `run`，總數正好為 `run`（長度 1..run 各一個）。
- 逐點前進並累加 `run`，等價於對所有結尾位置枚舉其所有合法起點，因此與分段後套 `len(len+1)/2` 的結果相同。

## 步驟

1) 初始化 `run = 0, ans = 0`。  
2) 逐日掃描 `prices`：若是第一天，`run = 1`；否則依差值更新 `run`（如上規則）。  
3) `ans += run`。  
4) 最終回傳 `ans`。

## 複雜度與適用情況

- 時間：O(n)。空間：O(1)。
- 適用於需要計算「連續差值滿足固定值」的區間數量，可平移到差值為 0（平穩段）、差值為 +1（平滑上升）等情境。

## 邊界與防呆

- 單元素陣列：`run` 從 1 開始，答案至少為 1。
- 相等或差值不為 -1 時，需重置 `run = 1`（當天單點區間）。
- 可能超過 32 位，使用 64 位累加。

