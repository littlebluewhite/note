# Sliding Window + Prefix DP for Max-Min ≤ k Partition

目標：計算一個陣列被切成若干連續段且「每段最大值與最小值差 ≤ k」的切分數；長度可達 5 * 10^4，需要線性或近線性演算法。

## 核心想法

- 用雙端隊列維持滑動視窗的 `max` 與 `min`。新增右端元素時，從隊尾彈掉不符合單調性的索引（max deque 遞減，min deque 遞增），因此隊首永遠是當前視窗的最大/最小值索引。
- 只要 `max - min > k`，就左移指標 `l` 並移除越界的隊首，直到恢復合法；這保證任意時刻的 `[l, r]` 都滿足條件。
- 令 `dp[i]` 為切出前 `i` 個元素的合法方案數，`prefix[i] = Σ_{0..i} dp`。當右端為 `r` 時，所有合法左端範圍是 `l..r`，故 `dp[r+1] = prefix[r] - prefix[l-1]`，利用前綴和 O(1) 取得區間和。

## `dp` / `prefix` 的意義與例子

- `dp[i]`：前 `i` 個元素 `nums[0..i)` 的合法切分數；`dp[0]=1`（空陣列的基準切法）。
- `prefix[i] = Σ_{0..i} dp`：`dp` 的前綴和，方便做區間和；`prefix[0]=dp[0]=1`。
- 在例子 `nums=[9,4,1,3,7], k=4` 中：  
  - `i=0`：`dp=1`, `prefix=1`  
  - `i=1`：`dp=1`, `prefix=2`  
  - `i=2`：`dp=1`, `prefix=3`  
  - `i=3`：`dp=2`, `prefix=5`  
  - `i=4`：`dp=4`, `prefix=9`  
  - `i=5`：`dp=6`, `prefix=15`

## 範例演算（`nums = [9,4,1,3,7]`, `k = 4`）

- 初始 `l=0, r=0`，視窗 `[9]` 合法，`dp[1]=1`，`prefix[1]=2`。  
- `r=1` 加入 4，不合法，左移到 `l=1` 得 `[4]`；合法左端僅 `l=1`，`dp[2]=prefix[1]-prefix[0]=1`，`prefix[2]=3`。  
- `r=2` 加入 1，視窗 `[4,1]` 合法，合法左端 `l=1..2`，`dp[3]=prefix[2]-prefix[0]=2`，`prefix[3]=5`。  
- `r=3` 加入 3，視窗 `[4,1,3]` 合法，合法左端 `l=1..3`，`dp[4]=prefix[3]-prefix[0]=4`，`prefix[4]=9`。  
- `r=4` 加入 7，不合法，左移到 `l=3` 得 `[3,7]` 合法；合法左端 `l=3..4`，`dp[5]=prefix[4]-prefix[2]=6`，`prefix[5]=15`。  
- 最終 `dp[5]=6`，對應題目示例的 6 種切分。

## 重要細節

- 視窗收縮時要同步檢查隊首是否等於舊的 `l`，若是就彈出，避免引用到已離開視窗的索引。
- `prefix[r] - prefix[l-1]` 可能為負，需加上 `MOD` 後再取模。
- 所有計數使用 `i64`；輸入值與 `k` 也轉為 `i64` 避免溢位。

## 複雜度

- 時間：O(n)，每個索引最多進出兩個 deque 各一次，DP 與前綴和為常數時間。
- 空間：O(n) 儲存 `dp`、`prefix` 與兩個隊列（隊列長度不超過目前視窗大小）。
