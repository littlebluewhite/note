# Covered Buildings via Row/Column Bounds

目標：在最多 1e5 棟的座標集合中，判定哪些建築在上下左右四個方向各至少有一棟鄰居。

## 核心觀察

- 同一列（`x` 固定）若存在比 `y` 小與比 `y` 大的座標，該點在列上就同時有左、右鄰居。這等價於該點的 `y` 不是該列的最小值或最大值。
- 同一欄（`y` 固定）同理：`x` 不是該欄的最小值或最大值，即同時有上、下鄰居。
- 因此只需為每列、每欄維護最小與最大座標，無須排序或二分，即可 O(1) 判定。

## 演算法步驟

1. 掃過所有建築 `(x, y)`，以雜湊表紀錄：
   - `row_bounds[x] = (min_y, max_y)`
   - `col_bounds[y] = (min_x, max_x)`
2. 再掃一次所有建築 `(x, y)`，若 `row_min < y < row_max` 且 `col_min < x < col_max`，則該建築被覆蓋。
3. 將符合條件的數量加總即為答案。

## 複雜度與實作細節

- 時間：O(m)，`m` 為建築數；兩次線性掃描。
- 空間：O(m) 儲存各列、各欄的邊界。
- 由於座標唯一且僅比較大小，不會涉及溢位或精度問題。`n` 僅提供座標上限，可直接忽略於計算。
