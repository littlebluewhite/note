# Long/Short K Transactions with One-Day Separation

目標：股價序列 `prices`，最多做 `k` 筆交易。每筆交易可「先買後賣」或「先賣後買」，交易完成前不可再動作，且平倉當天不能立即重新開倉。求最大總獲利。

## 狀態與轉移

- 以「已完成 t 筆交易」為狀態維度，維護三個陣列：  
  - `rest[t]`：空手。  
  - `long[t]`：持有多單（已花錢）。  
  - `short[t]`：持有空單（已收錢）。  
- 每日價格 `p` 的轉移（都從前一日狀態讀取，避免同日平倉再開倉）：  
  - 平倉：`rest[t+1] = max(rest[t+1], long[t] + p, short[t] - p)`。  
  - 開倉：`long[t] = max(long[t], rest[t] - p)`；`short[t] = max(short[t], rest[t] + p)`。
- 交易數只在平倉時 +1，符合「先開再平」的流程。

## 為什麼能禁止同日再開倉

- 當天的 `long/short` 更新僅依據前一日的 `rest`，而 `rest` 在當天只會被「平倉」提升。因為更新順序用「舊陣列生成新陣列」，同一日無法先平倉寫入新 `rest` 再用它開倉，等價於強制隔日才能開新倉。

## 步驟

1) 初始化：`rest[0] = 0`，其餘設為極小值。  
2) 逐日套用上述轉移，得到新一日的 `rest/long/short`。  
3) 走完所有價格後，答案為 `max(rest[0..=k])`。

## 複雜度與注意事項

- 時間：`O(n * k)`；空間：`O(k)`。  
- 需用 64 位整數承接獲利（價差可達 `1e9`，交易數可達 `500`）。  
- 若 `k = 0`，初始 `rest[0] = 0` 即為答案，平倉轉移自動被上界排除。
