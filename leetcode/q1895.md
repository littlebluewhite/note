[1895. Largest Magic Square](https://leetcode.com/problems/largest-magic-square/)

Medium

Topics

![premium lock icon](https://leetcode.com/_next/static/images/lock-a6627e2c7fa0ce8bc117c109fb4e567d.svg)Companies

Hint

A `k x k` **magic square** is a `k x k` grid filled with integers such that every row sum, every column sum, and both diagonal sums are **all equal**. The integers in the magic square **do not have to be distinct**. Every `1 x 1` grid is trivially a **magic square**.
`k x k` **魔術方陣** 是一個 `k x k` 的整數方格，使得每一列、每一欄與兩條對角線的總和都 **相等**。魔術方陣中的整數 **不必互異**。每個 `1 x 1` 的格子都視為 **魔術方陣**。

Given an `m x n` integer `grid`, return _the **size** (i.e., the side length `k`) of the **largest magic square** that can be found within this grid_.
給定 `m x n` 的整數矩陣 `grid`，請回傳其中最大的 **魔術方陣** 尺寸（邊長 `k`）。

**Example 1:**

![](https://assets.leetcode.com/uploads/2021/05/29/magicsquare-grid.jpg)

**Input:** grid = [ [7,1,4,5,6],[2,5,1,6,4],[1,5,4,3,2],[1,2,7,3,4] ]
**Output:** 3
**Explanation:** The largest magic square has a size of 3.
**解釋：** 最大的魔術方陣邊長為 3。
Every row sum, column sum, and diagonal sum of this magic square is equal to 12.
此魔術方陣每列、每欄與對角線總和都等於 12。
- Row sums: 5+1+6 = 5+4+3 = 2+7+3 = 12
- Column sums: 5+5+2 = 1+4+7 = 6+3+3 = 12
- Diagonal sums: 5+4+3 = 6+4+2 = 12
- 列總和：5+1+6 = 5+4+3 = 2+7+3 = 12
- 欄總和：5+5+2 = 1+4+7 = 6+3+3 = 12
- 對角線總和：5+4+3 = 6+4+2 = 12

**Example 2:**

![](https://assets.leetcode.com/uploads/2021/05/29/magicsquare2-grid.jpg)

**Input:** grid = [ [5,1,3,1],[9,3,3,1],[1,3,3,8] ]
**Output:** 2

**Constraints:**

- `m == grid.length`
- `n == grid[i].length`
- `1 <= m, n <= 50`
- `1 <= grid[i][j] <= 10^6`
- `m == grid.length`。
- `n == grid[i].length`。
- `1 <= m, n <= 50`。
- `1 <= grid[i][j] <= 10^6`。

## 解題筆記與程式碼

通用演算法筆記：[prefix_sum](../algorithm/prefix_sum.md)
通用演算法筆記：[fixed_size_subgrid_scan](../algorithm/fixed_size_subgrid_scan.md)
資料結構筆記：[dp_2d_array](../data_structure/dp_2d_array.md)

### 思路拆解

- 魔術方陣條件是「所有列、所有欄、兩條對角線總和相同」，可用前綴和在 `O(1)` 計算每列/欄/對角線總和。
- 為了求最大邊長，從 `k = min(m, n)` 由大到小掃描所有 `k x k` 子矩陣，只要找到第一個合法就能直接回傳。
- 每個子矩陣先檢查兩條對角線，再檢查 `k` 列與 `k` 欄，可快速剪枝。

### 演算法

1. 預處理：
   - `row[r][c+1]`：第 `r` 列的前綴和。
   - `col[r+1][c]`：第 `c` 欄的前綴和。
   - `diag1[r+1][c+1]`：主對角線（右下）前綴和。
   - `diag2[r+1][c]`：副對角線（左下）前綴和。
2. 對 `k` 由大到小：
   - 枚舉左上角 `(r, c)`。
   - 取第一列總和為 `target`，檢查兩條對角線是否等於 `target`。
   - 檢查 `k` 列與 `k` 欄總和是否都等於 `target`。
   - 若全部相等，回傳 `k`。
3. 若沒有更大尺寸，回傳 `1`。

### 時間與空間

- 前綴和建表：`O(mn)`。
- 檢查所有尺寸：`O(\sum_{k=1}^{K}(m-k+1)(n-k+1)k)`，`K = min(m,n)`，`m,n <= 50` 足夠快。
- 空間：`O(mn)` 儲存多個前綴和陣列。

```rust
impl Solution {
    pub fn largest_magic_square(grid: Vec<Vec<i32>>) -> i32 {
        let m = grid.len();
        let n = grid[0].len();
        let mut row = vec![vec![0i64; n + 1]; m];
        let mut col = vec![vec![0i64; n]; m + 1];
        let mut diag1 = vec![vec![0i64; n + 1]; m + 1];
        let mut diag2 = vec![vec![0i64; n + 1]; m + 1];

        for i in 0..m {
            for j in 0..n {
                let v = grid[i][j] as i64;
                row[i][j + 1] = row[i][j] + v;
                col[i + 1][j] = col[i][j] + v;
                diag1[i + 1][j + 1] = diag1[i][j] + v;
            }
        }
        for i in 0..m {
            for j in (0..n).rev() {
                let v = grid[i][j] as i64;
                diag2[i + 1][j] = diag2[i][j + 1] + v;
            }
        }

        let max_k = m.min(n);
        for k in (1..=max_k).rev() {
            for r in 0..=m - k {
                for c in 0..=n - k {
                    let target = row[r][c + k] - row[r][c];
                    let diag_main = diag1[r + k][c + k] - diag1[r][c];
                    if diag_main != target {
                        continue;
                    }
                    let diag_anti = diag2[r + k][c] - diag2[r][c + k];
                    if diag_anti != target {
                        continue;
                    }

                    let mut ok = true;
                    for i in 0..k {
                        let sum = row[r + i][c + k] - row[r + i][c];
                        if sum != target {
                            ok = false;
                            break;
                        }
                    }
                    if !ok {
                        continue;
                    }
                    for j in 0..k {
                        let sum = col[r + k][c + j] - col[r][c + j];
                        if sum != target {
                            ok = false;
                            break;
                        }
                    }
                    if ok {
                        return k as i32;
                    }
                }
            }
        }
        1
    }
}
```
