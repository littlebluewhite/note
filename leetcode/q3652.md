[3652. Best Time to Buy and Sell Stock using Strategy](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-using-strategy/)

Medium

Topics

![premium lock icon](https://leetcode.com/_next/static/images/lock-a6627e2c7fa0ce8bc117c109fb4e567d.svg)Companies

Hint

You are given two integer arrays `prices` and `strategy`, where:
給定兩個整數陣列 `prices` 與 `strategy`，其中：

- `prices[i]` is the price of a given stock on the `ith` day.
- `prices[i]` 為第 `i` 天的股價。
- `strategy[i]` represents a trading action on the `ith` day, where:
- `strategy[i]` 代表第 `i` 天的操作，其中：
    - `-1` indicates buying one unit of the stock.
    - `-1` 代表買入一單位股票。
    - `0` indicates holding the stock.
    - `0` 代表持有不動。
    - `1` indicates selling one unit of the stock.
    - `1` 代表賣出一單位股票。

You are also given an **even** integer `k`, and may perform **at most one** modification to `strategy`. A modification consists of:
另給定一個偶數 `k`，你可以對 `strategy` **最多進行一次** 修改，修改方式為：

- Selecting exactly `k` **consecutive** elements in `strategy`.
- 選擇 `strategy` 中恰好 `k` 個**連續**元素。
- Set the **first** `k / 2` elements to `0` (hold).
- 將其中**前** `k / 2` 個元素設為 `0`（持有）。
- Set the **last** `k / 2` elements to `1` (sell).
- 將**後** `k / 2` 個元素設為 `1`（賣出）。

The **profit** is defined as the **sum** of `strategy[i] * prices[i]` across all days.
總利潤定義為所有天數的 `strategy[i] * prices[i]` 之和。

Return the **maximum** possible profit you can achieve.
請回傳可得到的**最大**利潤。

**Note:** There are no constraints on budget or stock ownership, so all buy and sell operations are feasible regardless of past actions.
**注意：** 不考慮資金或持股限制，因此任何買賣操作皆可行。

**Example 1:**

**Input:** prices = [4,2,8], strategy = [-1,0,1], k = 2

**Output:** 10

**Explanation:**
**說明：**

|Modification|Strategy|Profit Calculation|Profit|
|---|---|---|---|
|Original|[-1, 0, 1]|(-1 × 4) + (0 × 2) + (1 × 8) = -4 + 0 + 8|4|
|Modify [0, 1]|[0, 1, 1]|(0 × 4) + (1 × 2) + (1 × 8) = 0 + 2 + 8|10|
|Modify [1, 2]|[-1, 0, 1]|(-1 × 4) + (0 × 2) + (1 × 8) = -4 + 0 + 8|4|

Thus, the maximum possible profit is 10, which is achieved by modifying the subarray `[0, 1]`​​​​​​​.
因此最大利潤為 10，可透過修改子陣列 `[0, 1]` 達成。

**Example 2:**

**Input:** prices = [5,4,3], strategy = [1,1,0], k = 2

**Output:** 9

**Explanation:**
**說明：**

|Modification|Strategy|Profit Calculation|Profit|
|---|---|---|---|
|Original|[1, 1, 0]|(1 × 5) + (1 × 4) + (0 × 3) = 5 + 4 + 0|9|
|Modify [0, 1]|[0, 1, 0]|(0 × 5) + (1 × 4) + (0 × 3) = 0 + 4 + 0|4|
|Modify [1, 2]|[1, 0, 1]|(1 × 5) + (0 × 4) + (1 × 3) = 5 + 0 + 3|8|

Thus, the maximum possible profit is 9, which is achieved without any modification.
因此最大利潤為 9，不需任何修改。

**Constraints:**

- `2 <= prices.length == strategy.length <= 10^5`
- `2 <= prices.length == strategy.length <= 10^5`
- `1 <= prices[i] <= 10^5`
- `1 <= prices[i] <= 10^5`
- `-1 <= strategy[i] <= 1`
- `-1 <= strategy[i] <= 1`
- `2 <= k <= prices.length`
- `2 <= k <= prices.length`
- `k` is even
- `k` 為偶數

## 解題筆記與程式碼

通用演算法筆記：[prefix_sum](../algorithm/prefix_sum.md)
通用演算法筆記：[sliding_window](../algorithm/sliding_window.md)

### 核心觀察

- 修改一段長度 `k` 的子陣列，前半被改成 0、後半改成 1；利潤變化只取決於該區間內原本的 `strategy[i]*prices[i]` 與後半段的價格總和。
- 對起點為 `l` 的區間，`delta = -Σ_{window}(strategy[i]*price[i]) + Σ_{second half}(price[i])`。
- 以 prefix sum O(1) 取得上述兩個求和，掃描所有 `l` 取最大增益 `max_delta`，答案為 `base_profit + max(0, max_delta)`。

### 時間與空間

- 時間：O(n) 前綴和後單次掃描。
- 空間：O(n) 儲存前綴和。

```rust
impl Solution {
    pub fn max_profit(prices: Vec<i32>, strategy: Vec<i32>, k: i32) -> i64 {
        let n = prices.len();
        let k = k as usize;
        let half = k / 2;

        let mut prefix_sp = vec![0i64; n + 1]; // prefix of strategy[i] * prices[i]
        let mut prefix_p = vec![0i64; n + 1];  // prefix of prices[i]
        let mut base: i64 = 0;

        for i in 0..n {
            let sp = strategy[i] as i64 * prices[i] as i64;
            base += sp;
            prefix_sp[i + 1] = prefix_sp[i] + sp;
            prefix_p[i + 1] = prefix_p[i] + prices[i] as i64;
        }

        let mut max_delta: i64 = 0;
        for l in 0..=n - k {
            let sum_sp = prefix_sp[l + k] - prefix_sp[l];
            let sum_second_half_prices = prefix_p[l + k] - prefix_p[l + half];
            let delta = -sum_sp + sum_second_half_prices;
            if delta > max_delta {
                max_delta = delta;
            }
        }

        base + max_delta
    }
}
```


## 補充筆記：O(n) 儲存前綴和。

### 注意事項

- 需以 64 位整數避免 `10^5 * 10^5` 累積溢位。
- `k` 為偶數，後半起點為 `l + k/2`，包含 `k/2` 個元素。
