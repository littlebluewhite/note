---
title: "q2976"
category: leetcode
tags: [leetcode]
created: 2026-02-03
updated: 2026-02-03
difficulty: Medium
source: leetcode
status: active
complexity_time: O(26^3 + n)
complexity_space: O(26^2)
---
[2976. Minimum Cost to Convert String I](https://leetcode.com/problems/minimum-cost-to-convert-string-i/)

Medium

Topics

![premium lock icon](https://leetcode.com/_next/static/images/lock-a6627e2c7fa0ce8bc117c109fb4e567d.svg)Companies

Hint

You are given two **0-indexed** strings `source` and `target`, both of length `n` and consisting of **lowercase** English letters. You are also given two **0-indexed** character arrays `original` and `changed`, and an integer array `cost`, where `cost[i]` represents the cost of changing the character `original[i]` to the character `changed[i]`.
給定兩個 **0-indexed** 字串 `source` 與 `target`，長度皆為 `n`，且都由 **小寫** 英文字母組成。另給定兩個 **0-indexed** 字元陣列 `original` 與 `changed`，以及整數陣列 `cost`，其中 `cost[i]` 表示將字元 `original[i]` 變成 `changed[i]` 的成本。

You start with the string `source`. In one operation, you can pick a character `x` from the string and change it to the character `y` at a cost of `z` **if** there exists **any** index `j` such that `cost[j] == z`, `original[j] == x`, and `changed[j] == y`.
你從字串 `source` 開始。一次操作中，可以選一個字元 `x` 把它改成字元 `y`，成本為 `z`，**前提是** 存在 **任意** 索引 `j` 使得 `cost[j] == z`、`original[j] == x` 且 `changed[j] == y`。

Return _the **minimum** cost to convert the string_ `source` _to the string_ `target` _using **any** number of operations. If it is impossible to convert_ `source` _to_ `target`, _return_ `-1`.
請回傳把字串 `source` 轉換成字串 `target` 的 **最小** 總成本（允許 **任意** 次操作）。若不可能從 `source` 轉換成 `target`，回傳 `-1`。

**Note** that there may exist indices `i`, `j` such that `original[j] == original[i]` and `changed[j] == changed[i]`.
**注意**：可能存在索引 `i`, `j` 使得 `original[j] == original[i]` 且 `changed[j] == changed[i]`（同一對轉換可能有多筆成本）。

**Example 1:**

**Input:** source = "abcd", target = "acbe", original = ["a","b","c","c","e","d"], changed = ["b","c","b","e","b","e"], cost = [2,5,5,1,2,20]
**Output:** 28
**Explanation:** To convert the string "abcd" to string "acbe":
- Change value at index 1 from 'b' to 'c' at a cost of 5.
- Change value at index 2 from 'c' to 'e' at a cost of 1.
- Change value at index 2 from 'e' to 'b' at a cost of 2.
- Change value at index 3 from 'd' to 'e' at a cost of 20.
The total cost incurred is 5 + 1 + 2 + 20 = 28.
It can be shown that this is the minimum possible cost.

**範例 1：**

**輸入：** source = "abcd", target = "acbe", original = ["a","b","c","c","e","d"], changed = ["b","c","b","e","b","e"], cost = [2,5,5,1,2,20]
**輸出：** 28
**解釋：** 將 "abcd" 轉換成 "acbe"：
- 索引 1 的字元由 'b' 變 'c'，成本 5。
- 索引 2 的字元由 'c' 變 'e'，成本 1。
- 索引 2 的字元由 'e' 變 'b'，成本 2。
- 索引 3 的字元由 'd' 變 'e'，成本 20。
總成本為 5 + 1 + 2 + 20 = 28。
可證明這是最小成本。

**Example 2:**

**Input:** source = "aaaa", target = "bbbb", original = ["a","c"], changed = ["c","b"], cost = [1,2]
**Output:** 12
**Explanation:** To change the character 'a' to 'b' change the character 'a' to 'c' at a cost of 1, followed by changing the character 'c' to 'b' at a cost of 2, for a total cost of 1 + 2 = 3. To change all occurrences of 'a' to 'b', a total cost of 3 * 4 = 12 is incurred.

**範例 2：**

**輸入：** source = "aaaa", target = "bbbb", original = ["a","c"], changed = ["c","b"], cost = [1,2]
**輸出：** 12
**解釋：** 將 'a' 變成 'b' 可先把 'a' 變成 'c'（成本 1），再把 'c' 變成 'b'（成本 2），總成本為 3。把所有 'a' 轉成 'b'，總成本為 3 * 4 = 12。

**Example 3:**

**Input:** source = "abcd", target = "abce", original = ["a"], changed = ["e"], cost = [10000]
**Output:** -1
**Explanation:** It is impossible to convert source to target because the value at index 3 cannot be changed from 'd' to 'e'.

**範例 3：**

**輸入：** source = "abcd", target = "abce", original = ["a"], changed = ["e"], cost = [10000]
**輸出：** -1
**解釋：** 無法從 source 轉成 target，因為索引 3 的字元無法由 'd' 變成 'e'。

**Constraints:**

- `1 <= source.length == target.length <= 105`
- `source`, `target` consist of lowercase English letters.
- `1 <= cost.length == original.length == changed.length <= 2000`
- `original[i]`, `changed[i]` are lowercase English letters.
- `1 <= cost[i] <= 106`
- `original[i] != changed[i]`
- `1 <= source.length == target.length <= 10^5`
- `source`, `target` 由小寫英文字母組成。
- `1 <= cost.length == original.length == changed.length <= 2000`
- `original[i]`, `changed[i]` 為小寫英文字母。
- `1 <= cost[i] <= 10^6`
- `original[i] != changed[i]`

## 解題筆記與程式碼

通用演算法筆記：[floyd_warshall_all_pairs_shortest_path](../algorithm/floyd_warshall_all_pairs_shortest_path.md)
資料結構筆記：[weighted_graph](../data_structure/weighted_graph.md)
資料結構筆記：[dp_2d_array](../data_structure/dp_2d_array.md)

### 思路拆解

- 把 26 個字母視為 26 個節點，`original[i] -> changed[i]` 是一條有向邊，邊權為 `cost[i]`，同一對轉換保留最小成本。
- 允許多次轉換，等價於求任兩字母間的最短路徑成本。
- 字母數量固定為 26，因此用 Floyd-Warshall 做全點對最短路徑最簡潔。
- 最後遍歷 `source` 與 `target` 的每個位置：若字元不同，累加 `dist[u][v]`，若不可達則回傳 `-1`。

### 為什麼選 Floyd-Warshall

- 節點數固定 26，`O(26^3)` 近乎常數，簡單可靠。
- 需要「任意字母對」的最小轉換成本，Floyd-Warshall 正好輸出全點對結果。

### 演算法

1. 建立 `26 x 26` 距離矩陣 `dist`，初始化為 `INF`，並令 `dist[i][i] = 0`。
2. 對每條轉換規則 `(u, v, c)`，更新 `dist[u][v] = min(dist[u][v], c)`。
3. 以 Floyd-Warshall 更新所有字母對的最短路徑：
   - `dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])`。
4. 逐字比較 `source[i]` 與 `target[i]`：
   - 若相同，略過；
   - 若 `dist[u][v]` 為 `INF`，回傳 `-1`；
   - 否則累加成本。

### 時間與空間

- 時間：`O(26^3 + n)`。
- 空間：`O(26^2)`。

```rust
impl Solution {
    pub fn minimum_cost(
        source: String,
        target: String,
        original: Vec<char>,
        changed: Vec<char>,
        cost: Vec<i32>,
    ) -> i64 {
        const INF: i64 = i64::MAX / 4;
        let mut dist = vec![vec![INF; 26]; 26];
        for i in 0..26 {
            dist[i][i] = 0;
        }

        for i in 0..cost.len() {
            let u = (original[i] as u8 - b'a') as usize;
            let v = (changed[i] as u8 - b'a') as usize;
            let w = cost[i] as i64;
            if w < dist[u][v] {
                dist[u][v] = w;
            }
        }

        for k in 0..26 {
            for i in 0..26 {
                let dik = dist[i][k];
                if dik == INF {
                    continue;
                }
                for j in 0..26 {
                    let dkj = dist[k][j];
                    if dkj == INF {
                        continue;
                    }
                    let nd = dik + dkj;
                    if nd < dist[i][j] {
                        dist[i][j] = nd;
                    }
                }
            }
        }

        let s = source.as_bytes();
        let t = target.as_bytes();
        let mut ans: i64 = 0;
        for i in 0..s.len() {
            if s[i] == t[i] {
                continue;
            }
            let u = (s[i] - b'a') as usize;
            let v = (t[i] - b'a') as usize;
            let d = dist[u][v];
            if d == INF {
                return -1;
            }
            ans += d;
        }
        ans
    }
}
```
