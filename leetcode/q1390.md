[1390. Four Divisors](https://leetcode.com/problems/four-divisors/)

Medium

Topics

![premium lock icon](https://leetcode.com/_next/static/images/lock-a6627e2c7fa0ce8bc117c109fb4e567d.svg)Companies

Hint

Given an integer array `nums`, return _the sum of divisors of the integers in that array that have exactly four divisors_. If there is no such integer in the array, return `0`.
給定整數陣列 `nums`，請回傳陣列中「剛好有四個因數」的元素，其所有因數總和之加總。若沒有符合的元素，回傳 `0`。

**Example 1:**

**Input:** nums = [21,4,7]
**輸入：** nums = [21,4,7]
**Output:** 32
**輸出：** 32
**Explanation:** 
**說明：**
21 has 4 divisors: 1, 3, 7, 21
21 有 4 個因數：1, 3, 7, 21
4 has 3 divisors: 1, 2, 4
4 有 3 個因數：1, 2, 4
7 has 2 divisors: 1, 7
7 有 2 個因數：1, 7
The answer is the sum of divisors of 21 only.
答案只取 21 的因數總和。

**Example 2:**

**Input:** nums = [21,21]
**輸入：** nums = [21,21]
**Output:** 64
**輸出：** 64

**Example 3:**

**Input:** nums = [1,2,3,4,5]
**輸入：** nums = [1,2,3,4,5]
**Output:** 0
**輸出：** 0

**Constraints:**

- `1 <= nums.length <= 10^4`
- `1 <= nums[i] <= 10^5`
- `1 <= nums.length <= 10^4`。
- `1 <= nums[i] <= 10^5`。

## 解題筆記與程式碼

通用演算法筆記：[divisor_enumeration_sqrt](../algorithm/divisor_enumeration_sqrt.md)

### 思路拆解

- 對每個 `n`，用「根號枚舉因數」找出所有因數的配對 `(i, n / i)`，同時累計因數個數與總和。
- 若因數數量超過 4 就可提早停止，避免多餘計算。
- 最後只有因數數量剛好為 4 的數字，其因數總和才會加進答案。

### 演算法

1. 對 `nums` 每個元素 `n`：
2. `i` 從 `1` 掃到 `floor(sqrt(n))`：
   - 若 `n % i == 0`，因數包含 `i` 與 `n / i`（同一個則只算一次）。
   - 更新因數數量與總和；若數量 > 4，直接回傳 0。
3. 若最終因數數量等於 4，回傳總和；否則回傳 0。
4. 將所有元素的回傳值加總即為答案。

### 時間與空間

- 時間：`O(len(nums) * sqrt(max(nums)))`
- 空間：`O(1)`

```rust
impl Solution {
    pub fn sum_four_divisors(nums: Vec<i32>) -> i32 {
        fn sum_if_four_divisors(n: i32) -> i32 {
            let n = n as i64;
            let mut count = 0;
            let mut sum = 0i64;
            let mut i = 1i64;
            while i * i <= n {
                if n % i == 0 {
                    let j = n / i;
                    if i == j {
                        count += 1;
                        sum += i;
                    } else {
                        count += 2;
                        sum += i + j;
                    }
                    if count > 4 {
                        return 0;
                    }
                }
                i += 1;
            }
            if count == 4 { sum as i32 } else { 0 }
        }

        let mut total = 0i32;
        for n in nums {
            total += sum_if_four_divisors(n);
        }
        total
    }
}
```

## 實作細節

- 使用 `i * i <= n` 進行根號枚舉，避免重複計算配對。
- 因數數量一旦超過 4 就提前返回，效率更好。
- 內部使用 `i64` 累計總和，最後再轉回 `i32`。
