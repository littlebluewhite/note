[3454. Separate Squares II](https://leetcode.com/problems/separate-squares-ii/)

Hard

Topics

![premium lock icon](https://leetcode.com/_next/static/images/lock-a6627e2c7fa0ce8bc117c109fb4e567d.svg)Companies

Hint

You are given a 2D integer array `squares`. Each `squares[i] = [xi, yi, li]` represents the coordinates of the bottom-left point and the side length of a square parallel to the x-axis.
給定二維整數陣列 `squares`，每個 `squares[i] = [xi, yi, li]` 代表與 x 軸平行的正方形，其左下角座標為 `(xi, yi)`，邊長為 `li`。

Find the **minimum** y-coordinate value of a horizontal line such that the total area covered by squares above the line _equals_ the total area covered by squares below the line.
請找出一條水平線的 **最小** y 座標，使線上方與線下方的正方形覆蓋總面積 _相等_。

Answers within `10^-5` of the actual answer will be accepted.
答案在實際值的 `10^-5` 誤差內都會被接受。

**Note**: Squares **may** overlap. Overlapping areas should be counted **only once** in this version.
**注意**：正方形 **可能** 重疊，本題中重疊區域只計算 **一次**。

**Example 1:**

**Input:** squares = [ [0,0,1],[2,2,1] ]

**Output:** 1.00000

**Explanation:**

![](https://assets.leetcode.com/uploads/2025/01/15/4065example1drawio.png)

Any horizontal line between `y = 1` and `y = 2` results in an equal split, with 1 square unit above and 1 square unit below. The minimum y-value is 1.
任何介於 `y = 1` 與 `y = 2` 的水平線，線上線下各 1 單位面積，最小可行答案是 1。

**Example 2:**

**Input:** squares = [ [0,0,2],[1,1,1] ]

**Output:** 1.00000

**Explanation:**

![](https://assets.leetcode.com/uploads/2025/01/15/4065example2drawio.png)

Since the blue square overlaps with the red square, it will not be counted again. Thus, the line `y = 1` splits the squares into two equal parts.
藍色正方形與紅色正方形重疊的區域只算一次，因此 `y = 1` 能將面積等分。

**Constraints:**

- `1 <= squares.length <= 5 * 10^4`
- `squares[i] = [xi, yi, li]`
- `squares[i].length == 3`
- `0 <= xi, yi <= 10^9`
- `1 <= li <= 10^9`
- The total area of all the squares will not exceed `10^15`.
- `1 <= squares.length <= 5 * 10^4`。
- `squares[i] = [xi, yi, li]`。
- `squares[i].length == 3`。
- `0 <= xi, yi <= 10^9`。
- `1 <= li <= 10^9`。
- 所有正方形的總面積不超過 `10^15`。

## 解題筆記與程式碼

通用演算法筆記：[scanline_union_area_segment_tree](../algorithm/scanline_union_area_segment_tree.md)
通用演算法筆記：[piecewise_linear_sweep](../algorithm/piecewise_linear_sweep.md)
通用演算法筆記：[coordinate_compression](../algorithm/coordinate_compression.md)
資料結構筆記：[segment_tree_lazy](../data_structure/segment_tree_lazy.md)

### 思路拆解

- 重疊區域只能算一次，因此每條水平切片的面積要用「x 方向聯集寬度 × 高度」。
- 以掃描線沿 `y` 軸由下往上，遇到底邊 `+1`、頂邊 `-1` 更新活躍區間。
- 由於 `x` 座標範圍很大，要先做座標壓縮，用線段樹維護聯集長度。
- 相鄰事件高度之間寬度固定，面積函數是分段線性；先掃描得到總面積，再在記錄的區間中線性插值找最小 `y`。

### 演算法

1. 對每個正方形建立事件 `(y, x1, x2, +1)` 與 `(y + l, x1, x2, -1)`，收集所有 `x` 端點。
2. 對 `x` 端點排序去重，建立線段樹（儲存覆蓋次數與覆蓋長度）。
3. 事件依 `y` 排序，掃描相鄰高度區間：
   - 先取目前聯集寬度 `width`，累積面積 `area += width * (cur_y - prev_y)`。
   - 記錄 `(y_start, y_end, start_area, width)`。
   - 再處理同一個 `y` 的事件更新線段樹。
4. 總面積 `total_area` 得到後，目標面積 `target = total_area / 2`。
5. 找到 `target` 落在的區間，用 `y = y_start + (target - start_area) / width` 計算最小 `y`。

### 時間與空間

- 時間：`O(n log n)`，排序與線段樹更新。
- 空間：`O(n)`，事件、座標與線段樹。

### Code Walkthrough / 程式詳解

- `Event`: 每個 `y` 邊界的變化，`delta=+1/-1` 代表新增/移除覆蓋。
- `SweepSegment`: 記錄一段高度區間的「起始面積、寬度」，方便最後做線性插值找最小 `y`。
- `SegmentTree`:
  - `xs` 是離散化後的 x 端點，葉子對應 `[xs[i], xs[i+1])`。
  - `count[idx]` 是節點區間的覆蓋次數；`tree[idx]` 是該區間的聯集長度。
  - `update`：對 `[ql, qr)` 做區間加，若 `count>0` 則整段覆蓋，否則由子節點合併。
  - `query`：回傳根節點的總覆蓋長度。
- `separate_squares`:
  1. 建事件與 `xs`，用 `i64` 避免座標溢位。
  2. 事件依 `y` 排序、`xs` 排序去重後建樹。
  3. 掃描時，先用當前 `width` 算上個高度段的面積，再處理同一個 `y` 的事件更新。
  4. `segments` 紀錄每一段 `(y_start, y_end, start_area, width)`。
  5. 算出 `target=total_area/2`，在 `segments` 中定位並用 `dy=(target-start_area)/width` 插值。

### Common Mistakes / 常見錯誤

- 用閉區間 `[x1, x2]` 造成重複計算邊界長度，應使用半開區間 `[x1, x2)`。
- 先更新事件再累積面積，會把當前 `y` 的覆蓋算到上一段高度，導致面積偏移。
- 不做 `xs` 去重或離散化，會導致零長度區間或無法在大座標上運算。
- 以 `i32` 存座標或面積，可能溢位（座標與面積上限很大）。
- 忘記處理 `width=0` 的區段，插值時會除以 0。

### Annotated Minimal Code / 註解分段精簡版

```rust
// 1) Events + compression: 每個正方形提供兩個 y 邊界事件
struct Event {
    y: i64,
    x1: i64,
    x2: i64,
    delta: i32, // +1 add, -1 remove
}

impl Event {
    fn new(y: i64, x1: i64, x2: i64, delta: i32) -> Self {
        Event { y, x1, x2, delta }
    }
}

struct SweepSegment {
    y_start: f64,
    y_end: f64,
    start_area: f64,
    width: f64,
}

impl SweepSegment {
    fn new(y_start: f64, y_end: f64, start_area: f64, width: f64) -> Self {
        SweepSegment {
            y_start,
            y_end,
            start_area,
            width,
        }
    }
}

// 2) Segment tree: count 表示覆蓋次數，len 表示聯集長度
struct SegmentTree {
    n: usize,
    tree: Vec<f64>,
    count: Vec<i32>,
    xs: Vec<i64>,
}

impl SegmentTree {
    fn new(xs: Vec<i64>) -> Self {
        let n = xs.len() - 1;
        // 4 * n is a safe upper bound for a binary segment tree array.
        let size = 4 * xs.len().max(1);
        SegmentTree {
            n,
            tree: vec![0.0; size],
            count: vec![0; size],
            xs,
        }
    }

    fn update(&mut self, idx: usize, l: usize, r: usize, ql: usize, qr: usize, delta: i32) {
        if qr <= l || ql >= r {
            return;
        }
        if ql <= l && r <= qr {
            self.count[idx] += delta;
        } else {
            let mid = (l + r) / 2;
            self.update(idx * 2, l, mid, ql, qr, delta);
            self.update(idx * 2 + 1, mid, r, ql, qr, delta);
        }

        // count > 0 -> full cover, else merge children
        if self.count[idx] > 0 {
            self.tree[idx] = (self.xs[r] - self.xs[l]) as f64;
        } else if r - l == 1 {
            self.tree[idx] = 0.0;
        } else {
            self.tree[idx] = self.tree[idx * 2] + self.tree[idx * 2 + 1];
        }
    }

    fn query(&self) -> f64 {
        self.tree[1]
    }
}

pub fn separate_squares(squares: Vec<Vec<i32>>) -> f64 {
    // Build events + xs
    let mut events: Vec<Event> = Vec::with_capacity(squares.len() * 2);
    let mut xs: Vec<i64> = Vec::with_capacity(squares.len() * 2);
    for sq in squares {
        let x = sq[0] as i64;
        let y = sq[1] as i64;
        let l = sq[2] as i64;
        events.push(Event::new(y, x, x + l, 1));
        events.push(Event::new(y + l, x, x + l, -1));
        xs.push(x);
        xs.push(x + l);
    }

    // Sort + dedup
    events.sort_by_key(|e| e.y);
    xs.sort();
    xs.dedup();

    // Sweep by y: width is constant between consecutive events
    let mut st = SegmentTree::new(xs.clone());
    let mut segments: Vec<SweepSegment> = Vec::new();
    let mut total_area = 0.0;
    let mut i = 0usize;
    let mut prev_y = events[0].y;

    while i < events.len() {
        let cur_y = events[i].y;
        if cur_y > prev_y {
            let width = st.query();
            let dy = (cur_y - prev_y) as f64;
            segments.push(SweepSegment::new(
                prev_y as f64,
                cur_y as f64,
                total_area,
                width,
            ));
            total_area += width * dy;
        }
        while i < events.len() && events[i].y == cur_y {
            let l = xs.binary_search(&events[i].x1).unwrap();
            let r = xs.binary_search(&events[i].x2).unwrap();
            st.update(1, 0, st.n, l, r, events[i].delta);
            i += 1;
        }
        prev_y = cur_y;
    }

    // Interpolate to find minimum y where area reaches total_area/2
    let target = total_area / 2.0;
    for seg in segments {
        let seg_area = seg.width * (seg.y_end - seg.y_start);
        if target <= seg.start_area + seg_area {
            return if seg.width == 0.0 {
                seg.y_start
            } else {
                seg.y_start + (target - seg.start_area) / seg.width
            };
        }
    }
    prev_y as f64
}
```

### Full Code / 完整程式

```rust
struct Event {
    y: i64,
    x1: i64,
    x2: i64,
    delta: i32,
}

impl Event {
    fn new(y: i64, x1: i64, x2: i64, delta: i32) -> Self {
        Event { y, x1, x2, delta }
    }
}

struct SweepSegment {
    y_start: f64,
    y_end: f64,
    start_area: f64,
    width: f64,
}

impl SweepSegment {
    fn new(y_start: f64, y_end: f64, start_area: f64, width: f64) -> Self {
        SweepSegment {
            y_start,
            y_end,
            start_area,
            width,
        }
    }
}

struct SegmentTree {
    n: usize,
    tree: Vec<f64>,
    count: Vec<i32>,
    xs: Vec<i64>,
}

impl SegmentTree {
    fn new(xs: Vec<i64>) -> Self {
        let n = xs.len() - 1;
        // 4 * n is a safe upper bound for a binary segment tree array.
        let size = 4 * xs.len().max(1);
        SegmentTree {
            n,
            tree: vec![0.0; size],
            count: vec![0; size],
            xs,
        }
    }

    fn update(&mut self, idx: usize, l: usize, r: usize, ql: usize, qr: usize, delta: i32) {
        if qr <= l || ql >= r {
            return;
        }
        if ql <= l && r <= qr {
            self.count[idx] += delta;
        } else {
            let mid = (l + r) / 2;
            self.update(idx * 2, l, mid, ql, qr, delta);
            self.update(idx * 2 + 1, mid, r, ql, qr, delta);
        }

        if self.count[idx] > 0 {
            // Fully covered: length equals the whole segment size.
            self.tree[idx] = (self.xs[r] - self.xs[l]) as f64;
        } else if r - l == 1 {
            // Leaf with no coverage.
            self.tree[idx] = 0.0;
        } else {
            // Merge children coverage.
            self.tree[idx] = self.tree[idx * 2] + self.tree[idx * 2 + 1];
        }
    }

    fn query(&self) -> f64 {
        self.tree[1]
    }
}

impl Solution {
    pub fn separate_squares(squares: Vec<Vec<i32>>) -> f64 {
        let mut events: Vec<Event> = Vec::with_capacity(squares.len() * 2);
        let mut xs: Vec<i64> = Vec::with_capacity(squares.len() * 2);

        for sq in squares {
            let x = sq[0] as i64;
            let y = sq[1] as i64;
            let l = sq[2] as i64;
            let x2 = x + l;
            let y2 = y + l;
            events.push(Event::new(y, x, x2, 1));
            events.push(Event::new(y2, x, x2, -1));
            xs.push(x);
            xs.push(x2);
        }

        events.sort_by_key(|e| e.y);
        xs.sort();
        xs.dedup();

        let mut st = SegmentTree::new(xs.clone());
        let mut total_area = 0.0f64;
        let mut segments: Vec<SweepSegment> = Vec::new();

        let mut i = 0usize;
        let mut prev_y = events[0].y;
        while i < events.len() {
            let cur_y = events[i].y;
            if cur_y > prev_y {
                let width = st.query();
                let dy = (cur_y - prev_y) as f64;
                let seg_area = width * dy;
                // Store strip data for later interpolation.
                segments.push(SweepSegment::new(
                    prev_y as f64,
                    cur_y as f64,
                    total_area,
                    width,
                ));
                total_area += seg_area;
            }

            while i < events.len() && events[i].y == cur_y {
                let l = xs.binary_search(&events[i].x1).unwrap();
                let r = xs.binary_search(&events[i].x2).unwrap();
                // Update covered x-range for this y boundary.
                st.update(1, 0, st.n, l, r, events[i].delta);
                i += 1;
            }

            prev_y = cur_y;
        }

        let target = total_area / 2.0;
        for seg in segments {
            let seg_area = seg.width * (seg.y_end - seg.y_start);
            if target <= seg.start_area + seg_area {
                if seg.width == 0.0 {
                    // No coverage in this strip; any y inside is equivalent.
                    return seg.y_start;
                }
                let dy = (target - seg.start_area) / seg.width;
                return seg.y_start + dy;
            }
        }

        prev_y as f64
    }
}
```
