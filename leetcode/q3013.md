[3013. Divide an Array Into Subarrays With Minimum Cost II](https://leetcode.com/problems/divide-an-array-into-subarrays-with-minimum-cost-ii/)

Hard

Topics

![premium lock icon](https://leetcode.com/_next/static/images/lock-a6627e2c7fa0ce8bc117c109fb4e567d.svg)Companies

Hint

You are given a **0-indexed** array of integers `nums` of length `n`, and two **positive** integers `k` and `dist`.
給定長度為 `n` 的 **0-indexed** 整數陣列 `nums`，以及兩個 **正整數** `k` 與 `dist`。

The **cost** of an array is the value of its **first** element. For example, the cost of `[1,2,3]` is `1` while the cost of `[3,4,1]` is `3`.
陣列的 **成本** 定義為其 **第一個** 元素的值。例如 `[1,2,3]` 的成本是 `1`，而 `[3,4,1]` 的成本是 `3`。

You need to divide `nums` into `k` **disjoint contiguous** subarrays, such that the difference between the starting index of the **second** subarray and the starting index of the `k`th subarray should be **less than or equal to** `dist`. In other words, if you divide `nums` into the subarrays `nums[0..(i1 - 1)], nums[i1..(i2 - 1)], ..., nums[ik-1..(n - 1)]`, then `ik-1 - i1 <= dist`.
你需要把 `nums` 分成 `k` 個 **互不重疊且連續** 的子陣列，且「第二個子陣列起點」與「第 `k` 個子陣列起點」的差距必須 **小於等於** `dist`。換句話說，若切分成 `nums[0..(i1 - 1)], nums[i1..(i2 - 1)], ..., nums[ik-1..(n - 1)]`，則必須滿足 `ik-1 - i1 <= dist`。

Return _the **minimum** possible sum of the cost of these_ _subarrays_.
請回傳這些子陣列成本總和的 **最小值**。

**Example 1:**

**Input:** nums = [1,3,2,6,4,2], k = 3, dist = 3
**Output:** 5
**Explanation:** The best possible way to divide nums into 3 subarrays is: [1,3], [2,6,4], and [2]. This choice is valid because ik-1 - i1 is 5 - 2 = 3 which is equal to dist. The total cost is nums[0] + nums[2] + nums[5] which is 1 + 2 + 2 = 5. It can be shown that there is no possible way to divide nums into 3 subarrays at a cost lower than 5.
最佳的切法是 [1,3]、[2,6,4]、[2]。此選擇有效，因為 `ik-1 - i1 = 5 - 2 = 3`，剛好等於 `dist`。總成本為 `nums[0] + nums[2] + nums[5] = 1 + 2 + 2 = 5`。可證明不存在成本低於 5 的 3 分割方式。

**Example 2:**

**Input:** nums = [10,1,2,2,2,1], k = 4, dist = 3
**Output:** 15
**Explanation:** The best possible way to divide nums into 4 subarrays is: [10], [1], [2], and [2,2,1]. This choice is valid because ik-1 - i1 is 3 - 1 = 2 which is less than dist. The total cost is nums[0] + nums[1] + nums[2] + nums[3] which is 10 + 1 + 2 + 2 = 15. The division [10], [1], [2,2,2], and [1] is not valid, because the difference between ik-1 and i1 is 5 - 1 = 4, which is greater than dist. It can be shown that there is no possible way to divide nums into 4 subarrays at a cost lower than 15.
最佳切法是 [10]、[1]、[2]、[2,2,1]。此選擇有效，因為 `ik-1 - i1 = 3 - 1 = 2`，小於 `dist`。總成本為 `nums[0] + nums[1] + nums[2] + nums[3] = 10 + 1 + 2 + 2 = 15`。分割 [10]、[1]、[2,2,2]、[1] 無效，因為 `ik-1 - i1 = 5 - 1 = 4` 大於 `dist`。可證明不存在成本低於 15 的 4 分割方式。

**Example 3:**

**Input:** nums = [10,8,18,9], k = 3, dist = 1
**Output:** 36
**Explanation:** The best possible way to divide nums into 3 subarrays is: [10], [8], and [18,9]. This choice is valid because ik-1 - i1 is 2 - 1 = 1 which is equal to dist. The total cost is nums[0] + nums[1] + nums[2] which is 10 + 8 + 18 = 36. The division [10], [8,18], and [9] is not valid, because the difference between ik-1 and i1 is 3 - 1 = 2, which is greater than dist. It can be shown that there is no possible way to divide nums into 3 subarrays at a cost lower than 36.
最佳切法是 [10]、[8]、[18,9]。此選擇有效，因為 `ik-1 - i1 = 2 - 1 = 1`，等於 `dist`。總成本為 `nums[0] + nums[1] + nums[2] = 10 + 8 + 18 = 36`。分割 [10]、[8,18]、[9] 無效，因為 `ik-1 - i1 = 3 - 1 = 2` 大於 `dist`。可證明不存在成本低於 36 的 3 分割方式。

**Constraints:**

- `3 <= n <= 105`
- `1 <= nums[i] <= 109`
- `3 <= k <= n`
- `k - 2 <= dist <= n - 2`
- `3 <= n <= 10^5`。
- `1 <= nums[i] <= 10^9`。
- `3 <= k <= n`。
- `k - 2 <= dist <= n - 2`。

## 解題筆記與程式碼

通用演算法筆記：[sliding_window_k_smallest_sum](../algorithm/sliding_window_k_smallest_sum.md)
資料結構筆記：[ordered_multiset_btreemap](../data_structure/ordered_multiset_btreemap.md)

### 思路拆解

- 第一個子陣列起點必為 `0`，成本固定是 `nums[0]`。
- 一旦選定其他 `k-1` 個起點（索引遞增），切分就唯一確定；因此問題轉成「挑選起點的最小總和」。
- 固定最後一段起點為 `i`（第 `k` 段），條件 `i - i1 <= dist` 代表第二段起點 `i1 >= i - dist`。
- 因此在區間 `[max(1, i - dist), i - 1]` 中挑出 `k-2` 個起點，且要讓 `nums` 值總和最小；也就是「取該視窗內最小的 `k-2` 個數」。

### 為什麼是滑動視窗

- 當 `i` 往右移 1，候選起點視窗只會：
  - 可能移出 `i - dist - 1`（若 > 0）
  - 新增 `i - 1`
- 需要動態維護「視窗內最小 `k-2` 個值的總和」。

### 演算法（兩個有序 multiset）

- 維護兩個有序 multiset：
  - `st1`：視窗內最小的 `k-2` 個值
  - `st2`：其餘值
- 另維護 `st1` 的總和 `sum`。
- 每次加入或刪除後，透過調整讓 `st1` 大小恆為 `k-2`：
  - `st1` 太小：從 `st2` 拿最小值補進來
  - `st1` 太大：把 `st1` 的最大值丟到 `st2`
- 對每個 `i`，候選最小成本為 `nums[0] + sum + nums[i]`。

### 複雜度

- 時間：`O(n log n)`（每次插入/刪除/調整為 `log n`）。
- 空間：`O(n)`（兩個 multiset 的總大小）。

```rust
use std::collections::BTreeMap;

struct Container {
    k: usize,
    st1: BTreeMap<i32, i32>,
    st2: BTreeMap<i32, i32>,
    sum: i64,
    st1_size: usize,
    st2_size: usize,
}

impl Container {
    fn new(k: usize) -> Self {
        Self {
            k,
            st1: BTreeMap::new(),
            st2: BTreeMap::new(),
            sum: 0,
            st1_size: 0,
            st2_size: 0,
        }
    }

    fn add_one(map: &mut BTreeMap<i32, i32>, key: i32) {
        *map.entry(key).or_insert(0) += 1;
    }

    fn remove_one(map: &mut BTreeMap<i32, i32>, key: i32) -> bool {
        if let Some(count) = map.get_mut(&key) {
            *count -= 1;
            if *count == 0 {
                map.remove(&key);
            }
            true
        } else {
            false
        }
    }

    fn first_key(map: &BTreeMap<i32, i32>) -> Option<i32> {
        map.keys().next().copied()
    }

    fn last_key(map: &BTreeMap<i32, i32>) -> Option<i32> {
        map.keys().next_back().copied()
    }

    fn adjust(&mut self) {
        while self.st1_size < self.k && !self.st2.is_empty() {
            if let Some(x) = Self::first_key(&self.st2) {
                Self::add_one(&mut self.st1, x);
                Self::remove_one(&mut self.st2, x);
                self.sum += x as i64;
                self.st1_size += 1;
                self.st2_size -= 1;
            }
        }
        while self.st1_size > self.k {
            if let Some(x) = Self::last_key(&self.st1) {
                Self::add_one(&mut self.st2, x);
                Self::remove_one(&mut self.st1, x);
                self.sum -= x as i64;
                self.st1_size -= 1;
                self.st2_size += 1;
            }
        }
    }

    fn add(&mut self, x: i32) {
        if !self.st2.is_empty() && x >= *self.st2.keys().next().unwrap() {
            Self::add_one(&mut self.st2, x);
            self.st2_size += 1;
        } else {
            Self::add_one(&mut self.st1, x);
            self.sum += x as i64;
            self.st1_size += 1;
        }
        self.adjust();
    }

    fn erase(&mut self, x: i32) {
        if Self::remove_one(&mut self.st1, x) {
            self.sum -= x as i64;
            self.st1_size -= 1;
        } else if Self::remove_one(&mut self.st2, x) {
            self.st2_size -= 1;
        }
        self.adjust();
    }

    fn sum(&self) -> i64 {
        self.sum
    }
}

impl Solution {
    pub fn minimum_cost(nums: Vec<i32>, k: i32, dist: i32) -> i64 {
        let n = nums.len();
        let k = k as usize;
        let dist = dist as usize;

        let mut cnt = Container::new(k - 2);
        for i in 1..k - 1 {
            cnt.add(nums[i]);
        }

        let mut ans = cnt.sum() + nums[k - 1] as i64;
        for i in k..n {
            let j = i as i32 - dist as i32 - 1;
            if j > 0 {
                cnt.erase(nums[j as usize]);
            }
            cnt.add(nums[i - 1]);
            ans = ans.min(cnt.sum() + nums[i] as i64);
        }

        ans + nums[0] as i64
    }
}
```
