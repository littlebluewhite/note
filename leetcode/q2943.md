---
title: "q2943"
category: leetcode
tags: [leetcode]
created: 2023-11-05
updated: 2023-11-05
difficulty: Medium
source: leetcode
status: active
complexity_time: O(h log h + v log v)
complexity_space: O(1)
---
[2943. Maximize Area of Square Hole in Grid](https://leetcode.com/problems/maximize-area-of-square-hole-in-grid/)

Medium

Topics

![premium lock icon](https://leetcode.com/_next/static/images/lock-a6627e2c7fa0ce8bc117c109fb4e567d.svg)Companies

Hint

You are given the two integers, `n` and `m` and two integer arrays, `hBars` and `vBars`.
給定兩個整數 `n` 與 `m`，以及兩個整數陣列 `hBars`、`vBars`。
The grid has `n + 2` horizontal and `m + 2` vertical bars, creating 1 x 1 unit cells.
網格有 `n + 2` 條水平桿與 `m + 2` 條垂直桿，形成 1 x 1 的單位格。
The bars are indexed starting from `1`.
桿的索引從 `1` 開始。

You can **remove** some of the bars in `hBars` from horizontal bars and some of the bars in `vBars` from vertical bars.
你可以 **移除** `hBars` 中的部分水平桿，以及 `vBars` 中的部分垂直桿。
Note that other bars are fixed and cannot be removed.
其他桿為固定桿，不能移除。

Return an integer denoting the **maximum area** of a _square-shaped_ hole in the grid, after removing some bars (possibly none).
請回傳移除部分桿後，網格中可形成的 **最大正方形洞** 的面積（可能不移除任何桿）。

**Example 1:**

![](https://assets.leetcode.com/uploads/2023/11/05/screenshot-from-2023-11-05-22-40-25.png)

**Input:** n = 2, m = 1, hBars = [2,3], vBars = [2]

**Output:** 4

**Explanation:**

The left image shows the initial grid formed by the bars.
左圖為初始由桿構成的網格。
The horizontal bars are `[1,2,3,4]`, and the vertical bars are `[1,2,3]`.
水平桿為 `[1,2,3,4]`，垂直桿為 `[1,2,3]`。

One way to get the maximum square-shaped hole is by removing horizontal bar 2 and vertical bar 2.
取得最大正方形洞的一種方式是移除水平桿 2 與垂直桿 2。

**Example 2:**

![](https://assets.leetcode.com/uploads/2023/11/04/screenshot-from-2023-11-04-17-01-02.png)

**Input:** n = 1, m = 1, hBars = [2], vBars = [2]

**Output:** 4

**Explanation:**

To get the maximum square-shaped hole, we remove horizontal bar 2 and vertical bar 2.
要得到最大正方形洞，可以移除水平桿 2 與垂直桿 2。

**Example 3:**

![](https://assets.leetcode.com/uploads/2024/03/12/unsaved-image-2.png)

**Input:** n = 2, m = 3, hBars = [2,3], vBars = [2,4]

**Output:** 4

**Explanation:**

One way to get the maximum square-shaped hole is by removing horizontal bar 3, and vertical bar 4.
取得最大正方形洞的一種方式是移除水平桿 3 與垂直桿 4。

**Constraints:**

- `1 <= n <= 10^9`
- `1 <= m <= 10^9`
- `1 <= hBars.length <= 100`
- `2 <= hBars[i] <= n + 1`
- `1 <= vBars.length <= 100`
- `2 <= vBars[i] <= m + 1`
- All values in `hBars` are distinct.
- All values in `vBars` are distinct.
- `1 <= n <= 10^9`。
- `1 <= m <= 10^9`。
- `1 <= hBars.length <= 100`。
- `2 <= hBars[i] <= n + 1`。
- `1 <= vBars.length <= 100`。
- `2 <= vBars[i] <= m + 1`。
- `hBars` 內所有值皆不重複。
- `vBars` 內所有值皆不重複。

## 解題筆記與程式碼

通用演算法筆記：[consecutive_run_length_sorted](../algorithm/consecutive_run_length_sorted.md)
資料結構筆記：[sorted_array](../data_structure/sorted_array.md)

### 思路拆解

- 移除連續的水平桿 `k` 根，等同垂直方向合併 `k + 1` 個單位格，所以可形成的高度是 `k + 1`。
- 垂直桿同理，移除連續 `k` 根可形成寬度 `k + 1`。
- 因為必須是正方形，最大邊長是 `min(maxH + 1, maxV + 1)`，其中 `maxH`、`maxV` 分別為 `hBars`、`vBars` 最長連續段長度。

### 演算法

1. 對 `hBars`、`vBars` 各自排序。
2. 線性掃描，找出每個陣列的最長連續段長度 `maxH`、`maxV`。
3. 計算 `side = min(maxH + 1, maxV + 1)`，回傳 `side * side`。

### 時間與空間

- 時間：`O(h log h + v log v)`，`h`、`v` 為兩陣列長度。
- 空間：`O(1)` 額外空間（排序就地）。

```rust
fn longest_run(bars: &mut Vec<i32>) -> i32 {
    if bars.is_empty() {
        return 0;
    }
    bars.sort_unstable();
    let mut best = 1;
    let mut cur = 1;
    for i in 1..bars.len() {
        if bars[i] == bars[i - 1] + 1 {
            cur += 1;
        } else {
            cur = 1;
        }
        if cur > best {
            best = cur;
        }
    }
    best
}

impl Solution {
    pub fn maximize_square_hole_area(
        _n: i32,
        _m: i32,
        mut h_bars: Vec<i32>,
        mut v_bars: Vec<i32>,
    ) -> i32 {
        let max_h = longest_run(&mut h_bars);
        let max_v = longest_run(&mut v_bars);
        let side = (max_h + 1).min(max_v + 1);
        side * side
    }
}
```
