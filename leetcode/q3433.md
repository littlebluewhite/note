[3433. Count Mentions Per User](https://leetcode.com/problems/count-mentions-per-user/)

Medium

Topics

![premium lock icon](https://leetcode.com/_next/static/images/lock-a6627e2c7fa0ce8bc117c109fb4e567d.svg)Companies

Hint

You are given an integer`numberOfUsers`representing the total number of users and an array`events`of size`n x 3`.
給定整數 `numberOfUsers` 代表使用者總數，以及大小為 `n x 3` 的陣列 `events`。

Each`events[i]`can be either of the following two types:
每筆 `events[i]` 可能為以下兩種型態：

1. **Message Event:**`["MESSAGE", "timestampi", "mentions_stringi"]`
    - This event indicates that a set of users was mentioned in a message at`timestampi`.
    - The`mentions_stringi`string can contain one of the following tokens:
        - `id<number>`: where`<number>`is an integer in range`[0,numberOfUsers - 1]`. There can be**multiple**ids
          separated by a single whitespace and may contain duplicates. This can mention even the offline users.
        - `ALL`: mentions**all**users.
        - `HERE`: mentions all**online**users.
1. **訊息事件：** `["MESSAGE", "timestampi", "mentions_stringi"]`
    - 代表在 `timestampi` 時有一則訊息提及一批使用者。
    - `mentions_stringi` 可以包含下列符號：
        - `id<number>`：`<number>` 介於 `[0, numberOfUsers - 1]`，可以有多個並以空白分隔，且允許重複；離線的用戶也可以被提及。
        - `ALL`：提及 **所有** 使用者。
        - `HERE`：提及當下 **在線** 的所有使用者。
2. **Offline Event:**`["OFFLINE", "timestampi", "idi"]`
    - This event indicates that the user`idi`had become offline at`timestampi`for**60 time units**. The user will
      automatically be online again at time`timestampi + 60`.
2. **離線事件：** `["OFFLINE", "timestampi", "idi"]`
    - 表示使用者 `idi` 在 `timestampi` 時離線 **60 個時間單位**，會於 `timestampi + 60` 自動回到線上。

Return an array`mentions`where`mentions[i]`represents the number of mentions the user with id`i`has across all`MESSAGE`
events.
請回傳陣列 `mentions`，其中 `mentions[i]` 代表使用者 `i` 在所有 `MESSAGE` 事件中被提及的次數。

All users are initially online, and if a user goes offline or comes back online, their status change is processed
_before_handling any message event that occurs at the same timestamp.
所有使用者初始皆在線上，且用戶的上下線狀態會在同一時間戳出現的訊息事件 **之前** 先處理。

**Note**that a user can be mentioned**multiple**times in a**single**message event, and each mention should be counted*
*separately**.
**注意**：同一則訊息可能多次提及同一用戶，每次都要分開計數。

**Example 1:**

**Input:**numberOfUsers = 2, events = [ ["MESSAGE","10","id1 id0"],["OFFLINE","11","0"],["MESSAGE","71","HERE"] ]

**Output:**[2,2]

**Explanation:**

Initially, all users are online.

At timestamp 10,`id1`and`id0`are mentioned.`mentions = [1,1]`

At timestamp 11,`id0`goes**offline.**

At timestamp 71,`id0`comes back**online**and`"HERE"`is mentioned.`mentions = [2,2]`

**Example 2:**

**Input:**numberOfUsers = 2, events = [ ["MESSAGE","10","id1 id0"],["OFFLINE","11","0"],["MESSAGE","12","ALL"] ]

**Output:**[2,2]

**Explanation:**

Initially, all users are online.

At timestamp 10,`id1`and`id0`are mentioned.`mentions = [1,1]`

At timestamp 11,`id0`goes**offline.**

At timestamp 12,`"ALL"`is mentioned. This includes offline users, so both`id0`and`id1`are mentioned.`mentions = [2,2]`

**Example 3:**

**Input:**numberOfUsers = 2, events = [ ["OFFLINE","10","0"],["MESSAGE","12","HERE"] ]

**Output:**[0,1]

**Explanation:**

Initially, all users are online.

At timestamp 10,`id0`goes**offline.**

At timestamp 12,`"HERE"`is mentioned. Because`id0`is still offline, they will not be mentioned.`mentions = [0,1]`

**Constraints:**

- `1 <= numberOfUsers <= 100`
- `1 <= events.length <= 100`
- `events[i].length == 3`
- `events[i][0]`will be one of`MESSAGE`or`OFFLINE`.
- `1 <= int(events[i][1]) <= 10^5`
- The number of`id<number>`mentions in any`"MESSAGE"`event is between`1`and`100`.
- `0 <= <number> <= numberOfUsers - 1`
- It is**guaranteed**that the user id referenced in the`OFFLINE`event is**online**at the time the event occurs.
- `1 <= numberOfUsers <= 100`
- `1 <= events.length <= 100`
- `events[i].length == 3`
- `events[i][0]` 只會是 `MESSAGE` 或 `OFFLINE`
- `1 <= int(events[i][1]) <= 10^5`
- 任一 `"MESSAGE"` 事件中的 `id<number>` 次數介於 `1` 到 `100`
- `0 <= <number> <= numberOfUsers - 1`
- 保證 `OFFLINE` 事件中的使用者在該時間點 **在線**。

## 解題筆記與程式碼

演算法相關筆記：[mentions_timeline_offline_window](../algorithm/mentions_timeline_offline_window.md)

### 核心觀察

- 狀態變化（自動回線與 `OFFLINE` 事件）都要在同一時間戳的訊息前處理，故可按時間排序，同時間先處理上下線，再計訊息。
- 用最小堆追蹤各使用者的回線時間 `(timestamp + 60)`，每遇到新的事件時間先彈出所有到期者並標為線上。
- 訊息中的 token 逐一處理：`ALL` 對所有人加一、`HERE` 只對線上者加一、`idX` 對指定編號加一；允許重複出現就重複累加。

### 演算法

1. 將事件依時間排序；若時間相同，`OFFLINE` 事件排在 `MESSAGE` 之前以符合先更新狀態的要求。
2. 維護 `online` 陣列（初始全為 `true`）、`mentions` 計數，以及最小堆存放 `(回線時間, 使用者)`.
3. 逐一處理排序後的事件：
    - 先從堆中彈出所有回線時間 `<= 當前時間` 的使用者並標為線上。
    - `OFFLINE`：將用戶標為離線，並把 `(time + 60, id)` 放入堆。
    - `MESSAGE`：逐 token 處理 `ALL`/`HERE`/`idX`，依規則累加提及次數。
4. 回傳 `mentions`。

### 時間與空間

- 時間：`O(m log m + m * k + n * m)`，`m` 為事件數，`k` 為每則訊息內 token 數（≤100），`n` 為使用者數（≤100）。
- 空間：`O(n + m)`，儲存線上狀態、回線堆與排序後事件。

```rust
use std::cmp::{Ordering, Reverse};
use std::collections::BinaryHeap;

impl Solution {
    pub fn count_mentions(number_of_users: i32, events: Vec<Vec<String>>) -> Vec<i32> {
        #[derive(Clone)]
        enum Payload {
            Offline(usize),
            Message(String),
        }

        #[derive(Clone)]
        struct Event {
            time: i32,
            payload: Payload,
        }

        let mut evs: Vec<Event> = events
            .into_iter()
            .map(|e| {
                let time = e[1].parse::<i32>().unwrap();
                let payload = match e[0].as_str() {
                    "OFFLINE" => Payload::Offline(e[2].parse::<usize>().unwrap()),
                    _ => Payload::Message(e[2].clone()),
                };
                Event { time, payload }
            })
            .collect();

        // 同時間戳先處理離線，再處理訊息
        evs.sort_by(|a, b| {
            let t_cmp = a.time.cmp(&b.time);
            if t_cmp != Ordering::Equal {
                return t_cmp;
            }
            let pa = matches!(a.payload, Payload::Message(_));
            let pb = matches!(b.payload, Payload::Message(_));
            pa.cmp(&pb)
        });

        let n = number_of_users as usize;
        let mut online = vec![true; n];
        let mut mentions = vec![0i32; n];

        // 最小堆：(回線時間, 使用者)
        let mut back_heap: BinaryHeap<Reverse<(i32, usize)>> = BinaryHeap::new();

        for ev in evs {
            let time = ev.time;

            // 先處理所有已到回線時間的使用者
            while let Some(&Reverse((t_back, id))) = back_heap.peek() {
                if t_back <= time {
                    back_heap.pop();
                    online[id] = true;
                } else {
                    break;
                }
            }

            match ev.payload {
                Payload::Offline(id) => {
                    online[id] = false;
                    back_heap.push(Reverse((time + 60, id)));
                }
                Payload::Message(text) => {
                    for token in text.split_whitespace() {
                        match token {
                            "ALL" => {
                                for x in mentions.iter_mut() {
                                    *x += 1;
                                }
                            }
                            "HERE" => {
                                for (i, x) in mentions.iter_mut().enumerate() {
                                    if online[i] {
                                        *x += 1;
                                    }
                                }
                            }
                            _ if token.starts_with("id") => {
                                if let Ok(id) = token[2..].parse::<usize>() {
                                    mentions[id] += 1;
                                }
                            }
                            _ => {}
                        }
                    }
                }
            }
        }

        mentions
    }
}
```
