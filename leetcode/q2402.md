[2402. Meeting Rooms III](https://leetcode.com/problems/meeting-rooms-iii/)

Hard

Topics

![premium lock icon](https://leetcode.com/_next/static/images/lock-a6627e2c7fa0ce8bc117c109fb4e567d.svg)Companies

Hint

You are given an integer `n`. There are `n` rooms numbered from `0` to `n - 1`.
給定整數 `n`，有 `n` 間會議室，編號從 `0` 到 `n - 1`。

You are given a 2D integer array `meetings` where `meetings[i] = [starti, endi]` means that a meeting will be held during the **half-closed** time interval `[starti, endi)`. All the values of `starti` are **unique**.
給定二維整數陣列 `meetings`，`meetings[i] = [starti, endi]` 代表一場會議在 **半開區間** `[starti, endi)` 舉行。所有 `starti` **互不相同**。

Meetings are allocated to rooms in the following manner:
會議安排規則如下：

1. Each meeting will take place in the unused room with the **lowest** number.
1. 每場會議安排到當下空閒且編號 **最小** 的房間。
2. If there are no available rooms, the meeting will be delayed until a room becomes free. The delayed meeting should have the **same** duration as the original meeting.
2. 若沒有空房間，會議延後到有房間空出；延後後的會議 **時長不變**。
3. When a room becomes unused, meetings that have an earlier original **start** time should be given the room.
3. 當房間空出時，原始 **開始時間** 較早的會議優先分配。

Return _the **number** of the room that held the most meetings._ If there are multiple rooms, return _the room with the **lowest** number._
回傳舉辦會議次數 **最多** 的房間編號；若有多個，回傳編號 **最小** 的。

A **half-closed interval** `[a, b)` is the interval between `a` and `b` **including** `a` and **not including** `b`.
**半開區間** `[a, b)` 表示包含 `a`，但 **不包含** `b`。

**Example 1:**

**Input:** n = 2, meetings = [ [0,10],[1,5],[2,7],[3,4] ]
**Output:** 0
**Explanation:**
- At time 0, both rooms are not being used. The first meeting starts in room 0.
- 時間 0：兩間房都空著，第一場會議用房間 0。
- At time 1, only room 1 is not being used. The second meeting starts in room 1.
- 時間 1：只有房間 1 空著，第二場會議用房間 1。
- At time 2, both rooms are being used. The third meeting is delayed.
- 時間 2：兩間房都在使用中，第三場會議延後。
- At time 3, both rooms are being used. The fourth meeting is delayed.
- 時間 3：兩間房都在使用中，第四場會議延後。
- At time 5, the meeting in room 1 finishes. The third meeting starts in room 1 for the time period [5,10).
- 時間 5：房間 1 結束會議，第三場會議在房間 1 舉行於 [5,10)。
- At time 10, the meetings in both rooms finish. The fourth meeting starts in room 0 for the time period [10,11).
- 時間 10：兩間房都結束會議，第四場會議在房間 0 舉行於 [10,11)。
Both rooms 0 and 1 held 2 meetings, so we return 0.
房間 0 與 1 都舉辦 2 場會議，因此回傳 0。

**Example 2:**

**Input:** n = 3, meetings = [ [1,20],[2,10],[3,5],[4,9],[6,8] ]
**Output:** 1
**Explanation:**
- At time 1, all three rooms are not being used. The first meeting starts in room 0.
- 時間 1：三間房都空著，第一場會議用房間 0。
- At time 2, rooms 1 and 2 are not being used. The second meeting starts in room 1.
- 時間 2：房間 1、2 空著，第二場會議用房間 1。
- At time 3, only room 2 is not being used. The third meeting starts in room 2.
- 時間 3：只有房間 2 空著，第三場會議用房間 2。
- At time 4, all three rooms are being used. The fourth meeting is delayed.
- 時間 4：三間房都在使用中，第四場會議延後。
- At time 5, the meeting in room 2 finishes. The fourth meeting starts in room 2 for the time period [5,10).
- 時間 5：房間 2 結束會議，第四場會議在房間 2 舉行於 [5,10)。
- At time 6, all three rooms are being used. The fifth meeting is delayed.
- 時間 6：三間房都在使用中，第五場會議延後。
- At time 10, the meetings in rooms 1 and 2 finish. The fifth meeting starts in room 1 for the time period [10,12).
- 時間 10：房間 1、2 結束會議，第五場會議在房間 1 舉行於 [10,12)。
Room 0 held 1 meeting while rooms 1 and 2 each held 2 meetings, so we return 1.
房間 0 舉辦 1 場，房間 1 與 2 各舉辦 2 場，因此回傳 1。

**Constraints:**

- `1 <= n <= 100`
- `1 <= meetings.length <= 10^5`
- `meetings[i].length == 2`
- `0 <= starti < endi <= 5 * 10^5`
- All the values of `starti` are **unique**.
- `1 <= n <= 100`。
- `1 <= meetings.length <= 10^5`。
- `meetings[i].length == 2`。
- `0 <= starti < endi <= 5 * 10^5`。
- 所有 `starti` **互不相同**。

## 解題筆記與程式碼

通用演算法筆記：[room_allocation_two_heaps](../algorithm/room_allocation_two_heaps.md)
資料結構筆記：[priority_queue_binary_heap](../data_structure/priority_queue_binary_heap.md)

### 思路拆解

- 依 `start` 排序會議，保證「原始開始時間較早」的會議先被處理。
- 用兩個最小堆：
  - `available`：存空房間編號，確保取最小編號。
  - `busy`：存 `(end_time, room_id)`，確保先釋放最早結束的房間。
- 處理每場會議時先釋放 `end_time <= start` 的房間；有空房直接排，無空房就延後到最早結束時間，會議長度不變。
- 統計每個房間使用次數，最後選次數最多且編號最小者。

### 為什麼要「排序 + 雙堆」

- 排序確保「原始開始時間」的優先順序自然成立。
- `available` 讓空房間的編號選擇正確。
- `busy` 讓延後時刻選擇最早結束房間，並以房間編號作為同時結束的 tie-break。

### 演算法

1. 將 `meetings` 依 `start` 升冪排序。
2. 初始化 `available = {0..n-1}`、`busy = {}`。
3. 逐一處理 `(start, end)`：
   - 釋放所有 `busy` 中 `end_time <= start` 的房間，移回 `available`。
   - 若 `available` 非空，取最小編號房間，安排於 `[start, end)`。
   - 否則取 `busy` 中最早結束房間 `(t, room)`，延後到 `[t, t + (end - start))`。
   - 更新該房間的會議次數，並把新的結束時間推回 `busy`。
4. 回傳會議次數最多、編號最小的房間。

### 時間與空間

- 時間：`O(m log n)`，`m` 為會議數。
- 空間：`O(n)`，兩個堆與計數陣列。

```rust
use std::cmp::Reverse;
use std::collections::BinaryHeap;

impl Solution {
    pub fn most_booked(n: i32, meetings: Vec<Vec<i32>>) -> i32 {
        let n = n as usize;
        let mut meetings: Vec<(i64, i64)> = meetings
            .into_iter()
            .map(|m| (m[0] as i64, m[1] as i64))
            .collect();
        meetings.sort_by_key(|m| m.0);

        let mut available: BinaryHeap<Reverse<usize>> = BinaryHeap::new();
        for room in 0..n {
            available.push(Reverse(room));
        }
        let mut busy: BinaryHeap<Reverse<(i64, usize)>> = BinaryHeap::new();
        let mut count = vec![0usize; n];

        for (start, end) in meetings {
            while let Some(&Reverse((t, room))) = busy.peek() {
                if t <= start {
                    busy.pop();
                    available.push(Reverse(room));
                } else {
                    break;
                }
            }

            if let Some(Reverse(room)) = available.pop() {
                count[room] += 1;
                busy.push(Reverse((end, room)));
            } else {
                let Reverse((t, room)) = busy.pop().unwrap();
                let duration = end - start;
                let new_end = t + duration;
                count[room] += 1;
                busy.push(Reverse((new_end, room)));
            }
        }

        let mut best = 0usize;
        for room in 1..n {
            if count[room] > count[best] {
                best = room;
            }
        }
        best as i32
    }
}
```

### 實作細節

- 時間可能被延後到超過 `5 * 10^5`，用 `i64` 避免溢位。
- `busy` 的排序鍵為 `(end_time, room_id)`，確保同時結束時選編號最小房間。
