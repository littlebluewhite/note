---
title: "q3314"
category: leetcode
tags: [leetcode]
created: 2026-02-03
updated: 2026-02-03
difficulty: Easy
source: leetcode
status: active
complexity_time: O(n log M)
complexity_space: O(1)
---
# q3314

[3314. Construct the Minimum Bitwise Array I](https://leetcode.com/problems/construct-the-minimum-bitwise-array-i/)

Easy

Topics

![premium lock icon](https://leetcode.com/_next/static/images/lock-a6627e2c7fa0ce8bc117c109fb4e567d.svg)Companies

Hint

You are given an array `nums` consisting of `n` prime integers.
給定陣列 `nums`，包含 `n` 個質數整數。

You need to construct an array `ans` of length `n`, such that, for each index `i`, the bitwise `OR` of `ans[i]` and `ans[i] + 1` is equal to `nums[i]`, i.e. `ans[i] OR (ans[i] + 1) == nums[i]`.
你需要建構長度為 `n` 的陣列 `ans`，使得每個索引 `i` 都滿足：`ans[i] OR (ans[i] + 1) == nums[i]`。

Additionally, you must **minimize** each value of `ans[i]` in the resulting array.
此外，必須讓每個 `ans[i]` 都 **最小化**。

If it is _not possible_ to find such a value for `ans[i]` that satisfies the **condition**, then set `ans[i] = -1`.
若 **無法** 找到符合條件的 `ans[i]`，則設為 `-1`。

**Example 1:**

**Input:** nums = [2,3,5,7]
**Output:** [-1,1,4,3]
**Explanation:**

- For `i = 0`, as there is no value for `ans[0]` that satisfies `ans[0] OR (ans[0] + 1) = 2`, so `ans[0] = -1`.
  `i = 0`：不存在滿足 `ans[0] OR (ans[0] + 1) = 2` 的值，因此 `ans[0] = -1`。
- For `i = 1`, the smallest `ans[1]` that satisfies `ans[1] OR (ans[1] + 1) = 3` is `1`, because `1 OR (1 + 1) = 3`.
  `i = 1`：最小的 `ans[1]` 是 `1`，因為 `1 OR (1 + 1) = 3`。
- For `i = 2`, the smallest `ans[2]` that satisfies `ans[2] OR (ans[2] + 1) = 5` is `4`, because `4 OR (4 + 1) = 5`.
  `i = 2`：最小的 `ans[2]` 是 `4`，因為 `4 OR (4 + 1) = 5`。
- For `i = 3`, the smallest `ans[3]` that satisfies `ans[3] OR (ans[3] + 1) = 7` is `3`, because `3 OR (3 + 1) = 7`.
  `i = 3`：最小的 `ans[3]` 是 `3`，因為 `3 OR (3 + 1) = 7`。

**Example 2:**

**Input:** nums = [11,13,31]
**Output:** [9,12,15]
**Explanation:**

- For `i = 0`, the smallest `ans[0]` that satisfies `ans[0] OR (ans[0] + 1) = 11` is `9`, because `9 OR (9 + 1) = 11`.
  `i = 0`：最小的 `ans[0]` 是 `9`，因為 `9 OR (9 + 1) = 11`。
- For `i = 1`, the smallest `ans[1]` that satisfies `ans[1] OR (ans[1] + 1) = 13` is `12`, because `12 OR (12 + 1) = 13`.
  `i = 1`：最小的 `ans[1]` 是 `12`，因為 `12 OR (12 + 1) = 13`。
- For `i = 2`, the smallest `ans[2]` that satisfies `ans[2] OR (ans[2] + 1) = 31` is `15`, because `15 OR (15 + 1) = 31`.
  `i = 2`：最小的 `ans[2]` 是 `15`，因為 `15 OR (15 + 1) = 31`。

**Constraints:**

- `1 <= nums.length <= 100`
- `2 <= nums[i] <= 1000`
- `nums[i]` is a prime number.
- `1 <= nums.length <= 100`。
- `2 <= nums[i] <= 1000`。
- `nums[i]` 為質數。

## 解題筆記與程式碼

通用演算法筆記：[bitwise_or_with_increment](../algorithm/bitwise_or_with_increment.md)

### 思路拆解

- 對任意整數 `x`，`x OR (x + 1)` 的最低位必為 `1`，結果一定是奇數；因此偶數目標值必不可能（本題只有 `2` 會失敗）。
- 設 `x` 的最低位 `0` 在第 `k` 位（更低位都是 `1`），則 `x + 1` 會把第 `k` 位變成 `1`、更低位變成 `0`，所以 `x OR (x + 1)` 會把第 `k` 位與更低位全部變成 `1`。
- 給定奇數目標 `y`，令尾端連續 `1` 的長度為 `L`。任何可行的 `x` 都是把這段連續 `1` 中「某一位」改成 `0` 的結果；要讓 `x` 最小，就改掉這段連續 `1` 中最左邊（最高位）的那一個。

### 為什麼是「清掉最高位的尾端 1」

- 對同一個 `y`，可行 `x` 皆為 `y - 2^k`（`k` 位於尾端連續 `1` 的範圍內）。
- 為了最小化 `x`，要讓 `2^k` 最大，因此選尾端連續 `1` 中最高位。

### 演算法

1. 對每個 `nums[i]`：
   - 若為偶數，答案為 `-1`。
   - 若為奇數，計算尾端連續 `1` 的長度 `L`。
   - 回傳 `nums[i] - 2^(L-1)`。

### 時間與空間

- 時間：`O(n log M)`，`M` 為數值大小，上限 1000，可視為常數。
- 空間：`O(1)` 額外空間（輸出陣列除外）。

```rust
impl Solution {
    pub fn min_bitwise_array(nums: Vec<i32>) -> Vec<i32> {
        let mut ans = Vec::with_capacity(nums.len());
        for &x in &nums {
            if x & 1 == 0 {
                ans.push(-1);
                continue;
            }
            let mut t = x;
            let mut len: u32 = 0;
            while t & 1 == 1 {
                len += 1;
                t >>= 1;
            }
            let bit = 1i32 << (len - 1);
            ans.push(x - bit);
        }
        ans
    }
}
```

## Related problems / 相關題目

- [3315. Construct the Minimum Bitwise Array II](https://leetcode.com/problems/construct-the-minimum-bitwise-array-ii/) / 建構最小位元陣列 II
