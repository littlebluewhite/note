[1877. Minimize Maximum Pair Sum in Array](https://leetcode.com/problems/minimize-maximum-pair-sum-in-array/)

Medium

Topics

![premium lock icon](https://leetcode.com/_next/static/images/lock-a6627e2c7fa0ce8bc117c109fb4e567d.svg)Companies

Hint

The **pair sum** of a pair `(a,b)` is equal to `a + b`. The **maximum pair sum** is the largest **pair sum** in a list of pairs.
一對 `(a,b)` 的 **配對和** 為 `a + b`，**最大配對和** 是所有配對和中的最大值。

- For example, if we have pairs `(1,5)`, `(2,3)`, and `(4,4)`, the **maximum pair sum** would be `max(1+5, 2+3, 4+4) = max(6, 5, 8) = 8`.
- 例如若配對為 `(1,5)`, `(2,3)`, `(4,4)`，則 **最大配對和** 為 `max(1+5, 2+3, 4+4) = max(6, 5, 8) = 8`。

Given an array `nums` of **even** length `n`, pair up the elements of `nums` into `n / 2` pairs such that:
給定長度為 **偶數** `n` 的陣列 `nums`，將元素配成 `n / 2` 組，使得：

- Each element of `nums` is in **exactly one** pair, and
- `nums` 的每個元素都 **恰好** 出現在一組配對中。
- The **maximum pair sum** is **minimized**.
- **最大配對和** 被 **最小化**。

Return _the minimized **maximum pair sum** after optimally pairing up the elements_.
請回傳最佳配對後的 **最小化最大配對和**。

**Example 1:**

**Input:** nums = [3,5,2,3]
**Output:** 7
**Explanation:** The elements can be paired up into pairs (3,3) and (5,2).
**說明：** 可以配成 (3,3) 與 (5,2)。
The maximum pair sum is max(3+3, 5+2) = max(6, 7) = 7.
最大配對和為 max(3+3, 5+2) = max(6, 7) = 7。

**Example 2:**

**Input:** nums = [3,5,4,2,4,6]
**Output:** 8
**Explanation:** The elements can be paired up into pairs (3,5), (4,4), and (6,2).
**說明：** 可以配成 (3,5)、(4,4)、(6,2)。
The maximum pair sum is max(3+5, 4+4, 6+2) = max(8, 8, 8) = 8.
最大配對和為 max(3+5, 4+4, 6+2) = max(8, 8, 8) = 8。

**Constraints:**

- `n == nums.length`
- `n == nums.length`。
- `2 <= n <= 105`
- `2 <= n <= 10^5`。
- `n` is **even**.
- `n` 為 **偶數**。
- `1 <= nums[i] <= 105`
- `1 <= nums[i] <= 10^5`。

## 解題筆記與程式碼

通用演算法筆記：[greedy_pairing_extremes](../algorithm/greedy_pairing_extremes.md)
通用演算法筆記：[two_pointers](../algorithm/two_pointers.md)
資料結構筆記：[sorted_array](../data_structure/sorted_array.md)

### 思路拆解

- 為了讓最大配對和最小，先排序後讓最小值配最大值。
- 最大值一定要與某個元素配對，和最小值配能使這一組的和最小。
- 對剩下元素重複同樣的做法，就能最小化整體的最大值。
- 以左右指標往內掃描即可完成配對與最大值更新。

### 為什麼極值配對是最優

- 排序後設 `a0 <= ... <= a(n-1)`，`a(n-1)` 一定要配對。
- 若它與 `ai (i>0)` 配對，該組和為 `a(n-1) + ai >= a(n-1) + a0`。
- 因此存在最優解讓 `a(n-1)` 與 `a0` 配對，且不會讓最大值變大。
- 移除後對剩下元素同理，歸納成立。

### 演算法

1. 將 `nums` 由小到大排序。
2. `l=0, r=n-1`，迭代直到 `l < r`：
   - 更新 `ans = max(ans, nums[l] + nums[r])`。
   - `l++`, `r--`。
3. 回傳 `ans`。

### 時間與空間

- 時間：`O(n log n)`，排序為主。
- 空間：`O(1)` 額外空間（就地排序），不含輸入。

```rust
impl Solution {
    pub fn min_pair_sum(mut nums: Vec<i32>) -> i32 {
        nums.sort_unstable();
        let mut l = 0usize;
        let mut r = nums.len() - 1;
        let mut ans = 0i32;
        while l < r {
            let sum = nums[l] + nums[r];
            if sum > ans {
                ans = sum;
            }
            l += 1;
            r -= 1;
        }
        ans
    }
}
```

## 補充筆記：本題只需要維護最大值，不必儲存所有配對和。
