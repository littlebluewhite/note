---
title: "q3637"
category: leetcode
tags: [leetcode]
created: 2026-02-03
updated: 2026-02-03
difficulty: Easy
source: leetcode
status: active
complexity_time: O(n)
complexity_space: O(1)
---
# q3637

[3637. Trionic Array I](https://leetcode.com/problems/trionic-array-i/)

Easy

Topics

Companies

Hint

You are given an integer array `nums` of length `n`.
給定一個長度為 `n` 的整數陣列 `nums`。

An array is **trionic** if there exist indices `0 < p < q < n - 1` such that:
若存在索引 `0 < p < q < n - 1` 使得下列條件成立，則此陣列為 **trionic**：

- `nums[0...p]` is **strictly** increasing.
  / `nums[0...p]` 為 **嚴格遞增**。
- `nums[p...q]` is **strictly** decreasing.
  / `nums[p...q]` 為 **嚴格遞減**。
- `nums[q...n - 1]` is **strictly** increasing.
  / `nums[q...n - 1]` 為 **嚴格遞增**。

Return `true` if `nums` is trionic, otherwise return `false`.
若 `nums` 是 trionic 回傳 `true`，否則回傳 `false`。

**Example 1:**

Input: `nums = [1,3,5,4,2,6]`
Output: `true`

Explanation:
Pick `p = 2`, `q = 4`:

- `nums[0...2] = [1, 3, 5]` is strictly increasing.
  / `nums[0...2] = [1, 3, 5]` 為嚴格遞增。
- `nums[2...4] = [5, 4, 2]` is strictly decreasing.
  / `nums[2...4] = [5, 4, 2]` 為嚴格遞減。
- `nums[4...5] = [2, 6]` is strictly increasing.
  / `nums[4...5] = [2, 6]` 為嚴格遞增。

**Example 2:**

Input: `nums = [2,1,3]`
Output: `false`

Explanation:
There is no way to pick `p` and `q` to form the required three segments.
無法選出 `p` 與 `q` 形成符合條件的三段。

**Constraints:**

- `3 <= n <= 100`
- `-1000 <= nums[i] <= 1000`

---

## 解題筆記與程式碼

核心想法：用一次線性掃描把陣列切成「嚴格遞增 → 嚴格遞減 → 嚴格遞增」三段；任何一段無法前進（或段長不足）就直接失敗。

- 先從左往右走到第一段嚴格遞增的盡頭，得到 `p`（必須 `p >= 1`）。
- 接著走嚴格遞減到盡頭，得到 `q`（必須 `q > p` 且 `q <= n-2`）。
- 最後走嚴格遞增到陣列結尾，且必須剛好走到 `n-1`。

相關筆記：
- 演算法：[`algorithm/monotonic_segment_scan.md`](../algorithm/monotonic_segment_scan.md)
- 資料結構：[`data_structure/array.md`](../data_structure/array.md)

### Rust

```rust
impl Solution {
    pub fn is_trionic(nums: Vec<i32>) -> bool {
        let n = nums.len();
        if n < 4 {
            return false;
        }

        let mut i: usize = 0;

        // 1) strictly increasing: nums[0..=p]
        while i + 1 < n && nums[i] < nums[i + 1] {
            i += 1;
        }
        let p = i;
        if p == 0 {
            return false; // need 0 < p
        }

        // 2) strictly decreasing: nums[p..=q]
        while i + 1 < n && nums[i] > nums[i + 1] {
            i += 1;
        }
        let q = i;
        if q == p {
            return false; // need p < q
        }
        if q >= n - 1 {
            return false; // need q < n-1
        }

        // 3) strictly increasing: nums[q..=n-1]
        while i + 1 < n && nums[i] < nums[i + 1] {
            i += 1;
        }

        i == n - 1
    }
}
```

### Complexity

- Time: `O(n)`
- Space: `O(1)` (excluding input)
