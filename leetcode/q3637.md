---
title: "3637. Trionic Array I"
category: leetcode
tags: [leetcode]
created: 2026-02-03
updated: 2026-02-03
difficulty: easy
source: leetcode
status: active
complexity_time: O(n)
complexity_space: O(1)
---

# 3637. Trionic Array I

Link: https://leetcode.com/problems/trionic-array-i/
Difficulty: Easy

## Problem

You are given an integer array `nums` of length `n`.

給你一個長度為 `n` 的整數陣列 `nums`。

An array is **trionic** if there exist indices `0 < p < q < n − 1` such that:

若存在索引 `0 < p < q < n − 1` 使得下列三段成立，則陣列稱為 **trionic**：

- `nums[0...p]` is **strictly** increasing,
  `nums[0...p]` **嚴格遞增**。
- `nums[p...q]` is **strictly** decreasing,
  `nums[p...q]` **嚴格遞減**。
- `nums[q...n − 1]` is **strictly** increasing.
  `nums[q...n − 1]` **嚴格遞增**。

Return `true` if `nums` is trionic, otherwise return `false`.

若 `nums` 是 trionic 則回傳 `true`，否則回傳 `false`。

## Examples

**Example 1:**

**Input:** nums = [1,3,5,4,2,6]

**Output:** true

**Explanation:**
Pick `p = 2`, `q = 4`:

- `nums[0...2] = [1, 3, 5]` is strictly increasing (`1 < 3 < 5`).
- `nums[2...4] = [5, 4, 2]` is strictly decreasing (`5 > 4 > 2`).
- `nums[4...5] = [2, 6]` is strictly increasing (`2 < 6`).

**中文說明：**
選 `p = 2`、`q = 4`：
- 前段 [1,3,5] 嚴格遞增。
- 中段 [5,4,2] 嚴格遞減。
- 後段 [2,6] 嚴格遞增。

**Example 2:**

**Input:** nums = [2,1,3]

**Output:** false

**Explanation:**
There is no way to pick `p` and `q` to form the required three segments.

**中文說明：**
無法找到 `p`、`q` 使三段（增→減→增）同時成立。

## Constraints

- `3 <= n <= 100`
- `-1000 <= nums[i] <= 1000`

## 解題方向 / Solution Idea

這題其實是「三段單調」判斷：

- 先吃掉最長的嚴格遞增前綴（得到切點 `p`）
- 再吃掉最長的嚴格遞減中段（得到切點 `q`）
- 最後吃掉嚴格遞增後綴，且必須剛好走到陣列尾端

同時要確保三段都**非空**（等價於 `p>0`、`q>p`、`q<n-1`）。

相關演算法筆記：
- [Monotonic Three-Phase Scan](../algorithm/monotonic_three_phase_scan.md)

## Complexity
- Time: `O(n)`
- Space: `O(1)`

## Rust

```rust
impl Solution {
    pub fn is_trionic(nums: Vec<i32>) -> bool {
        let n = nums.len();
        if n < 4 {
            return false;
        }

        let mut i: usize = 0;

        // phase 0: strictly increasing
        while i + 1 < n && nums[i] < nums[i + 1] {
            i += 1;
        }
        let p = i;
        if p == 0 || p == n - 1 {
            return false;
        }

        // phase 1: strictly decreasing
        while i + 1 < n && nums[i] > nums[i + 1] {
            i += 1;
        }
        let q = i;
        if q == p || q == n - 1 {
            return false;
        }

        // phase 2: strictly increasing
        while i + 1 < n && nums[i] < nums[i + 1] {
            i += 1;
        }

        i == n - 1
    }
}
```
