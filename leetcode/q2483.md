---
title: "q2483"
category: leetcode
tags: [leetcode]
created: 2026-02-03
updated: 2026-02-03
difficulty: Medium
source: leetcode
status: active
complexity_time: O(n)
complexity_space: O(n)
---
[2483. Minimum Penalty for a Shop](https://leetcode.com/problems/minimum-penalty-for-a-shop/)

Medium

Topics

![premium lock icon](https://leetcode.com/_next/static/images/lock-a6627e2c7fa0ce8bc117c109fb4e567d.svg)Companies

Hint

You are given the customer visit log of a shop represented by a **0-indexed** string `customers` consisting only of characters `'N'` and `'Y'`:
給你一間商店的顧客到訪紀錄，以 **0-indexed** 字串 `customers` 表示，字串只包含 `'N'` 與 `'Y'`：

- if the `ith` character is `'Y'`, it means that customers come at the `ith` hour
- 若第 `i` 個字元是 `'Y'`，代表第 `i` 小時有顧客到訪。
- whereas `'N'` indicates that no customers come at the `ith` hour.
- 若第 `i` 個字元是 `'N'`，代表第 `i` 小時沒有顧客到訪。

If the shop closes at the `jth` hour (`0 <= j <= n`), the **penalty** is calculated as follows:
若商店在第 `j` 小時關店（`0 <= j <= n`），**懲罰值** 定義如下：

- For every hour when the shop is open and no customers come, the penalty increases by `1`.
- 商店營業期間若沒有顧客到訪，每小時懲罰 `+1`。
- For every hour when the shop is closed and customers come, the penalty increases by `1`.
- 商店已關店但仍有顧客到訪，每小時懲罰 `+1`。

Return the **earliest** hour at which the shop must be closed to incur a **minimum** penalty.
請回傳使懲罰值 **最小** 的 **最早** 關店時刻。

**Note** that if a shop closes at the `jth` hour, it means the shop is closed at the hour `j`.
**注意**：商店若在第 `j` 小時關店，代表第 `j` 小時開始就不營業。

**Example 1:**

**Input:** customers = "YYNY"
**Output:** 2
**Explanation:** 
- Closing the shop at the 0th hour incurs in 1+1+0+1 = 3 penalty.
- 在第 0 小時關店的懲罰為 1+1+0+1 = 3。
- Closing the shop at the 1st hour incurs in 0+1+0+1 = 2 penalty.
- 在第 1 小時關店的懲罰為 0+1+0+1 = 2。
- Closing the shop at the 2nd hour incurs in 0+0+0+1 = 1 penalty.
- 在第 2 小時關店的懲罰為 0+0+0+1 = 1。
- Closing the shop at the 3rd hour incurs in 0+0+1+1 = 2 penalty.
- 在第 3 小時關店的懲罰為 0+0+1+1 = 2。
- Closing the shop at the 4th hour incurs in 0+0+1+0 = 1 penalty.
- 在第 4 小時關店的懲罰為 0+0+1+0 = 1。
Closing the shop at 2nd or 4th hour gives a minimum penalty. Since 2 is earlier, the optimal closing time is 2.
第 2 或第 4 小時關店都達到最小懲罰，但 2 較早，因此答案為 2。

**Example 2:**

**Input:** customers = "NNNNN"
**Output:** 0
**Explanation:** It is best to close the shop at the 0th hour as no customers arrive.
最佳策略是第 0 小時關店，因為整天都沒有顧客。

**Example 3:**

**Input:** customers = "YYYY"
**Output:** 4
**Explanation:** It is best to close the shop at the 4th hour as customers arrive at each hour.
最佳策略是第 4 小時關店，因為每小時都有顧客到訪。

**Constraints:**

- `1 <= customers.length <= 10^5`
- `customers` consists only of characters `'Y'` and `'N'`.
- `1 <= customers.length <= 10^5`。
- `customers` 只包含 `'Y'` 與 `'N'`。

## 解題筆記與程式碼

通用演算法筆記：[prefix_suffix_penalty_scan](../algorithm/prefix_suffix_penalty_scan.md)
通用資料結構筆記：[prefix_suffix_count_array](../data_structure/prefix_suffix_count_array.md)

### 思路拆解

- 關店於 `j` 時，`[0, j)` 是營業時段，懲罰來自其中的 `'N'`；`[j, n)` 是關店時段，懲罰來自其中的 `'Y'`。
- 因此總懲罰 = `prefixN[j] + suffixY[j]`，只要能快速查到前綴 `'N'` 與後綴 `'Y'` 的數量即可。
- 掃描所有 `j`，找出最小懲罰；若同分，保留最早的 `j`。

### 演算法

1. 建立 `prefixN`：`prefixN[i + 1] = prefixN[i] + (customers[i] == 'N')`。
2. 建立 `suffixY`：`suffixY[i] = suffixY[i + 1] + (customers[i] == 'Y')`。
3. 對每個 `j = 0..=n` 計算 `penalty = prefixN[j] + suffixY[j]`，更新最小值與最早位置。

### 時間與空間

- 時間：`O(n)`。
- 空間：`O(n)`。

```rust
impl Solution {
    pub fn best_closing_time(customers: String) -> i32 {
        let bytes = customers.as_bytes();
        let n = bytes.len();

        let mut prefix_n = vec![0i32; n + 1];
        for i in 0..n {
            prefix_n[i + 1] = prefix_n[i] + if bytes[i] == b'N' { 1 } else { 0 };
        }

        let mut suffix_y = vec![0i32; n + 1];
        for i in (0..n).rev() {
            suffix_y[i] = suffix_y[i + 1] + if bytes[i] == b'Y' { 1 } else { 0 };
        }

        let mut best = 0usize;
        let mut best_penalty = i32::MAX;
        for j in 0..=n {
            let penalty = prefix_n[j] + suffix_y[j];
            if penalty < best_penalty {
                best_penalty = penalty;
                best = j;
            }
        }

        best as i32
    }
}
```

### O(1) 空間版本（running penalty）

- 關店於 `0` 的懲罰等於全字串 `'Y'` 的數量（全部視為關店時段的顧客）。  
- 每往右移一小時 `j`：若 `customers[i] == 'Y'`，該顧客從關店時段變成營業時段，懲罰 `-1`；若 `customers[i] == 'N'`，該空時段從關店變成營業，懲罰 `+1`。
- 逐步更新最小懲罰，遇到同分不更新即可保留最早 `j`。

```rust
impl Solution {
    pub fn best_closing_time(customers: String) -> i32 {
        let bytes = customers.as_bytes();
        let mut penalty = bytes.iter().filter(|&&c| c == b'Y').count() as i32;
        let mut best_penalty = penalty;
        let mut best = 0i32;

        for (i, &c) in bytes.iter().enumerate() {
            if c == b'Y' {
                penalty -= 1;
            } else {
                penalty += 1;
            }
            let j = (i + 1) as i32;
            if penalty < best_penalty {
                best_penalty = penalty;
                best = j;
            }
        }

        best
    }
}
```
