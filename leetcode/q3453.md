---
title: "q3453"
category: leetcode
tags: [leetcode]
created: 2026-02-03
updated: 2026-02-03
difficulty: Medium
source: leetcode
status: active
complexity_time: O(n log n)
complexity_space: O(n)
---
# q3453

[3453. Separate Squares I](https://leetcode.com/problems/separate-squares-i/)

Medium

Topics

![premium lock icon](https://leetcode.com/_next/static/images/lock-a6627e2c7fa0ce8bc117c109fb4e567d.svg)Companies

Hint

You are given a 2D integer array `squares`. Each `squares[i] = [xi, yi, li]` represents the coordinates of the bottom-left point and the side length of a square parallel to the x-axis.
給定一個二維整數陣列 `squares`。每個 `squares[i] = [xi, yi, li]` 代表一個與 x 軸平行的正方形，其左下角座標為 `(xi, yi)`，邊長為 `li`。

Find the **minimum** y-coordinate value of a horizontal line such that the total area of the squares above the line _equals_ the total area of the squares below the line.
請找出一條水平線的 **最小** y 座標，使得線上方的總面積 _等於_ 線下方的總面積。

Answers within `10^-5` of the actual answer will be accepted.
答案在實際值的 `10^-5` 誤差內都會被接受。

**Note**: Squares **may** overlap. Overlapping areas should be counted **multiple times**.
**注意**：正方形 **可能** 重疊，重疊區域要 **重複計算** 面積。

**Example 1:**

**Input:** squares = [ [0,0,1],[2,2,1] ]
**Output:** 1.00000
**Explanation:**

![](https://assets.leetcode.com/uploads/2025/01/06/4062example1drawio.png)

Any horizontal line between `y = 1` and `y = 2` will have 1 square unit above it and 1 square unit below it. The lowest option is 1.
任何介於 `y = 1` 與 `y = 2` 的水平線，上下方的面積都各為 1。最小的可行答案是 1。

**Example 2:**

**Input:** squares = [ [0,0,2],[1,1,1] ]
**Output:** 1.16667
**Explanation:**

![](https://assets.leetcode.com/uploads/2025/01/15/4062example2drawio.png)

The areas are:
面積如下：

- Below the line: `7/6 * 2 (Red) + 1/6 (Blue) = 15/6 = 2.5`.
- 線下方：`7/6 * 2 (Red) + 1/6 (Blue) = 15/6 = 2.5`。
- Above the line: `5/6 * 2 (Red) + 5/6 (Blue) = 15/6 = 2.5`.
- 線上方：`5/6 * 2 (Red) + 5/6 (Blue) = 15/6 = 2.5`。

Since the areas above and below the line are equal, the output is `7/6 = 1.16667`.
因為線上方與線下方的面積相等，所以輸出為 `7/6 = 1.16667`。

**Constraints:**

- `1 <= squares.length <= 5 * 10^4`
- `squares[i] = [xi, yi, li]`
- `squares[i].length == 3`
- `0 <= xi, yi <= 10^9`
- `1 <= li <= 10^9`
- The total area of all the squares will not exceed `10^12`.
- `1 <= squares.length <= 5 * 10^4`。
- `squares[i] = [xi, yi, li]`。
- `squares[i].length == 3`。
- `0 <= xi, yi <= 10^9`。
- `1 <= li <= 10^9`。
- 所有正方形的總面積不會超過 `10^12`。

## 解題筆記與程式碼

通用演算法筆記：[event_sorting_sweep](../algorithm/event_sorting_sweep.md)
通用演算法筆記：[piecewise_linear_sweep](../algorithm/piecewise_linear_sweep.md)
資料結構筆記：[dynamic_array_vec](../algorithm/dynamic_array_vec.md)

### 思路拆解

- 重疊面積要重複計算，因此每個正方形的面積貢獻可以獨立相加，`x` 座標完全不影響答案。
- 對單一正方形：若水平線高度為 `y`，線下方貢獻面積為 `li * clamp(y - yi, 0, li)`。
- 總面積函數 `F(y)` 是 **連續且單調不減** 的分段線性函數；只要找到 `F(y) = total/2` 的最小 `y` 即可。
- 對每個正方形建立兩個事件：`y = yi` 使斜率 `+li`，`y = yi + li` 使斜率 `-li`；掃描事件即可累積線下方面積並定位答案。

### 演算法

1. 計算 `total = sum(li^2)`，目標面積 `target = total / 2`。
2. 建立事件陣列 `events`：對每個正方形加入 `(yi, +li)` 與 `(yi + li, -li)`。
3. 依 `y` 升冪排序事件，掃描相鄰事件的區間：
   - 令 `slope` 為目前斜率（活躍正方形邊長總和）、`area` 為 `F(prev_y)`。
   - 若 `area + slope * (curr_y - prev_y) >= target`，答案在此區間，回傳
     `prev_y + (target - area) / slope`。
   - 否則更新 `area` 並處理同 `y` 的事件更新 `slope`。
4. 一旦命中區間即可回傳最小 `y`。

### 為什麼只看 y

- 因為重疊要重複計算，每個正方形的貢獻只與其垂直高度切割比例有關；水平線的 `x` 方向位置完全不影響總面積。

### 時間與空間

- 時間：`O(n log n)`，排序事件。
- 空間：`O(n)`，儲存事件與掃描狀態。

```rust
impl Solution {
    pub fn separate_squares(squares: Vec<Vec<i32>>) -> f64 {
        let mut events: Vec<(i64, i64)> = Vec::with_capacity(squares.len() * 2);
        let mut total_area = 0.0f64;

        for s in squares.iter() {
            let y = s[1] as i64;
            let l = s[2] as i64;
            events.push((y, l));
            events.push((y + l, -l));
            total_area += (l as f64) * (l as f64);
        }

        events.sort_by_key(|e| e.0);

        let target = total_area / 2.0;
        let mut area = 0.0f64;
        let mut slope = 0.0f64;
        let mut i = 0usize;

        let mut prev_y = events[0].0;
        while i < events.len() && events[i].0 == prev_y {
            slope += events[i].1 as f64;
            i += 1;
        }

        while i < events.len() {
            let curr_y = events[i].0;
            let dy = (curr_y - prev_y) as f64;

            if slope > 0.0 {
                let next_area = area + slope * dy;
                if target <= next_area {
                    return prev_y as f64 + (target - area) / slope;
                }
                area = next_area;
            }

            prev_y = curr_y;
            while i < events.len() && events[i].0 == curr_y {
                slope += events[i].1 as f64;
                i += 1;
            }
        }

        prev_y as f64
    }
}
```
