[85. Maximal Rectangle](https://leetcode.com/problems/maximal-rectangle/)

Hard

Topics

![premium lock icon](https://leetcode.com/_next/static/images/lock-a6627e2c7fa0ce8bc117c109fb4e567d.svg)Companies

Given a `rows x cols` binary `matrix` filled with `0`'s and `1`'s, find the largest rectangle containing only `1`'s and return its area.
給定 `rows x cols` 的二元矩陣 `matrix`，由 `0` 與 `1` 組成，請找出只包含 `1` 的最大矩形，回傳其面積。

**Example 1:**

![](https://assets.leetcode.com/uploads/2020/09/14/maximal.jpg)

**Input:** matrix = [["1","0","1","0","0"],["1","0","1","1","1"],["1","1","1","1","1"],["1","0","0","1","0"]]
**Output:** 6
**Explanation:** The maximal rectangle is shown in the above picture.
輸入：matrix = [["1","0","1","0","0"],["1","0","1","1","1"],["1","1","1","1","1"],["1","0","0","1","0"]]
輸出：6
說明：最大矩形如圖所示。

**Example 2:**

**Input:** matrix = [["0"]]
**Output:** 0
輸入：matrix = [["0"]]
輸出：0

**Example 3:**

**Input:** matrix = [["1"]]
**Output:** 1
輸入：matrix = [["1"]]
輸出：1

**Constraints:**

- `rows == matrix.length`
- `cols == matrix[i].length`
- `1 <= rows, cols <= 200`
- `matrix[i][j]` is `'0'` or `'1'`.
- `rows == matrix.length`。
- `cols == matrix[i].length`。
- `1 <= rows, cols <= 200`。
- `matrix[i][j]` 為 `'0'` 或 `'1'`。

## 解題筆記與程式碼

通用演算法筆記：[largest_rectangle_histogram](../algorithm/largest_rectangle_histogram.md)
通用資料結構筆記：[stack](../data_structure/stack.md)

### 思路拆解

- 把每一列視為直方圖的底邊：維護 `heights[c]`，連續的 `1` 高度累加，遇到 `0` 歸零。
- 對每列的 `heights` 套用「直方圖最大矩形」的單調遞增堆疊算法，更新答案。
- 每列只需 `O(cols)`，總時間 `O(rows * cols)`。

### 為什麼單調堆疊可用

- 當某個柱高 `h` 被彈出時，它左右兩側第一個更小的柱子已確定，矩形寬度為 `right - left - 1`。
- 每個索引只會進堆疊、出堆疊各一次，線性時間成立。

### 演算法

1. 初始化 `heights` 長度為 `cols`，全為 0。
2. 逐列掃描：
   - 若 `matrix[r][c] == '1'`，`heights[c] += 1`；否則 `heights[c] = 0`。
   - 用單調遞增堆疊計算當前 `heights` 的最大矩形面積，更新全域答案。
3. 回傳最大面積。

### 時間與空間

- 時間：`O(rows * cols)`。
- 空間：`O(cols)`，高度陣列與堆疊。

```rust
impl Solution {
    pub fn maximal_rectangle(matrix: Vec<Vec<char>>) -> i32 {
        if matrix.is_empty() || matrix[0].is_empty() {
            return 0;
        }
        let rows = matrix.len();
        let cols = matrix[0].len();
        let mut heights = vec![0i32; cols];
        let mut ans = 0i32;

        for r in 0..rows {
            for c in 0..cols {
                if matrix[r][c] == '1' {
                    heights[c] += 1;
                } else {
                    heights[c] = 0;
                }
            }
            ans = ans.max(Self::largest_histogram(&heights));
        }
        ans
    }

    fn largest_histogram(heights: &Vec<i32>) -> i32 {
        let mut stack: Vec<usize> = Vec::new();
        let mut max_area = 0i32;
        let mut extended = heights.clone();
        extended.push(0);

        for i in 0..extended.len() {
            let cur = extended[i];
            while let Some(&top) = stack.last() {
                if extended[top] <= cur {
                    break;
                }
                let h = extended[top];
                stack.pop();
                let width = match stack.last() {
                    Some(&left) => i - left - 1,
                    None => i,
                };
                let area = h * width as i32;
                if area > max_area {
                    max_area = area;
                }
            }
            stack.push(i);
        }
        max_area
    }
}
```
