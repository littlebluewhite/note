[955. Delete Columns to Make Sorted II](https://leetcode.com/problems/delete-columns-to-make-sorted-ii/)

Attempted

Medium

Topics

![premium lock icon](https://leetcode.com/_next/static/images/lock-a6627e2c7fa0ce8bc117c109fb4e567d.svg)Companies

You are given an array of `n` strings `strs`, all of the same length.
給你一個長度為 `n` 的字串陣列 `strs`，所有字串的長度相同。

We may choose any deletion indices, and we delete all the characters in those indices for each string.
我們可以選擇要刪除的欄位索引，並對每個字串刪除這些索引的字元。

For example, if we have `strs = ["abcdef","uvwxyz"]` and deletion indices `{0, 2, 3}`, then the final array after deletions is `["bef", "vyz"]`.
例如 `strs = ["abcdef","uvwxyz"]`，刪除索引 `{0, 2, 3}` 後，結果為 `["bef", "vyz"]`。

Suppose we chose a set of deletion indices `answer` such that after deletions, the final array has its elements in **lexicographic** order (i.e., `strs[0] <= strs[1] <= strs[2] <= ... <= strs[n - 1]`). Return the minimum possible value of `answer.length`.
假設我們選擇一組刪除索引 `answer`，使刪除後的陣列滿足 **字典序** 排序（`strs[0] <= strs[1] <= ... <= strs[n - 1]`），請回傳 `answer.length` 的最小值。

**Example 1:**

**Input:** strs = ["ca","bb","ac"]
**Output:** 1
**Explanation:**
After deleting the first column, strs = ["a", "b", "c"].
刪除第一欄後，strs = ["a", "b", "c"]。
Now strs is in lexicographic order (ie. strs[0] <= strs[1] <= strs[2]).
此時 strs 已經字典序非遞減。
We require at least 1 deletion since initially strs was not in lexicographic order, so the answer is 1.
起始時並非字典序，因此至少要刪除 1 欄。

**Example 2:**

**Input:** strs = ["xc","yb","za"]
**Output:** 0
**Explanation:**
strs is already in lexicographic order, so we do not need to delete anything.
strs 已經是字典序，因此不需要刪除。
Note that the rows of strs are not necessarily in lexicographic order:
i.e., it is NOT necessarily true that (strs[0][0] <= strs[0][1] <= ...)
注意每一列本身不一定遞增（例如不保證 strs[0][0] <= strs[0][1] <= ...）。

**Example 3:**

**Input:** strs = ["zyx","wvu","tsr"]
**Output:** 3
**Explanation:** We have to delete every column.
必須刪除所有欄位。

**Constraints:**

- `n == strs.length`
- `1 <= n <= 100`
- `1 <= strs[i].length <= 100`
- `strs[i]` consists of lowercase English letters.
- `n == strs.length`。
- `1 <= n <= 100`。
- `1 <= strs[i].length <= 100`。
- `strs[i]` 僅包含小寫英文字母。

## 解題筆記與程式碼

通用演算法筆記：[greedy_column_scan](../algorithm/greedy_column_scan.md)
通用資料結構筆記：[state_tracking_array](../data_structure/state_tracking_array.md)

### 思路拆解

- 逐欄掃描：如果目前欄位在「尚未確定順序」的相鄰列中出現逆序（`>`），此欄位必須刪除，因為前面的欄位都相等，未來欄位也無法修正這個逆序。
- 若沒有逆序，保留此欄位，並把在此欄位出現嚴格遞增（`<`）的相鄰列標記為「已確定順序」，之後不必再比較。
- 使用 `sorted[i]` 表示 `strs[i] <= strs[i+1]` 的順序已在前面欄位確定。

### 為什麼貪心正確

- 對於尚未確定順序的相鄰列，先前欄位都相等，因此一旦在當前欄位看到 `>`，後面欄位無法彌補這個逆序，只能刪除該欄位。
- 若當前欄位沒有造成逆序，保留該欄位不會破壞可行性，且能永久確定更多相鄰列的順序。

### 演算法

1. 將字串轉為位元組陣列，初始化 `sorted` 長度為 `n-1`。
2. 對每一欄：
   - 若任一尚未確定的相鄰列在此欄位出現逆序，刪除此欄位並計數。
   - 否則，將在此欄位出現嚴格遞增的相鄰列標為已確定。
3. 回傳刪除欄位數量。

### 時間與空間

- 時間：`O(n * m)`，`n` 為字串數、`m` 為字串長度。
- 空間：`O(n)`，只需一個相鄰列狀態陣列。

```rust
impl Solution {
    pub fn min_deletion_size(strs: Vec<String>) -> i32 {
        let n = strs.len();
        if n <= 1 {
            return 0;
        }
        let m = strs[0].len();
        let bytes: Vec<Vec<u8>> = strs.iter().map(|s| s.as_bytes().to_vec()).collect();

        let mut sorted = vec![false; n - 1];
        let mut deletions = 0;

        for col in 0..m {
            let mut bad = false;
            for i in 1..n {
                if !sorted[i - 1] && bytes[i - 1][col] > bytes[i][col] {
                    bad = true;
                    break;
                }
            }
            if bad {
                deletions += 1;
                continue;
            }
            for i in 1..n {
                if !sorted[i - 1] && bytes[i - 1][col] < bytes[i][col] {
                    sorted[i - 1] = true;
                }
            }
        }

        deletions
    }
}
```
