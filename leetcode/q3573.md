[3573. Best Time to Buy and Sell Stock V](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-v/)

Medium

Topics

![premium lock icon](https://leetcode.com/_next/static/images/lock-a6627e2c7fa0ce8bc117c109fb4e567d.svg)Companies

Hint

You are given an integer array `prices` where `prices[i]` is the price of a stock in dollars on the `ith` day, and an integer `k`.
給定整數陣列 `prices`，其中 `prices[i]` 是第 `i` 天的股價，以及整數 `k`。

You are allowed to make at most `k` transactions, where each transaction can be either of the following:
允許最多進行 `k` 筆交易，每筆交易可以是下列兩種之一：

- **Normal transaction**: Buy on day `i`, then sell on a later day `j` where `i < j`. You profit `prices[j] - prices[i]`.
- **一般交易**：在第 `i` 天買入，之後第 `j (i < j)` 天賣出，獲利為 `prices[j] - prices[i]`。
    
- **Short selling transaction**: Sell on day `i`, then buy back on a later day `j` where `i < j`. You profit `prices[i] - prices[j]`.
- **放空交易**：在第 `i` 天賣出，之後第 `j (i < j)` 天買回，獲利為 `prices[i] - prices[j]`。
    

**Note** that you must complete each transaction before starting another. Additionally, you can't buy or sell on the same day you are selling or buying back as part of a previous transaction.
注意：必須先完成前一筆交易再開始下一筆；當天用來平倉（賣出或買回）的日子不能同時再買或賣以開啟新交易。

Return the **maximum** total profit you can earn by making **at most** `k` transactions.
請回傳最多進行 `k` 筆交易時可以得到的最大總獲利。

**Example 1:**

**Input:** prices = [1,7,9,8,2], k = 2

**Output:** 14

**Explanation:**

We can make $14 of profit through 2 transactions:
透過兩筆交易可以賺取 14 的獲利：

- A normal transaction: buy the stock on day 0 for $1 then sell it on day 2 for $9.
- A short selling transaction: sell the stock on day 3 for $8 then buy back on day 4 for $2.
- 一般交易：第 0 天用 1 買入，第 2 天用 9 賣出。
- 放空交易：第 3 天用 8 賣出，第 4 天用 2 買回。

**Example 2:**

**Input:** prices = [12,16,19,19,8,1,19,13,9], k = 3

**Output:** 36

**Explanation:**

We can make $36 of profit through 3 transactions:
透過三筆交易可以賺取 36 的獲利：

- A normal transaction: buy the stock on day 0 for $12 then sell it on day 2 for $19.
- A short selling transaction: sell the stock on day 3 for $19 then buy back on day 4 for $8.
- A normal transaction: buy the stock on day 5 for $1 then sell it on day 6 for $19.
- 一般交易：第 0 天以 12 買入，第 2 天以 19 賣出。
- 放空交易：第 3 天以 19 賣出，第 4 天以 8 買回。
- 一般交易：第 5 天以 1 買入，第 6 天以 19 賣出。

**Constraints:**

- `2 <= prices.length <= 103`
- `1 <= prices[i] <= 109`
- `1 <= k <= prices.length / 2`
- `2 <= prices.length <= 10^3`
- `1 <= prices[i] <= 10^9`
- `1 <= k <= prices.length / 2`

## 解題筆記與程式碼

演算法相關筆記：[k_transactions_long_short_cooldown](../algorithm/k_transactions_long_short_cooldown.md)

### 思路拆解

- 一筆交易一定是「先開倉再平倉」，且平倉當天不能再開新倉；這些限制都能靠 DP 的更新時序自然滿足。
- 同時允許做多/做空 ⇒ 需要兩種持倉狀態，加上一種空手狀態：`rest`（空手）、`long`（持多）、`short`（持空）。
- 交易數只在「平倉」時 +1；開倉不增加交易數，所以狀態要分層表示「已完成 t 筆交易」。
- 為了避免同日先平倉再開倉，當天的狀態僅從「前一日」讀取，算出「當日新陣列」後再整批覆蓋。

### 核心觀察

- 任一交易只取決於開倉與平倉價差；做多或放空可視為兩種「持倉」狀態，獲利分別是 `+price`（賣出平倉多單）與 `-price`（買回平倉空單）。
- 不能在平倉當天重新開倉，使用「前一日的狀態更新當日」的 DP 即可自然禁止同日開收，無須額外冷卻旗標。
- 以「完成 t 筆交易」為狀態維度，維護三個陣列：`rest[t]`（空手）、`long[t]`（持多）、`short[t]`（持空）。開倉不增加交易數，平倉使交易數 +1。

### 演算法

1) 初始化：`rest[0] = 0`，其餘全設極小值（代表不可能）。  
2) 對每一天的價格 `p`：  
   - 先複製前一日的 `rest/long/short` 成為 `next_*`。  
   - 平倉：若持多/持空存在，就嘗試更新 `next_rest[t+1]` 為 `long[t] + p` 或 `short[t] - p`。  
   - 開倉：僅能用「前一日的空手」開倉，更新 `next_long[t] = max(next_long[t], rest[t] - p)`、`next_short[t] = max(next_short[t], rest[t] + p)`。  
   - 全部更新完後，`rest/long/short = next_*`。因為當天只用「舊 rest」開倉，所以同日不會出現先平倉再開倉。  
3) 走完所有天數後，答案是 `rest[0..=k]` 的最大值（空手時的收益）。

### 時間與空間

- 時間：`O(n * k)`，`n <= 10^3, k <= 500` 可接受。  
- 空間：`O(k)` 使用三個長度 `k+1` 的陣列。

```rust
impl Solution {
    pub fn maximum_profit(prices: Vec<i32>, k: i32) -> i64 {
        let k = k as usize;
        let neg: i64 = i64::MIN / 4;
        let mut rest = vec![neg; k + 1];
        let mut long = vec![neg; k + 1];
        let mut short = vec![neg; k + 1];
        rest[0] = 0;

        for &p in &prices {
            let price = p as i64;
            let mut next_rest = rest.clone();
            let mut next_long = long.clone();
            let mut next_short = short.clone();

            for t in 0..=k {
                if t < k {
                    if long[t] != neg {
                        next_rest[t + 1] = next_rest[t + 1].max(long[t] + price);
                    }
                    if short[t] != neg {
                        next_rest[t + 1] = next_rest[t + 1].max(short[t] - price);
                    }
                }
                if rest[t] != neg {
                    next_long[t] = next_long[t].max(rest[t] - price);
                    next_short[t] = next_short[t].max(rest[t] + price);
                }
            }

            rest = next_rest;
            long = next_long;
            short = next_short;
        }

        *rest.iter().max().unwrap()
    }
}
```
