---
title: "q3075"
category: leetcode
tags: [leetcode]
created: 2026-02-03
updated: 2026-02-03
difficulty: Medium
source: leetcode
status: active
complexity_time: O(n log n)
complexity_space: O(1)
---
[3075. Maximize Happiness of Selected Children](https://leetcode.com/problems/maximize-happiness-of-selected-children/)

Medium

Topics

![premium lock icon](https://leetcode.com/_next/static/images/lock-a6627e2c7fa0ce8bc117c109fb4e567d.svg)Companies

Hint

You are given an array `happiness` of length `n`, and a **positive** integer `k`.
給定長度為 `n` 的陣列 `happiness`，以及一個 **正整數** `k`。

There are `n` children standing in a queue, where the `ith` child has **happiness value** `happiness[i]`. You want to select `k` children from these `n` children in `k` turns.
有 `n` 位小孩排成一列，第 `i` 位小孩的 **快樂值** 為 `happiness[i]`。你要在 `k` 回合內從 `n` 位小孩中選出 `k` 位。

In each turn, when you select a child, the **happiness value** of all the children that have **not** been selected till now decreases by `1`. Note that the happiness value **cannot** become negative and gets decremented **only** if it is positive.
每一回合選一位小孩後，所有 **尚未被選到** 的小孩快樂值會減少 `1`。注意快樂值 **不會變成負數**，且只有在快樂值為正時才會遞減。

Return _the **maximum** sum of the happiness values of the selected children you can achieve by selecting_ `k` _children_.
請回傳選出 `k` 位小孩時，所能得到的 **最大** 快樂值總和。

**Example 1:**

**Input:** happiness = [1,2,3], k = 2  
**Output:** 4  
**Explanation:** We can pick 2 children in the following way:  
**說明：** 可以用以下方式選 2 位小孩：  
- Pick the child with the happiness value == 3. The happiness value of the remaining children becomes [0,1].  
  先選快樂值為 3 的小孩，剩下小孩快樂值變成 [0,1]。  
- Pick the child with the happiness value == 1. The happiness value of the remaining child becomes [0]. Note that the happiness value cannot become less than 0.  
  再選快樂值為 1 的小孩，剩下一位變成 [0]，快樂值不會低於 0。  
The sum of the happiness values of the selected children is 3 + 1 = 4.  
被選到的小孩快樂值總和為 3 + 1 = 4。

**Example 2:**

**Input:** happiness = [1,1,1,1], k = 2  
**Output:** 1  
**Explanation:** We can pick 2 children in the following way:  
**說明：** 可以用以下方式選 2 位小孩：  
- Pick any child with the happiness value == 1. The happiness value of the remaining children becomes [0,0,0].  
  先選任一位快樂值為 1 的小孩，剩下變成 [0,0,0]。  
- Pick the child with the happiness value == 0. The happiness value of the remaining child becomes [0,0].  
  再選快樂值為 0 的小孩，剩下變成 [0,0]。  
The sum of the happiness values of the selected children is 1 + 0 = 1.  
被選到的小孩快樂值總和為 1 + 0 = 1。

**Example 3:**

**Input:** happiness = [2,3,4,5], k = 1  
**Output:** 5  
**Explanation:** We can pick 1 child in the following way:  
**說明：** 可以用以下方式選 1 位小孩：  
- Pick the child with the happiness value == 5. The happiness value of the remaining children becomes [1,2,3].  
  選快樂值為 5 的小孩，剩下變成 [1,2,3]。  
The sum of the happiness values of the selected children is 5.  
被選到的小孩快樂值總和為 5。

**Constraints:**

- `1 <= n == happiness.length <= 2 * 10^5`
- `1 <= n == happiness.length <= 2 * 10^5`。
- `1 <= happiness[i] <= 10^8`
- `1 <= happiness[i] <= 10^8`。
- `1 <= k <= n`
- `1 <= k <= n`。

## 解題筆記與程式碼

通用演算法筆記：[greedy_sorting_linear_decay](../algorithm/greedy_sorting_linear_decay.md)
資料結構筆記：[dynamic_array_vec](../algorithm/dynamic_array_vec.md)

### 思路拆解

- 每選一次，未選到的快樂值統一減 1，因此第 `t` 回合選到某位小孩時，實際貢獻為 `max(h - t, 0)`。
- 若有兩位小孩 `a >= b`，把 `a` 放在更早的回合只會讓總和更大或相同，因此應該依快樂值由大到小排序。
- 排序後取前 `k` 個，第 `i` 個的貢獻為 `max(happiness[i] - i, 0)`。

### 為什麼貪婪排序是最優

- 以交換論證：若在某兩回合先選 `b` 後選 `a` 且 `a >= b`，則
  - 原本貢獻為 `max(b - t, 0) + max(a - (t+1), 0)`
  - 交換後貢獻為 `max(a - t, 0) + max(b - (t+1), 0)`
- 交換不會使總和變小，因此排序後依序選取是最優。

### 演算法

1. 將 `happiness` 由大到小排序。
2. 迭代前 `k` 個元素，累加 `max(happiness[i] - i, 0)`。
3. 回傳總和。

### 時間與空間

- 時間：`O(n log n)`，排序為主。
- 空間：`O(1)` 額外空間（就地排序），不含輸入。

```rust
impl Solution {
    pub fn maximum_happiness_sum(mut happiness: Vec<i32>, k: i32) -> i64 {
        happiness.sort_unstable_by(|a, b| b.cmp(a));
        let k = k as usize;
        let mut total: i64 = 0;
        for i in 0..k {
            let gain = happiness[i] as i64 - i as i64;
            if gain > 0 {
                total += gain;
            }
        }
        total
    }
}
```

## 補充筆記：排序後用回合索引當作遞減量即可，不需要模擬整個過程。
