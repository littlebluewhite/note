[1161. Maximum Level Sum of a Binary Tree](https://leetcode.com/problems/maximum-level-sum-of-a-binary-tree/)

Medium

Topics

![premium lock icon](https://leetcode.com/_next/static/images/lock-a6627e2c7fa0ce8bc117c109fb4e567d.svg)Companies

Hint

Given the `root` of a binary tree, the level of its root is `1`, the level of its children is `2`, and so on.
給定二元樹的 `root`，根節點的層級為 `1`，其子節點的層級為 `2`，以此類推。

Return the **smallest** level `x` such that the sum of all the values of nodes at level `x` is **maximal**.
回傳使得該層節點值總和 **最大** 的最小層級 `x`。

**Example 1:**

![](https://assets.leetcode.com/uploads/2019/05/03/capture.JPG)

**Input:** root = [1,7,0,7,-8,null,null]
**Output:** 2
**Explanation:** 
Level 1 sum = 1.
Level 2 sum = 7 + 0 = 7.
Level 3 sum = 7 + -8 = -1.
So we return the level with the maximum sum which is level 2.
**輸入：** root = [1,7,0,7,-8,null,null]
**輸出：** 2
**說明：**
第 1 層總和 = 1。
第 2 層總和 = 7 + 0 = 7。
第 3 層總和 = 7 + -8 = -1。
因此回傳總和最大的層級，為第 2 層。

**Example 2:**

**Input:** root = [989,null,10250,98693,-89388,null,null,null,-32127]
**Output:** 2
**輸入：** root = [989,null,10250,98693,-89388,null,null,null,-32127]
**輸出：** 2

**Constraints:**

- The number of nodes in the tree is in the range `[1, 10^4]`.
- `-10^5 <= Node.val <= 10^5`
- 樹的節點數量介於 `1` 到 `10^4`。
- `-10^5 <= Node.val <= 10^5`。

## 解題筆記與程式碼

通用演算法筆記：[tree_level_order_traversal](../algorithm/tree_level_order_traversal.md)
資料結構筆記：[deque_vecdeque](../data_structure/deque_vecdeque.md)
資料結構筆記：[binary_tree](../data_structure/binary_tree.md)

### 思路拆解

- 用層序遍歷（BFS）逐層累加節點值，得到每一層的總和。
- 維護 `max_sum` 與對應的最小層級 `best_level`，只有在總和 **更大** 時才更新，確保層級最小。
- 以佇列處理每層節點，透過當前佇列長度固定當層範圍。

### 演算法

1. 若 `root` 為空，直接回傳 `0`（題目保證至少 1 個節點，這是防禦式處理）。
2. 將 `root` 放入佇列，`level = 1`，`max_sum = -inf`。
3. 迴圈處理佇列：
   - 取出當前佇列長度 `size` 作為本層節點數。
   - 連續 `size` 次出隊並累加值，將子節點入隊。
   - 若本層總和 > `max_sum`，更新 `max_sum` 與 `best_level`。
   - `level += 1`。
4. 回傳 `best_level`。

### 時間與空間

- 時間：`O(n)`，每個節點只處理一次。
- 空間：`O(w)`，`w` 為樹的最大寬度（最壞 `O(n)`）。

```rust
// Definition for a binary tree node.
// #[derive(Debug, PartialEq, Eq)]
// pub struct TreeNode {
//   pub val: i32,
//   pub left: Option<Rc<RefCell<TreeNode>>>,
//   pub right: Option<Rc<RefCell<TreeNode>>>,
// }
//
// impl TreeNode {
//   #[inline]
//   pub fn new(val: i32) -> Self {
//     TreeNode {
//       val,
//       left: None,
//       right: None
//     }
//   }
// }

use std::rc::Rc;
use std::cell::RefCell;
use std::collections::VecDeque;
impl Solution {
	pub fn max_level_sum(root: Option<Rc<RefCell<TreeNode>>>) -> i32 {
		if root.is_none() {
			return 0;
		}

		let mut q: VecDeque<Rc<RefCell<TreeNode>>> = VecDeque::new();
		q.push_back(root.unwrap());

		let mut level: i32 = 1;
		let mut best_level: i32 = 1;
		let mut best_sum: i64 = i64::MIN;

		while !q.is_empty() {
			let size = q.len();
			let mut sum: i64 = 0;
			for _ in 0..size {
				let node_rc = q.pop_front().unwrap();
				let (val, left, right) = {
					let node = node_rc.borrow();
					(node.val, node.left.clone(), node.right.clone())
				};
				sum += val as i64;
				if let Some(left) = left {
					q.push_back(left);
				}
				if let Some(right) = right {
					q.push_back(right);
				}
			}

			if sum > best_sum {
				best_sum = sum;
				best_level = level;
			}
			level += 1;
		}

		best_level
	}
}
```
