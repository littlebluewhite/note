---
title: "q960"
category: leetcode
tags: [leetcode]
created: 2026-02-03
updated: 2026-02-03
difficulty: Hard
source: leetcode
status: active
complexity_time: O(m^2 * n)
complexity_space: O(m)
---
# q960

[960. Delete Columns to Make Sorted III](https://leetcode.com/problems/delete-columns-to-make-sorted-iii/)

Attempted

Hard

Topics

![premium lock icon](https://leetcode.com/_next/static/images/lock-a6627e2c7fa0ce8bc117c109fb4e567d.svg)Companies

You are given an array of `n` strings `strs`, all of the same length.
給定長度相同的 `n` 個字串陣列 `strs`。

We may choose any deletion indices, and we delete all the characters in those indices for each string.
我們可以選擇任意刪除索引，並對每個字串刪除這些位置的字元。

For example, if we have `strs = ["abcdef","uvwxyz"]` and deletion indices `{0, 2, 3}`, then the final array after deletions is `["bef", "vyz"]`.
例如 `strs = ["abcdef","uvwxyz"]` 且刪除索引 `{0, 2, 3}`，刪除後為 `["bef", "vyz"]`。

Suppose we chose a set of deletion indices `answer` such that after deletions, the final array has **every string (row) in lexicographic** order. (i.e., `(strs[0][0] <= strs[0][1] <= ... <= strs[0][strs[0].length - 1])`, and `(strs[1][0] <= strs[1][1] <= ... <= strs[1][strs[1].length - 1])`, and so on). Return _the minimum possible value of_ `answer.length`.
假設我們選擇一組刪除索引 `answer`，使得刪除後的每一列字串都符合 **字典序非遞減**（也就是每列都滿足 `strs[r][0] <= strs[r][1] <= ...`）。請回傳 `answer.length` 的最小可能值。

**Example 1:**

**Input:** strs = ["babca","bbazb"]
**Output:** 3
**Explanation:** After deleting columns 0, 1, and 4, the final array is strs = ["bc", "az"].
刪除第 0、1、4 欄後得到 `["bc", "az"]`。
Both these rows are individually in lexicographic order (ie. strs[0][0] <= strs[0][1] and strs[1][0] <= strs[1][1]).
兩列各自都符合非遞減。
Note that strs[0] > strs[1] - the array strs is not necessarily in lexicographic order.
注意：整體列與列之間不需要排序。

**Example 2:**

**Input:** strs = ["edcba"]
**Output:** 4
**Explanation:** If we delete less than 4 columns, the only row will not be lexicographically sorted.
刪除少於 4 欄，唯一一列不可能非遞減。

**Example 3:**

**Input:** strs = ["ghi","def","abc"]
**Output:** 0
**Explanation:** All rows are already lexicographically sorted.
所有列原本就已非遞減。

**Constraints:**

- `n == strs.length`
- `1 <= n <= 100`
- `1 <= strs[i].length <= 100`
- `strs[i]` consists of lowercase English letters.
- `n == strs.length`。
- `1 <= n <= 100`。
- `1 <= strs[i].length <= 100`。
- `strs[i]` 由小寫英文字母組成。

```rust
impl Solution {
    pub fn min_deletion_size(strs: Vec<String>) -> i32 {
        let n = strs.len();
        let m = strs[0].len();
        let rows: Vec<Vec<u8>> = strs.into_iter().map(|s| s.into_bytes()).collect();

        let mut dp = vec![1usize; m];
        for j in 0..m {
            for i in 0..j {
                let mut ok = true;
                for r in 0..n {
                    if rows[r][i] > rows[r][j] {
                        ok = false;
                        break;
                    }
                }
                if ok {
                    dp[j] = dp[j].max(dp[i] + 1);
                }
            }
        }

        let keep = *dp.iter().max().unwrap_or(&0);
        (m - keep) as i32
    }
}
```

## 解題筆記與程式碼

通用演算法筆記：[longest_chain_dp](../algorithm/longest_chain_dp.md)
通用資料結構筆記：[dp_1d_array](../data_structure/dp_1d_array.md)

### 核心觀察

- 需要保留一個「欄位子序列」，使得每一列在這些欄位上都是非遞減。
- 若把欄位當成序列位置，欄位 `i` 能接在欄位 `j` 後面（`i < j`）的條件是：對所有列 `r`，`strs[r][i] <= strs[r][j]`。
- 因此答案是：欄位數 `m` 減去「滿足上述條件的最長鏈長度」。

### 演算法

1. 將每列字串轉成 bytes，方便 `O(1)` 比較欄位字元。
2. 定義 `dp[j]`：以第 `j` 欄結尾的最長可行欄位子序列長度。
3. 對每個 `j`，枚舉所有 `i < j`，若對所有列皆滿足 `col[i] <= col[j]`，則 `dp[j] = max(dp[j], dp[i] + 1)`。
4. `max(dp)` 是最大可保留欄位數，答案為 `m - max(dp)`。

### 為什麼用 `dp[i] + 1` 更新 `dp[j]`

`dp[j]` 的定義是「以第 `j` 欄結尾的最長可行欄位鏈長度」。若欄位 `i` 可以接到欄位 `j`（對所有列都滿足 `col[i] <= col[j]`），那麼「以 `i` 結尾的最佳鏈」再加上欄位 `j`，就形成一條更長的鏈，所以候選長度是 `dp[i] + 1`。這就是欄位上的最長非遞減子序列轉移。

### 範例手動跑一次 dp 表

以 `strs = ["babca","bbazb"]` 為例，欄位如下（每欄是兩列的字元對）：

- `c0 = (b, b)`
- `c1 = (a, b)`
- `c2 = (b, a)`
- `c3 = (c, z)`
- `c4 = (a, b)`

初始化：`dp = [1, 1, 1, 1, 1]`

- `j=0`: 無前欄，`dp[0]=1`
- `j=1`: `i=0` 不可接（`b > a`），`dp[1]=1`
- `j=2`: `i=0,1` 都不可接（第二列 `b > a`），`dp[2]=1`
- `j=3`: `i=0,1,2` 都可接，`dp[3]=max(1, dp[i]+1)=2`
- `j=4`: 只有 `i=1` 可接，`dp[4]=max(1, dp[1]+1)=2`

最後 `dp = [1, 1, 1, 2, 2]`，可保留欄數 `max(dp)=2`，刪除 `5-2=3` 欄。

### 時間與空間

- 時間：`O(m^2 * n)`，`m` 為欄位數，`n` 為列數。
- 空間：`O(m)` 的 DP 陣列。
