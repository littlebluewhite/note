[2977. Minimum Cost to Convert String II](https://leetcode.com/problems/minimum-cost-to-convert-string-ii/)

Hard

Topics

![premium lock icon](https://leetcode.com/_next/static/images/lock-a6627e2c7fa0ce8bc117c109fb4e567d.svg)Companies

Hint

You are given two **0-indexed** strings `source` and `target`, both of length `n` and consisting of **lowercase** English characters. You are also given two **0-indexed** string arrays `original` and `changed`, and an integer array `cost`, where `cost[i]` represents the cost of converting the string `original[i]` to the string `changed[i]`.
給定兩個 **0-indexed** 字串 `source` 與 `target`，長度皆為 `n`，且只包含 **小寫** 英文字母。另給兩個 **0-indexed** 字串陣列 `original`、`changed`，以及整數陣列 `cost`，其中 `cost[i]` 表示把 `original[i]` 轉成 `changed[i]` 的成本。

You start with the string `source`. In one operation, you can pick a **substring** `x` from the string, and change it to `y` at a cost of `z` **if** there exists **any** index `j` such that `cost[j] == z`, `original[j] == x`, and `changed[j] == y`. You are allowed to do **any** number of operations, but any pair of operations must satisfy **either** of these two conditions:
一開始字串為 `source`。一次操作中，你可選擇一段 **子字串** `x`，並以成本 `z` 把它改成 `y`，**前提是** 存在某個索引 `j` 使得 `cost[j] == z`、`original[j] == x` 且 `changed[j] == y`。你可以做 **任意多次** 操作，但任兩次操作必須滿足 **以下之一**：

- The substrings picked in the operations are `source[a..b]` and `source[c..d]` with either `b < c` **or** `d < a`. In other words, the indices picked in both operations are **disjoint**.
- The substrings picked in the operations are `source[a..b]` and `source[c..d]` with `a == c` **and** `b == d`. In other words, the indices picked in both operations are **identical**.
- 兩次操作選到的子字串為 `source[a..b]` 與 `source[c..d]`，且 `b < c` **或** `d < a`，也就是兩段索引 **不重疊**。
- 兩次操作選到的子字串為 `source[a..b]` 與 `source[c..d]`，且 `a == c` **且** `b == d`，也就是兩段索引 **完全相同**。

Return the **minimum** cost to convert the string `source` to the string `target` using **any** number of operations. If it is impossible to convert `source` to `target`, return `-1`.
請回傳用 **任意次** 操作把 `source` 轉成 `target` 的 **最小** 成本；若無法轉換，回傳 `-1`。

**Note** that there may exist indices `i`, `j` such that `original[j] == original[i]` and `changed[j] == changed[i]`.
**注意** 可能存在 `i`, `j` 使得 `original[j] == original[i]` 且 `changed[j] == changed[i]`。

**Example 1:**

**Input:** source = "abcd", target = "acbe", original = ["a","b","c","c","e","d"], changed = ["b","c","b","e","b","e"], cost = [2,5,5,1,2,20]
**Output:** 28
**Explanation:** To convert "abcd" to "acbe", do the following operations:
- Change substring source[1..1] from "b" to "c" at a cost of 5.
- Change substring source[2..2] from "c" to "e" at a cost of 1.
- Change substring source[2..2] from "e" to "b" at a cost of 2.
- Change substring source[3..3] from "d" to "e" at a cost of 20.
The total cost incurred is 5 + 1 + 2 + 20 = 28.
It can be shown that this is the minimum possible cost.
**說明：** 要把 "abcd" 轉成 "acbe"，可做以下操作：
- 將 source[1..1] 的 "b" 改成 "c"，成本 5。
- 將 source[2..2] 的 "c" 改成 "e"，成本 1。
- 將 source[2..2] 的 "e" 改成 "b"，成本 2。
- 將 source[3..3] 的 "d" 改成 "e"，成本 20。
總成本為 5 + 1 + 2 + 20 = 28。
可證明 28 為最小可能成本。

**Example 2:**

**Input:** source = "abcdefgh", target = "acdeeghh", original = ["bcd","fgh","thh"], changed = ["cde","thh","ghh"], cost = [1,3,5]
**Output:** 9
**Explanation:** To convert "abcdefgh" to "acdeeghh", do the following operations:
- Change substring source[1..3] from "bcd" to "cde" at a cost of 1.
- Change substring source[5..7] from "fgh" to "thh" at a cost of 3. We can do this operation because indices [5,7] are disjoint with indices picked in the first operation.
- Change substring source[5..7] from "thh" to "ghh" at a cost of 5. We can do this operation because indices [5,7] are disjoint with indices picked in the first operation, and identical with indices picked in the second operation.
The total cost incurred is 1 + 3 + 5 = 9.
It can be shown that this is the minimum possible cost.
**說明：** 要把 "abcdefgh" 轉成 "acdeeghh"，可做以下操作：
- 將 source[1..3] 的 "bcd" 改成 "cde"，成本 1。
- 將 source[5..7] 的 "fgh" 改成 "thh"，成本 3。此操作與第一個操作的索引 [5,7] **不重疊**。
- 將 source[5..7] 的 "thh" 改成 "ghh"，成本 5。此操作與第一個操作不重疊，且與第二個操作索引 **完全相同**。
總成本為 1 + 3 + 5 = 9。
可證明 9 為最小可能成本。

**Example 3:**

**Input:** source = "abcdefgh", target = "addddddd", original = ["bcd","defgh"], changed = ["ddd","ddddd"], cost = [100,1578]
**Output:** -1
**Explanation:** It is impossible to convert "abcdefgh" to "addddddd".
If you select substring source[1..3] as the first operation to change "abcdefgh" to "adddefgh", you cannot select substring source[3..7] as the second operation because it has a common index, 3, with the first operation.
If you select substring source[3..7] as the first operation to change "abcdefgh" to "abcddddd", you cannot select substring source[1..3] as the second operation because it has a common index, 3, with the first operation.
**說明：** 無法把 "abcdefgh" 轉成 "addddddd"。
若先選 source[1..3] 把 "abcdefgh" 變成 "adddefgh"，第二次就不能選 source[3..7]，因為索引 3 與第一次操作 **重疊**。
若先選 source[3..7] 把 "abcdefgh" 變成 "abcddddd"，第二次也不能選 source[1..3]，同樣因為索引 3 **重疊**。

**Constraints:**

- `1 <= source.length == target.length <= 1000`
- `source`, `target` consist only of lowercase English characters.
- `1 <= cost.length == original.length == changed.length <= 100`
- `1 <= original[i].length == changed[i].length <= source.length`
- `original[i]`, `changed[i]` consist only of lowercase English characters.
- `original[i] != changed[i]`
- `1 <= cost[i] <= 10^6`
- `1 <= source.length == target.length <= 1000`。
- `source`、`target` 只包含小寫英文字母。
- `1 <= cost.length == original.length == changed.length <= 100`。
- `1 <= original[i].length == changed[i].length <= source.length`。
- `original[i]`、`changed[i]` 只包含小寫英文字母。
- `original[i] != changed[i]`。
- `1 <= cost[i] <= 10^6`。

## 解題筆記與程式碼

通用演算法筆記：[floyd_warshall_all_pairs_shortest_path](../algorithm/floyd_warshall_all_pairs_shortest_path.md)
通用演算法筆記：[dp_dynamic_programming](../algorithm/dp_dynamic_programming.md)
資料結構筆記：[hash_map_set](../data_structure/hash_map_set.md)
資料結構筆記：[dp_1d_array](../data_structure/dp_1d_array.md)

### 思路拆解

- 每次操作的子字串要嘛 **不重疊**，要嘛 **完全相同**。因此真正會連續套用多次的操作，只會發生在同一段索引上，可視為「同一段字串上的多步轉換」。
- 單次操作不改變長度，連續多次操作也不改變長度，所以所有可達轉換都限制在 **相同長度** 的字串之間。
- 把 `original`/`changed` 出現過的字串視為節點，對每個長度獨立建圖並做 **全點對最短路徑**，得到任意兩個字串間的最小轉換成本。
- 最後用一維 DP 切割字串：對每個位置 `i`，要嘛不動（`source[i] == target[i]`），要嘛選一段長度 `L` 的子字串做一次「最短轉換」。

### 為什麼可以用「最短路徑 + 切割 DP」

- 「相同索引」允許你在同一段上重複操作，等價於在該段字串圖上走一條路徑；最省成本就是最短路徑。
- 「不重疊」限制讓每段操作互不干擾，因此全局最小成本可以由左到右切割並用 DP 累積。

### 演算法

1. 收集 `original` 與 `changed` 的所有不同字串，依長度分組並編號。
2. 對每個長度建立距離矩陣 `dist`：
   - `dist[i][i] = 0`
   - 對每條規則 `original -> changed`，取最小成本更新 `dist`
   - 以 Floyd-Warshall 算出最短路徑
3. 一維 DP：`dp[i]` 表示轉換 `source[0..i-1]` 的最小成本。
   - 若 `source[i] == target[i]`，可不操作：`dp[i+1] = min(dp[i+1], dp[i])`
   - 對每個可用長度 `L`：
     - 若 `source[i..i+L)` 與 `target[i..i+L)` 都在字典中且最短距離有限，更新 `dp[i+L]`
4. 若 `dp[n]` 有限，回傳 `dp[n]`，否則回傳 `-1`。

### 時間與空間

- 設 `K` 為不同字串總數（`K <= 200`），`n` 為字串長度（`n <= 1000`）。
- Floyd-Warshall：`O(sum K_L^3) <= O(K^3)`。
- DP：`O(n * Lmax)`，其中 `Lmax` 為規則中字串最大長度（`<= 1000`，通常 `<= 100`）。
- 空間：`O(K^2 + n)`。

```rust
use std::collections::HashMap;

impl Solution {
    pub fn minimum_cost(
        source: String,
        target: String,
        original: Vec<String>,
        changed: Vec<String>,
        cost: Vec<i32>,
    ) -> i64 {
        let n = source.len();
        let inf: i64 = i64::MAX / 4;

        let mut id_map: HashMap<usize, HashMap<String, usize>> = HashMap::new();
        let mut strings_by_len: HashMap<usize, Vec<String>> = HashMap::new();

        for s in original.iter().chain(changed.iter()) {
            let len = s.len();
            let entry = id_map.entry(len).or_insert_with(HashMap::new);
            if !entry.contains_key(s) {
                let id = entry.len();
                entry.insert(s.clone(), id);
                strings_by_len.entry(len).or_insert_with(Vec::new).push(s.clone());
            }
        }

        let mut dist_by_len: HashMap<usize, Vec<Vec<i64>>> = HashMap::new();
        for (len, map) in id_map.iter() {
            let m = map.len();
            let mut dist = vec![vec![inf; m]; m];
            for i in 0..m {
                dist[i][i] = 0;
            }
            dist_by_len.insert(*len, dist);
        }

        for i in 0..cost.len() {
            let len = original[i].len();
            let map = &id_map[&len];
            let u = map[&original[i]];
            let v = map[&changed[i]];
            let dist = dist_by_len.get_mut(&len).unwrap();
            let c = cost[i] as i64;
            if c < dist[u][v] {
                dist[u][v] = c;
            }
        }

        for (_len, dist) in dist_by_len.iter_mut() {
            let m = dist.len();
            for k in 0..m {
                for i in 0..m {
                    let ik = dist[i][k];
                    if ik == inf {
                        continue;
                    }
                    for j in 0..m {
                        let kj = dist[k][j];
                        if kj == inf {
                            continue;
                        }
                        let nd = ik + kj;
                        if nd < dist[i][j] {
                            dist[i][j] = nd;
                        }
                    }
                }
            }
        }

        let source_bytes = source.as_bytes();
        let target_bytes = target.as_bytes();
        let mut lengths: Vec<usize> = id_map.keys().cloned().collect();
        lengths.sort_unstable();

        let mut dp = vec![inf; n + 1];
        dp[0] = 0;

        for i in 0..n {
            if dp[i] == inf {
                continue;
            }
            if source_bytes[i] == target_bytes[i] {
                if dp[i] < dp[i + 1] {
                    dp[i + 1] = dp[i];
                }
            }

            for &len in &lengths {
                if i + len > n {
                    break;
                }
                let s_sub = std::str::from_utf8(&source_bytes[i..i + len]).unwrap();
                let t_sub = std::str::from_utf8(&target_bytes[i..i + len]).unwrap();
                let map = &id_map[&len];
                let sid = match map.get(s_sub) {
                    Some(&v) => v,
                    None => continue,
                };
                let tid = match map.get(t_sub) {
                    Some(&v) => v,
                    None => continue,
                };
                let dist = dist_by_len[&len][sid][tid];
                if dist == inf {
                    continue;
                }
                let nd = dp[i] + dist;
                if nd < dp[i + len] {
                    dp[i + len] = nd;
                }
            }
        }

        if dp[n] >= inf {
            -1
        } else {
            dp[n]
        }
    }
}
```

### 程式碼逐步解析

1. **初始化與資料結構**
   - `n`：`source` 長度。
   - `inf`：代表不可達的超大值。
   - `id_map[len][string] = id`：依「長度」分組後的字串編號表。
   - `strings_by_len`：收集同長度字串（此版本未再使用，保留無妨）。

2. **蒐集所有可用字串並編號**
   - 掃過 `original` 與 `changed`，把出現過的字串加入 `id_map`。
   - 只要是轉換規則出現過的字串，就會成為圖上的節點。

3. **建立每個長度的距離矩陣**
   - 對每個長度 `len` 建 `m x m` 的 `dist`。
   - `dist[i][i] = 0`，其餘設為 `inf`。

4. **寫入直接轉換邊**
   - 針對每條規則 `original[i] -> changed[i]`，更新 `dist[u][v]` 為最小成本。

5. **Floyd-Warshall：同長度字串的最短轉換成本**
   - 允許在同一段索引上多次操作，因此等價於在圖上走多步。
   - 計算任意兩字串間的最短路徑成本。

6. **DP 初始化**
   - `dp[i]` 表示把 `source[0..i)` 轉成 `target[0..i)` 的最小成本。
   - `dp[0] = 0`，其餘為 `inf`。
   - 收集並排序所有規則長度 `lengths`，方便提前 `break`。

7. **DP 主迴圈（從左到右切割）**
   - 若 `source[i] == target[i]`，可不操作：`dp[i+1] = min(dp[i+1], dp[i])`。
   - 枚舉每個可用長度 `len`：
     - 若 `i+len > n`，停止（長度已過界）。
     - 取 `source[i..i+len)` 與 `target[i..i+len)`。
     - 兩者都需在字典中，且最短距離 `dist` 有限。
     - 更新 `dp[i+len] = min(dp[i+len], dp[i] + dist)`。

8. **回傳答案**
   - 若 `dp[n]` 仍為 `inf`，代表不可達，回傳 `-1`。
   - 否則回傳 `dp[n]`。
