---
title: "q3651"
category: leetcode
tags: [leetcode]
created: 2026-02-03
updated: 2026-02-03
difficulty: Hard
source: leetcode
status: active
complexity_time: O(mn log(mn) + k * mn)
complexity_space: O(mn)
---
[3651. Minimum Cost Path with Teleportations](https://leetcode.com/problems/minimum-cost-path-with-teleportations/)

Hard

Topics

![premium lock icon](https://leetcode.com/_next/static/images/lock-a6627e2c7fa0ce8bc117c109fb4e567d.svg)Companies

Hint

You are given a `m x n` 2D integer array `grid` and an integer `k`. You start at the top-left cell `(0, 0)` and your goal is to reach the bottom-right cell `(m - 1, n - 1)`.
給定 `m x n` 的二維整數陣列 `grid` 與整數 `k`。你從左上角 `(0, 0)` 出發，目標到達右下角 `(m - 1, n - 1)`。

There are two types of moves available:
可用的移動方式有兩種：

- **Normal move**: You can move right or down from your current cell `(i, j)`, i.e. you can move to `(i, j + 1)` (right) or `(i + 1, j)` (down). The cost is the value of the destination cell.
- **一般移動**：從 `(i, j)` 往右或往下，抵達 `(i, j + 1)` 或 `(i + 1, j)`，花費為「目的地格子的值」。

- **Teleportation**: You can teleport from any cell `(i, j)` to any cell `(x, y)` such that `grid[x][y] <= grid[i][j]`; the cost of this move is 0. You may teleport at most `k` times.
- **傳送**：可從 `(i, j)` 傳送到任意 `(x, y)`，但需滿足 `grid[x][y] <= grid[i][j]`，傳送成本為 0。最多可傳送 `k` 次。

Return the **minimum** total cost to reach cell `(m - 1, n - 1)` from `(0, 0)`.
請回傳從 `(0, 0)` 到 `(m - 1, n - 1)` 的**最小**總成本。

**Example 1:**

**Input:** grid = [ [1,3,3],[2,5,4],[4,3,5] ], k = 2
**Output:** 7

**Explanation:**
Initially we are at (0, 0) and cost is 0.
初始在 (0, 0)，成本為 0。

|Current Position|Move|New Position|Total Cost|
|---|---|---|---|
|`(0, 0)`|Move Down|`(1, 0)`|`0 + 2 = 2`|
|`(1, 0)`|Move Right|`(1, 1)`|`2 + 5 = 7`|
|`(1, 1)`|Teleport to `(2, 2)`|`(2, 2)`|`7 + 0 = 7`|

The minimum cost to reach bottom-right cell is 7.
到達右下角的最小成本為 7。

**Step-by-step cost matrices (from each cell to end, cost at end = 0, exclude current cell value):**

Step 0 (t = 0, no teleport, after normal moves):
```
[
  [14, 12,  9],
  [12,  8,  5],
  [ 8,  5,  0]
]
```

Step 1 (t = 1):

After teleport sweep:
```
[
  [14,  5,  5],
  [12,  0,  5],
  [ 5,  5,  0]
]
```

After normal moves (DP_1):
```
[
  [ 7,  5,  5],
  [ 5,  0,  5],
  [ 5,  5,  0]
]
```

Step 2 (t = 2):

After teleport sweep:
```
[
  [ 7,  5,  5],
  [ 5,  0,  5],
  [ 5,  5,  0]
]
```

After normal moves (DP_2):
```
[
  [ 7,  5,  5],
  [ 5,  0,  5],
  [ 5,  5,  0]
]
```

**Step-by-step cost matrices (from start to each cell, start cost = 0, include destination cell value):**

Step 0 (t = 0, no teleport, after normal moves):
```
[
  [0, 3, 6],
  [2, 7, 10],
  [6, 9, 14]
]
```

Step 1 (t = 1):

After teleport sweep:
```
[
  [0, 3, 3],
  [2, 7, 6],
  [6, 3, 7]
]
```

After normal moves (DP_1):
```
[
  [0, 3, 3],
  [2, 7, 6],
  [6, 3, 7]
]
```

Step 2 (t = 2):

After teleport sweep:
```
[
  [0, 3, 3],
  [2, 7, 6],
  [6, 3, 7]
]
```

After normal moves (DP_2):
```
[
  [0, 3, 3],
  [2, 7, 6],
  [6, 3, 7]
]
```

**Per-move path matrices (one optimal path, "." = not visited yet):**

Step 0 (start at (0, 0), cost = 0):
```
[
  [0, ., .],
  [., ., .],
  [., ., .]
]
```

Step 1 (move down to (1, 0), cost = 2):
```
[
  [0, ., .],
  [2, ., .],
  [., ., .]
]
```

Step 2 (move right to (1, 1), cost = 7):
```
[
  [0, ., .],
  [2, 7, .],
  [., ., .]
]
```

Step 3 (teleport to (2, 2), cost = 7):
```
[
  [0, ., .],
  [2, 7, .],
  [., ., 7]
]
```

**Example 2:**

**Input:** grid = [ [1,2],[2,3],[3,4] ], k = 1
**Output:** 9

**Explanation:**
Initially we are at (0, 0) and cost is 0.
初始在 (0, 0)，成本為 0。

|Current Position|Move|New Position|Total Cost|
|---|---|---|---|
|`(0, 0)`|Move Down|`(1, 0)`|`0 + 2 = 2`|
|`(1, 0)`|Move Right|`(1, 1)`|`2 + 3 = 5`|
|`(1, 1)`|Move Down|`(2, 1)`|`5 + 4 = 9`|

The minimum cost to reach bottom-right cell is 9.
到達右下角的最小成本為 9。

**Step-by-step cost matrices (from each cell to end, cost at end = 0, exclude current cell value):**

Step 0 (t = 0, no teleport, after normal moves):
```
[
  [9, 7],
  [7, 4],
  [4, 0]
]
```

Step 1 (t = 1):

After teleport sweep:
```
[
  [9, 7],
  [7, 4],
  [4, 0]
]
```

After normal moves (DP_1):
```
[
  [9, 7],
  [7, 4],
  [4, 0]
]
```

**Step-by-step cost matrices (from start to each cell, start cost = 0, include destination cell value):**

Step 0 (t = 0, no teleport, after normal moves):
```
[
  [0, 2],
  [2, 5],
  [5, 9]
]
```

Step 1 (t = 1):

After teleport sweep:
```
[
  [0, 2],
  [2, 5],
  [5, 9]
]
```

After normal moves (DP_1):
```
[
  [0, 2],
  [2, 5],
  [5, 9]
]
```

**Per-move path matrices (one optimal path, "." = not visited yet):**

Step 0 (start at (0, 0), cost = 0):
```
[
  [0, .],
  [., .],
  [., .]
]
```

Step 1 (move down to (1, 0), cost = 2):
```
[
  [0, .],
  [2, .],
  [., .]
]
```

Step 2 (move right to (1, 1), cost = 5):
```
[
  [0, .],
  [2, 5],
  [., .]
]
```

Step 3 (move down to (2, 1), cost = 9):
```
[
  [0, .],
  [2, 5],
  [., 9]
]
```

**Constraints:**

- `2 <= m, n <= 80`
- `m == grid.length`
- `n == grid[i].length`
- `0 <= grid[i][j] <= 10^4`
- `0 <= k <= 10`
- `2 <= m, n <= 80`。
- `m == grid.length`。
- `n == grid[i].length`。
- `0 <= grid[i][j] <= 10^4`。
- `0 <= k <= 10`。

## 解題筆記與程式碼

通用演算法筆記：[dp_dynamic_programming](../algorithm/dp_dynamic_programming.md)
通用演算法筆記：[value_sorted_prefix_min_sweep](../algorithm/value_sorted_prefix_min_sweep.md)
資料結構筆記：[dp_2d_array](../data_structure/dp_2d_array.md)
資料結構筆記：[sorted_array](../data_structure/sorted_array.md)

### 思路拆解

- 定義 `costs[t][i][j]` 表示「從 `(i, j)` 走到 `(m-1, n-1)`、最多使用 `t` 次傳送」的最小成本。
- 一般移動轉移：`costs[t][i][j] = min(costs[t][i+1][j] + grid[i+1][j], costs[t][i][j+1] + grid[i][j+1])`。
- 傳送轉移：`costs[t][i][j] = min(costs[t-1][x][y])`，其中 `grid[x][y] <= grid[i][j]`。
- 關鍵在於**快速求「值 <= 當前格子」的最小值**：將所有座標依 `grid` 值排序，用前綴最小值掃描。遇到相同值要「成批更新」，避免同一輪內互相污染。
- `costs[t]` 只依賴 `costs[t-1]`，可原地覆寫成 `costs[i][j]` 以節省空間。

### 為什麼要「排序 + 前綴最小值」

- 直接對每格掃描所有 `grid[x][y] <= grid[i][j]` 會是 `O((mn)^2)`，不可行。
- 先把所有格子依 `grid` 值升冪排列，掃描時維護 `minCost`（前面看過的最小值），即可把傳送轉移降成 `O(mn)`。
- 相同值要先收集成區間 `[j, i]`，等 `minCost` 完整更新後再統一寫回，確保使用的是「上一輪」的成本值。

### 演算法

1. 收集所有座標 `(i, j)`，依 `grid[i][j]` 升冪排序成 `points`。
2. 初始化 `costs[i][j] = +inf`。
3. 重複 `k + 1` 輪：先掃描 `points` 以 `minCost` 更新同值區間（傳送轉移），再倒序掃描網格更新右/下最小成本並設定終點為 0（一般移動轉移）。
4. 回傳 `costs[0][0]`。

### 時間與空間

- 時間：`O(mn log(mn) + k * mn)`，排序一次 + 每輪線性掃描。
- 空間：`O(mn)`。

```rust
impl Solution {
    pub fn min_cost(grid: Vec<Vec<i32>>, k: i32) -> i32 {
        let m = grid.len();
        let n = grid[0].len();
        let mut points = vec![];
        for i in 0..m {
            for j in 0..n {
                points.push((i, j));
            }
        }
        points.sort_by_key(|&(i, j)| grid[i][j]);

        let mut costs = vec![vec![i32::MAX; n]; m];
        for _ in 0..=k {
            let mut min_cost = i32::MAX;
            let mut i = 0;
            let mut j = 0;
            while i < points.len() {
                min_cost = min_cost.min(costs[points[i].0][points[i].1]);
                if i + 1 < points.len()
                    && grid[points[i].0][points[i].1]
                        == grid[points[i + 1].0][points[i + 1].1]
                {
                    i += 1;
                    continue;
                }
                for r in j..=i {
                
                    let p = points[r];
                    costs[p.0][p.1] = min_cost;
                }
                j = i + 1;
                i += 1;
            }

            for i in (0..m).rev() {
                for j in (0..n).rev() {
                    if i == m - 1 && j == n - 1 {
                        costs[i][j] = 0;
                        continue;
                    }
                    if i != m - 1 {
                        costs[i][j] = costs[i][j].min(costs[i + 1][j] + grid[i + 1][j]);
                    }
                    if j != n - 1 {
                        costs[i][j] = costs[i][j].min(costs[i][j + 1] + grid[i][j + 1]);
                    }
                }
            }
        }
        costs[0][0]
    }
}
```

## 補充筆記

- 先做傳送轉移、再做一般移動，等價於「本輪最多多用一次傳送」。
- 相同 `grid` 值的區間一定要批次寫回，避免同輪使用更新後的值。
