---
title: "q3379"
category: leetcode
tags: [leetcode]
created: 2026-02-05
updated: 2026-02-05
difficulty: Easy
source: leetcode
status: active
complexity_time: O(n)
complexity_space: O(n)
---
# q3379

[3379. Transformed Array](https://leetcode.com/problems/transformed-array/)

Easy

Topics: Array, Simulation

## 題目 / Problem

You are given an integer array `nums` that represents a circular array. Your task is to create a new array `result` of the **same** size, following these rules:
給定整數陣列 `nums`，視為一個環狀陣列。請建立 **同樣大小** 的新陣列 `result`，規則如下：

For each index `i` (where `0 <= i < nums.length`), perform the following **independent** actions:
對每個索引 `i`（`0 <= i < nums.length`），分別獨立處理：

- If `nums[i] > 0`: Start at index `i` and move `nums[i]` steps to the **right** in the circular array. Set `result[i]` to the value of the index where you land.
  若 `nums[i] > 0`：從 `i` 出發向 **右** 走 `nums[i]` 步（環狀），`result[i]` 取落點的值。
- If `nums[i] < 0`: Start at index `i` and move `abs(nums[i])` steps to the **left** in the circular array. Set `result[i]` to the value of the index where you land.
  若 `nums[i] < 0`：從 `i` 出發向 **左** 走 `abs(nums[i])` 步（環狀），`result[i]` 取落點的值。
- If `nums[i] == 0`: Set `result[i]` to `nums[i]`.
  若 `nums[i] == 0`：`result[i] = nums[i]`。

**Note:** Since `nums` is circular, moving past the last element wraps around to the beginning, and moving before the first element wraps back to the end.
**注意：** `nums` 為環狀陣列，超過尾端會回到開頭，往前超過頭部會繞到尾端。

## Examples / 範例

**Example 1:**

**Input:** `nums = [3,-2,1,1]`

**Output:** `[1,1,1,3]`

**Explanation:**

- For `nums[0]` that is equal to 3, if we move 3 steps to right, we reach `nums[3]`. So `result[0]` should be 1.
  `nums[0] = 3`：向右走 3 步到 `nums[3]`，所以 `result[0] = 1`。
- For `nums[1]` that is equal to -2, if we move 2 steps to left, we reach `nums[3]`. So `result[1]` should be 1.
  `nums[1] = -2`：向左走 2 步到 `nums[3]`，所以 `result[1] = 1`。
- For `nums[2]` that is equal to 1, if we move 1 step to right, we reach `nums[3]`. So `result[2]` should be 1.
  `nums[2] = 1`：向右走 1 步到 `nums[3]`，所以 `result[2] = 1`。
- For `nums[3]` that is equal to 1, if we move 1 step to right, we reach `nums[0]`. So `result[3]` should be 3.
  `nums[3] = 1`：向右走 1 步到 `nums[0]`，所以 `result[3] = 3`。

**Example 2:**

**Input:** `nums = [-1,4,-1]`

**Output:** `[-1,-1,4]`

**Explanation:**

- For `nums[0]` that is equal to -1, if we move 1 step to left, we reach `nums[2]`. So `result[0]` should be -1.
  `nums[0] = -1`：向左走 1 步到 `nums[2]`，所以 `result[0] = -1`。
- For `nums[1]` that is equal to 4, if we move 4 steps to right, we reach `nums[2]`. So `result[1]` should be -1.
  `nums[1] = 4`：向右走 4 步到 `nums[2]`，所以 `result[1] = -1`。
- For `nums[2]` that is equal to -1, if we move 1 step to left, we reach `nums[1]`. So `result[2]` should be 4.
  `nums[2] = -1`：向左走 1 步到 `nums[1]`，所以 `result[2] = 4`。

## Constraints / 限制

- `1 <= nums.length <= 100`
- `-100 <= nums[i] <= 100`

## 解題筆記與程式碼

通用演算法筆記：[circular_array_indexing](../algorithm/circular_array_indexing.md)
資料結構筆記：[array](../data_structure/array.md)

### 思路拆解

- 每個索引的操作互相獨立，不需要互相影響或模擬多步過程。
- 環狀索引可用模數運算處理：`j = (i + nums[i]) mod n`，負數要用 `rem_euclid`（或加 `n` 修正）。
- 一次掃描，對每個 `i` 計算落點並填入 `result[i]`。

### 演算法

1. 設 `n = nums.len()`。
2. 逐一枚舉索引 `i`，計算 `j = (i as i32 + nums[i]).rem_euclid(n as i32)`，並令 `result[i] = nums[j]`。
3. 回傳 `result`。

### 時間與空間

- 時間：`O(n)`。
- 空間：`O(n)`（輸出陣列）。

```rust
impl Solution {
    pub fn construct_transformed_array(nums: Vec<i32>) -> Vec<i32> {
        let n = nums.len() as i32;
        let mut result = Vec::with_capacity(nums.len());

        for (i, &v) in nums.iter().enumerate() {
            let idx = (i as i32 + v).rem_euclid(n) as usize;
            result.push(nums[idx]);
        }

        result
    }
}
```

## Related problems / 相關題目

- [189. Rotate Array](https://leetcode.com/problems/rotate-array/) / 旋轉陣列
- [457. Circular Array Loop](https://leetcode.com/problems/circular-array-loop/) / 環形陣列循環
- [918. Maximum Sum Circular Subarray](https://leetcode.com/problems/maximum-sum-circular-subarray/) / 環形子陣列的最大和
