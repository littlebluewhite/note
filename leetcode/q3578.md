[3578. Count Partitions With Max-Min Difference at Most K](https://leetcode.com/problems/count-partitions-with-max-min-difference-at-most-k/)

Medium

Topics

![premium lock icon](https://leetcode.com/_next/static/images/lock-a6627e2c7fa0ce8bc117c109fb4e567d.svg)Companies

Hint

You are given an integer array `nums` and an integer `k`.
給定整數陣列 `nums` 與整數 `k`。

Your task is to partition `nums` into one or more **non-empty** contiguous segments such that in each segment, the difference between its **maximum** and **minimum** elements is **at most** `k`.
請把 `nums` 劃分為一段或多段「非空」連續區間，且每段的最大值與最小值差不超過 `k`。

Return the total number of ways to partition `nums` under this condition.
回傳滿足條件的切分方式總數。

Since the answer may be too large, return it **modulo** `10^9 + 7`.
答案可能過大，請對 `10^9 + 7` 取模。

**Example 1:**

**Input:** nums = [9,4,1,3,7], k = 4

**Output:** 6

**Explanation:**
There are 6 valid partitions where the difference between the maximum and minimum elements in each segment is at most `k = 4`:
共有 6 種切分方式，使得每段的最大值與最小值差不超過 `k = 4`：

- `[[9], [4], [1], [3], [7]]`
- `[[9], [4], [1], [3, 7]]`
- `[[9], [4], [1, 3], [7]]`
- `[[9], [4, 1], [3], [7]]`
- `[[9], [4, 1], [3, 7]]`
- `[[9], [4, 1, 3], [7]]`

**Example 2:**

**Input:** nums = [3,3,4], k = 0

**Output:** 2

**Explanation:**
There are 2 valid partitions that satisfy the given conditions:
共有 2 種符合條件的切分：

- `[[3], [3], [4]]`
- `[[3, 3], [4]]`

**Constraints:**

- `2 <= nums.length <= 5 * 10^4`
- `1 <= nums[i] <= 10^9`
- `0 <= k <= 10^9`
- `2 <= nums.length <= 5 * 10^4`。
- `1 <= nums[i] <= 10^9`。
- `0 <= k <= 10^9`。

## 解題筆記與程式碼

演算法相關筆記：[monotone_window_partition](../algorithm/monotone_window_partition.md)

### 核心觀察

- 用兩個雙端隊列追蹤滑動視窗 `[l, r]` 的最大/最小值：max deque 遞減、min deque 遞增。新增 `nums[r]` 時，彈掉隊尾不符合單調性的索引，隊首永遠是當前視窗的最大/最小值索引。
- 若 `max - min > k`，視窗不合法，左端 `l` 右移並同步把等於 `l` 的隊首彈出，直到回到合法區間。`l` 被維持為「最左且合法」的位置，因此合法左端必然是連續的 `[l, r]`。
- 定義 `dp[i]`：切出前 `i` 個元素（`nums[0..i)`）的方案數，`prefix[i] = Σ_{0..i} dp`。當右端在 `r` 時，合法左端是 `[l, r]`，代表新段的起點可在這個閉區間內任選，因此 `dp[r+1] = prefix[r] - prefix[l-1]`（若 `l=0` 則用 0），模數避免負值。
- 小例子（`nums = [9,4,1,3,7], k = 4`）：  
  - `r=0`，視窗 `[9]` 合法，`dp[1]=1`。  
  - `r=1`，加入 4 不合法，左移到 `[4]`，此時合法左端只有 `l=1`，`dp[2]=prefix[1]-prefix[0]=1`。  
  - `r=2`，視窗 `[4,1]` 合法，合法左端區間 `l=1..2`，所以要加總 `dp[1]+dp[2]`，用前綴和即 `dp[3]=prefix[2]-prefix[0]= (dp[0]+dp[1]+dp[2]) - dp[0] = dp[1]+dp[2] = 2`。  
  - `r=3`，視窗 `[4,1,3]` 合法，合法左端仍 `l=1..3`，`dp[4]=prefix[3]-prefix[0]=4`。  
  - `r=4`，加入 7 後需左移到 `l=3` 才合法（視窗 `[3,7]`），合法左端 `l=3..4`，`dp[5]=prefix[4]-prefix[2]=6`。  
  - 最終 `dp[5]=6`，對應題目例子的 6 種切分。

### `dp` / `prefix` 的意義與數值（同上例）

- `dp[i]`：前 `i` 個元素的合法切分數；`dp[0]=1` 代表空陣列只有一種切法（遞推起點）。
- `prefix[i] = Σ_{0..i} dp`：`dp` 的前綴和，用來 O(1) 取區間和；`prefix[0]=dp[0]=1`。
- 例子中的數值表：  
  - `i=0`：`dp[0]=1`，`prefix[0]=1`  
  - `i=1`：`dp[1]=1`，`prefix[1]=2`  
  - `i=2`：`dp[2]=1`，`prefix[2]=3`  
  - `i=3`：`dp[3]=2`，`prefix[3]=5`  
  - `i=4`：`dp[4]=4`，`prefix[4]=9`  
  - `i=5`：`dp[5]=6`，`prefix[5]=15`

### 演算法

1. 以單調遞減的 max deque 與單調遞增的 min deque 追蹤當前視窗 `[l, r]` 的最大/最小值。
2. 每次新增 `nums[r]` 後，若 `max - min > k` 則遞增 `l` 並移除越界的索引，直到視窗合法。
3. 計算 `dp[r+1] = prefix[r] - prefix[l.saturating_sub(1)]`（模運算校正負值），再更新前綴和 `prefix[r+1]`。
4. 最終答案為 `dp[n]`。

### 時間與空間

- 時間：O(n)，每個索引僅進出隊一次。
- 空間：O(n)，存放 `dp`/`prefix` 與兩個 deque。

```rust
use std::collections::VecDeque;

const MOD: i64 = 1_000_000_007;

impl Solution {
    pub fn count_partitions(nums: Vec<i32>, k: i32) -> i32 {
        let n = nums.len();
        let k = k as i64;

        let mut max_q: VecDeque<usize> = VecDeque::new();
        let mut min_q: VecDeque<usize> = VecDeque::new();

        let mut dp = vec![0i64; n + 1];
        let mut prefix = vec![0i64; n + 1];
        dp[0] = 1;
        prefix[0] = 1;

        let mut l = 0usize;
        for r in 0..n {
            let val = nums[r] as i64;

            // 維持遞減的最大值 deque
            while let Some(&idx) = max_q.back() {
                if nums[idx] as i64 <= val {
                    max_q.pop_back();
                } else {
                    break;
                }
            }
            max_q.push_back(r);

            // 維持遞增的最小值 deque
            while let Some(&idx) = min_q.back() {
                if nums[idx] as i64 >= val {
                    min_q.pop_back();
                } else {
                    break;
                }
            }
            min_q.push_back(r);

            // 縮窗直到滿足 max - min <= k
            while l <= r
                && (nums[*max_q.front().unwrap()] as i64 - nums[*min_q.front().unwrap()] as i64) > k
            {
                if max_q.front().copied() == Some(l) {
                    max_q.pop_front();
                }
                if min_q.front().copied() == Some(l) {
                    min_q.pop_front();
                }
                l += 1;
            }

            let left_prefix = if l == 0 { 0 } else { prefix[l - 1] };
            dp[r + 1] = (prefix[r] - left_prefix + MOD) % MOD;
            prefix[r + 1] = (prefix[r] + dp[r + 1]) % MOD;
        }

        dp[n] as i32
    }
}
```
