---
title: "q3640"
category: leetcode
tags: [leetcode]
created: 2026-02-04
updated: 2026-02-04
difficulty: Hard
source: leetcode
status: active
complexity_time: O(n)
complexity_space: O(1)
---
# q3640

[3640. Trionic Array II](https://leetcode.com/problems/trionic-array-ii/)

Hard

Topics

Companies

Hint

You are given an integer array `nums` of length `n`.
給定一個長度為 `n` 的整數陣列 `nums`。

A trionic subarray is a contiguous subarray `nums[l...r]` (with `0 <= l < r < n`) for which there exist indices `l < p < q < r` such that:
如果存在 `l < p < q < r`，使得以下條件成立，則連續子陣列 `nums[l...r]`（`0 <= l < r < n`）為 trionic：

- `nums[l...p]` is strictly increasing.
  / `nums[l...p]` 為嚴格遞增。
- `nums[p...q]` is strictly decreasing.
  / `nums[p...q]` 為嚴格遞減。
- `nums[q...r]` is strictly increasing.
  / `nums[q...r]` 為嚴格遞增。

Return the maximum sum of any trionic subarray in `nums`.
回傳 `nums` 中任一 trionic 子陣列的最大總和。

**Example 1:**

**Input:** `nums = [0,-2,-1,-3,0,2,-1]`
**Output:** `-4`
**Explanation:**
Pick `l = 1, p = 2, q = 3, r = 5`:
選擇 `l = 1, p = 2, q = 3, r = 5`：

- `nums[1...2] = [-2, -1]` is strictly increasing (`-2 < -1`).
  / `nums[1...2] = [-2, -1]` 為嚴格遞增（`-2 < -1`）。
- `nums[2...3] = [-1, -3]` is strictly decreasing (`-1 > -3`).
  / `nums[2...3] = [-1, -3]` 為嚴格遞減（`-1 > -3`）。
- `nums[3...5] = [-3, 0, 2]` is strictly increasing (`-3 < 0 < 2`).
  / `nums[3...5] = [-3, 0, 2]` 為嚴格遞增（`-3 < 0 < 2`）。
Sum = `(-2) + (-1) + (-3) + 0 + 2 = -4`.
總和為 `(-2) + (-1) + (-3) + 0 + 2 = -4`。

**Example 2:**

**Input:** `nums = [1,4,2,7]`
**Output:** `14`
**Explanation:**
Pick `l = 0, p = 1, q = 2, r = 3`:
選擇 `l = 0, p = 1, q = 2, r = 3`：

- `nums[0...1] = [1, 4]` is strictly increasing (`1 < 4`).
  / `nums[0...1] = [1, 4]` 為嚴格遞增（`1 < 4`）。
- `nums[1...2] = [4, 2]` is strictly decreasing (`4 > 2`).
  / `nums[1...2] = [4, 2]` 為嚴格遞減（`4 > 2`）。
- `nums[2...3] = [2, 7]` is strictly increasing (`2 < 7`).
  / `nums[2...3] = [2, 7]` 為嚴格遞增（`2 < 7`）。
Sum = `1 + 4 + 2 + 7 = 14`.
總和為 `1 + 4 + 2 + 7 = 14`。

**Constraints:**

- `4 <= n = nums.length <= 10^5`
- `-10^9 <= nums[i] <= 10^9`
- It is guaranteed that at least one trionic subarray exists.
- `4 <= n = nums.length <= 10^5`。
- `-10^9 <= nums[i] <= 10^9`。
- 保證至少存在一個 trionic 子陣列。

---

## 解題筆記與程式碼

通用演算法筆記：[grouped_loop_scan](../algorithm/grouped_loop_scan.md)
通用演算法筆記：[monotonic_three_phase_scan](../algorithm/monotonic_three_phase_scan.md)
資料結構筆記：[array](../data_structure/array.md)

### 思路拆解

- 子陣列需滿足「嚴格遞增 → 嚴格遞減 → 嚴格遞增」三段結構，可視為從某個起點出發的三段單調段。
- 使用 grouped loop 先找出「最大化」的三段子陣列：第一段最長遞增、第二段最長遞減、第三段最長遞增。
- 對每個最大三段子陣列，我們可以在不破壞單調性的前提下，決定是否往左右延伸以最大化總和。

### 關鍵觀察

- 第二段（遞減）必須完整保留，因為切掉任意內部元素會破壞三段連續性。
- 第一段至少要保留最後兩個元素（`p-1, p`），第三段至少要保留前兩個元素（`q, q+1`）。
- 固定最小三段後，向左延伸的最佳收益是第一段的「最大後綴和」（從 `p-2` 向左累加）。
- 向右延伸的最佳收益是第三段的「最大前綴和」（從 `q+2` 向右累加）。
- 若延伸收益為負，則不延伸（視為 0）。

### 演算法

1. `i` 從左到右掃描，先吃完最長遞增段得到 `p`。
2. 接著吃完最長遞減段得到 `q`。
3. 若沒有有效第三段（`nums[q] < nums[q+1]` 不成立），移動 `i` 繼續。
4. 計算「最小三段」的基礎總和：`nums[p-1] + nums[p..q] + nums[q+1]`。
5. 在第一段中，向左計算最大後綴和並加到總和。
6. 在第三段中，向右計算最大前綴和並加到總和。
7. 更新答案，並把 `i` 移到下一個可能起點（第三段的開頭附近）。

### 時間與空間

- 時間：`O(n)`，每個索引最多被掃描常數次。
- 空間：`O(1)`。

### Rust

```rust
impl Solution {
    pub fn max_sum_trionic(nums: Vec<i32>) -> i64 {
        let n = nums.len();
        let mut ans: i64 = i64::MIN;
        let mut i: usize = 0;

        while i < n {
            let mut j = i + 1;

            // 1) first segment: strictly increasing
            while j < n && nums[j - 1] < nums[j] {
                j += 1;
            }
            let p = j - 1;
            if p == i {
                i += 1;
                continue;
            }

            // 2) second segment: strictly decreasing
            let mut res: i64 = (nums[p] + nums[p - 1]) as i64;
            while j < n && nums[j - 1] > nums[j] {
                res += nums[j] as i64;
                j += 1;
            }
            let q = j - 1;
            if q == p || q == n - 1 || (j < n && nums[j] <= nums[q]) {
                i = q;
                continue;
            }

            // 3) third segment: strictly increasing, ensure minimal length (q, q+1)
            res += nums[q + 1] as i64;

            // extend to the right: max prefix sum inside third segment
            let mut max_sum: i64 = 0;
            let mut sum: i64 = 0;
            let mut k = q + 2;
            while k < n && nums[k] > nums[k - 1] {
                sum += nums[k] as i64;
                if sum > max_sum {
                    max_sum = sum;
                }
                k += 1;
            }
            res += max_sum;

            // extend to the left: max suffix sum inside first segment
            let mut max_sum: i64 = 0;
            let mut sum: i64 = 0;
            let mut k = p as isize - 2;
            while k >= i as isize {
                sum += nums[k as usize] as i64;
                if sum > max_sum {
                    max_sum = sum;
                }
                k -= 1;
            }
            res += max_sum;

            if res > ans {
                ans = res;
            }

            // next start: move near the third segment start (will advance to q if needed)
            i = q - 1;
        }

        ans
    }
}
```
