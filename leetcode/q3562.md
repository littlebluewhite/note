[3562. Maximum Profit from Trading Stocks with Discounts](https://leetcode.com/problems/maximum-profit-from-trading-stocks-with-discounts/)

Hard

Topics

![premium lock icon](https://leetcode.com/_next/static/images/lock-a6627e2c7fa0ce8bc117c109fb4e567d.svg)Companies

Hint

You are given an integer `n`, representing the number of employees in a company. Each employee is assigned a unique ID from `1` to `n`, and employee `1` is the CEO. You are given two 1-based integer arrays, `present` and `future`, each of length `n`, where:
給定整數 `n` 代表公司員工數，員工編號為 `1..n`，其中員工 `1` 為 CEO。另有兩個 1-based 陣列 `present` 與 `future`，長度皆為 `n`：

`present[i]` represents the current price at which the `ith` employee can buy a stock today.
`present[i]` 表示員工 i 今天可以買入股票的價格。

`future[i]` represents the expected price at which the `ith` employee can sell the stock tomorrow.
`future[i]` 表示員工 i 明天賣出的預期價格。

The company's hierarchy is represented by a 2D integer array `hierarchy`, where `hierarchy[i] = [ui, vi]` means that employee `ui` is the direct boss of employee `vi`.
公司層級由二維陣列 `hierarchy` 表示，`hierarchy[i] = [ui, vi]` 代表員工 `ui` 是員工 `vi` 的直屬主管。

Additionally, you have an integer `budget` representing the total funds available for investment.
另有整數 `budget` 代表可用的投資預算。

However, the company has a discount policy: if an employee's direct boss purchases their own stock, then the employee can buy their stock at half the original price (`floor(present[v] / 2)`).
公司有折扣政策：若員工的直屬主管購買了自己的股票，該員工即可用半價（`floor(present[v] / 2)`) 購入。

Return the maximum profit that can be achieved without exceeding the given budget.
請回傳在不超出 `budget` 的前提下，能取得的最大總獲利。

Note:  
備註：

- You may buy each stock at most once.  
  每檔股票至多買一次。  
- You cannot use any profit earned from future stock prices to fund additional investments and must buy only from `budget`.  
  獲利不能回填再投資，只能使用 `budget` 內的預算購買。

**Example 1:**

**Input:** `n = 2, present = [1,2], future = [4,3], hierarchy = [[1,2]], budget = 3`  
**Output:** `5`

**Explanation:**

- Employee 1 buys the stock at price `1` and earns a profit of `4 - 1 = 3`.  
- Since Employee 1 is the direct boss of Employee 2, Employee 2 gets a discounted price of `floor(2 / 2) = 1`.  
- Employee 2 buys the stock at price `1` and earns a profit of `3 - 1 = 2`.  
- Total cost `1 + 1 = 2 <= 3`, so maximum profit is `3 + 2 = 5`.

**Example 2:**

**Input:** `n = 2, present = [3,4], future = [5,8], hierarchy = [[1,2]], budget = 4`  
**Output:** `4`

**Example 3:**

**Input:** `n = 3, present = [4,6,8], future = [7,9,11], hierarchy = [[1,2],[1,3]], budget = 10`  
**Output:** `10`

**Example 4:**

**Input:** `n = 3, present = [5,2,3], future = [8,5,6], hierarchy = [[1,2],[2,3]], budget = 7`  
**Output:** `12`

**Constraints:**

- `1 <= n <= 160`  
- `present.length = future.length = n`  
- `1 <= present[i], future[i] <= 50`  
- `hierarchy.length == n - 1`  
- `hierarchy[i] == [ui, vi]`  
- `1 <= ui, vi <= n`, `ui != vi`  
- `1 <= budget <= 160`  
- There are no duplicate edges.  
- Employee `1` is the direct or indirect boss of every employee.  
- The input graph `hierarchy` has no cycles.  
- `1 <= n <= 160`。  
- `present.length = future.length = n`。  
- `1 <= present[i], future[i] <= 50`。  
- `hierarchy.length == n - 1`。  
- `hierarchy[i] == [ui, vi]`。  
- `1 <= ui, vi <= n`，且 `ui != vi`。  
- `1 <= budget <= 160`。  
- 邊不重複，員工 1 為所有人的上司，且層級圖無環。

## 解題筆記與程式碼

演算法相關筆記：[tree_knapsack_discount](../algorithm/tree_knapsack_discount.md)

### 核心觀察

- 折扣只由直屬主管是否購買決定，和更上層無關，因此對每個節點用「父節點有/無購買」當作 DP 狀態就能涵蓋所有折扣情況。  
- 節點自己買或不買會影響子節點選哪個狀態（享折扣或不享折扣），可對兩種選擇分別做樹上 0/1 背包再取最大值。  
- 預算上限 `160`，可在每個節點維持長度 `budget+1` 的價值表並用背包合併子樹，總複雜度可接受。

### 演算法

1. 以員工 1 為根建子節點陣列。定義 `dfs(u)` 回傳兩個長度 `B+1` 的陣列：  
   - `dp0`: 父節點沒買時，在子樹 `u` 內花費 `b` 的最大獲利。  
   - `dp1`: 父節點已買時的同義陣列（`u` 本人可半價）。  
2. 在 `dfs` 中列舉兩種情境：「`u` 不買」與「`u` 買」。  
   - 若 `u` 不買，子節點只能用 `dp0` 狀態（無折扣）。  
   - 若 `u` 買，成本為原價或半價，子節點使用 `dp1` 狀態（有折扣）。  
   對每個情境，從基底成本開始，逐一與子節點的陣列做 0/1 背包合併。  
3. `dp0` 取「不買」與「買（原價）」兩組合併結果的逐欄最大值；`dp1` 則取「不買」與「買（半價）」的最大值。  
4. 最終答案為根節點 `dp0` 中、預算不超過 `budget` 的最大值。

### 時間與空間

- 時間：`O(n * B^2)`，每個節點合併子樹做背包，`B = budget (<= 160)`。  
- 空間：`O(n * B)` 儲存兩組 DP 陣列（可就地覆蓋避免額外記憶體）。

```rust
impl Solution {
    pub fn max_profit(
        n: i32,
        present: Vec<i32>,
        future: Vec<i32>,
        hierarchy: Vec<Vec<i32>>,
        budget: i32,
    ) -> i32 {
        const NEG: i32 = -1_000_000_000;
        let b = budget as usize;
        let mut children = vec![Vec::new(); n as usize];
        for edge in hierarchy {
            let u = (edge[0] - 1) as usize;
            let v = (edge[1] - 1) as usize;
            children[u].push(v);
        }

        fn merge(base: Vec<i32>, child: &Vec<i32>, limit: usize) -> Vec<i32> {
            let mut res = vec![NEG; limit + 1];
            for i in 0..=limit {
                if base[i] == NEG {
                    continue;
                }
                let remain = limit - i;
                for j in 0..=remain {
                    let val = child[j];
                    if val == NEG {
                        continue;
                    }
                    let new_cost = i + j;
                    let new_val = base[i] + val;
                    if new_val > res[new_cost] {
                        res[new_cost] = new_val;
                    }
                }
            }
            res
        }

        fn build_option(
            base_cost: usize,
            base_profit: i32,
            child_states: &[(Vec<i32>, Vec<i32>)],
            use_discount_state: bool,
            limit: usize,
        ) -> Vec<i32> {
            let mut dp = vec![NEG; limit + 1];
            if base_cost <= limit {
                dp[base_cost] = base_profit;
            }
            for (c0, c1) in child_states {
                let child = if use_discount_state { c1 } else { c0 };
                dp = merge(dp, child, limit);
            }
            dp
        }

        fn dfs(
            u: usize,
            children: &Vec<Vec<usize>>,
            present: &Vec<i32>,
            future: &Vec<i32>,
            limit: usize,
        ) -> (Vec<i32>, Vec<i32>) {
            let mut sub = Vec::new();
            for &v in &children[u] {
                sub.push(dfs(v, children, present, future, limit));
            }

            let full_cost = present[u] as usize;
            let full_profit = future[u] - present[u];
            let disc_cost = (present[u] / 2) as usize;
            let disc_profit = future[u] - present[u] / 2;

            let opt_no_buy = build_option(0, 0, &sub, false, limit);
            let opt_buy_full = build_option(full_cost, full_profit, &sub, true, limit);
            let mut dp0 = vec![NEG; limit + 1];
            for i in 0..=limit {
                dp0[i] = opt_no_buy[i].max(opt_buy_full[i]);
            }

            let opt_buy_disc = build_option(disc_cost, disc_profit, &sub, true, limit);
            let mut dp1 = vec![NEG; limit + 1];
            for i in 0..=limit {
                dp1[i] = opt_no_buy[i].max(opt_buy_disc[i]);
            }

            (dp0, dp1)
        }

        let (root_dp, _) = dfs(0, &children, &present, &future, b);
        root_dp.into_iter().take(b + 1).max().unwrap_or(0)
    }
}
```
