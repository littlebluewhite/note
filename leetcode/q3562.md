---
title: "q3562"
category: leetcode
tags: [leetcode]
created: 2026-02-03
updated: 2026-02-03
difficulty: Hard
source: leetcode
status: active
complexity_time: O(n * B^2)
complexity_space: O(n * B)
---
[3562. Maximum Profit from Trading Stocks with Discounts](https://leetcode.com/problems/maximum-profit-from-trading-stocks-with-discounts/)

Hard

Topics

![premium lock icon](https://leetcode.com/_next/static/images/lock-a6627e2c7fa0ce8bc117c109fb4e567d.svg)Companies

Hint

You are given an integer `n`, representing the number of employees in a company. Each employee is assigned a unique ID from `1` to `n`, and employee `1` is the CEO. You are given two 1-based integer arrays, `present` and `future`, each of length `n`, where:
給定整數 `n` 代表公司員工數，員工編號為 `1..n`，其中員工 `1` 為 CEO。另有兩個 1-based 陣列 `present` 與 `future`，長度皆為 `n`：

`present[i]` represents the current price at which the `ith` employee can buy a stock today.
`present[i]` 表示員工 i 今天可以買入股票的價格。

`future[i]` represents the expected price at which the `ith` employee can sell the stock tomorrow.
`future[i]` 表示員工 i 明天賣出的預期價格。

The company's hierarchy is represented by a 2D integer array `hierarchy`, where `hierarchy[i] = [ui, vi]` means that employee `ui` is the direct boss of employee `vi`.
公司層級由二維陣列 `hierarchy` 表示，`hierarchy[i] = [ui, vi]` 代表員工 `ui` 是員工 `vi` 的直屬主管。

Additionally, you have an integer `budget` representing the total funds available for investment.
另有整數 `budget` 代表可用的投資預算。

However, the company has a discount policy: if an employee's direct boss purchases their own stock, then the employee can buy their stock at half the original price (`floor(present[v] / 2)`).
公司有折扣政策：若員工的直屬主管購買了自己的股票，該員工即可用半價（`floor(present[v] / 2)`) 購入。

Return the maximum profit that can be achieved without exceeding the given budget.
請回傳在不超出 `budget` 的前提下，能取得的最大總獲利。

Note:  
備註：

- You may buy each stock at most once.  
  每檔股票至多買一次。  
- You cannot use any profit earned from future stock prices to fund additional investments and must buy only from `budget`.  
  獲利不能回填再投資，只能使用 `budget` 內的預算購買。

**Example 1:**

**Input:** `n = 2, present = [1,2], future = [4,3], hierarchy = [[1,2]], budget = 3`  
**Output:** `5`

**Explanation:**

- Employee 1 buys the stock at price `1` and earns a profit of `4 - 1 = 3`.  
- Since Employee 1 is the direct boss of Employee 2, Employee 2 gets a discounted price of `floor(2 / 2) = 1`.  
- Employee 2 buys the stock at price `1` and earns a profit of `3 - 1 = 2`.  
- Total cost `1 + 1 = 2 <= 3`, so maximum profit is `3 + 2 = 5`.

**Example 2:**

**Input:** `n = 2, present = [3,4], future = [5,8], hierarchy = [[1,2]], budget = 4`  
**Output:** `4`

**Example 3:**

**Input:** `n = 3, present = [4,6,8], future = [7,9,11], hierarchy = [[1,2],[1,3]], budget = 10`  
**Output:** `10`

**Example 4:**

**Input:** `n = 3, present = [5,2,3], future = [8,5,6], hierarchy = [[1,2],[2,3]], budget = 7`  
**Output:** `12`

**Constraints:**

- `1 <= n <= 160`  
- `present.length = future.length = n`  
- `1 <= present[i], future[i] <= 50`  
- `hierarchy.length == n - 1`  
- `hierarchy[i] == [ui, vi]`  
- `1 <= ui, vi <= n`, `ui != vi`  
- `1 <= budget <= 160`  
- There are no duplicate edges.  
- Employee `1` is the direct or indirect boss of every employee.  
- The input graph `hierarchy` has no cycles.  
- `1 <= n <= 160`。  
- `present.length = future.length = n`。  
- `1 <= present[i], future[i] <= 50`。  
- `hierarchy.length == n - 1`。  
- `hierarchy[i] == [ui, vi]`。  
- `1 <= ui, vi <= n`，且 `ui != vi`。  
- `1 <= budget <= 160`。  
- 邊不重複，員工 1 為所有人的上司，且層級圖無環。

## 解題筆記與程式碼

DP 筆記：[dp_dynamic_programming](../algorithm/dp_dynamic_programming.md)
通用演算法筆記：[tree_dp](../algorithm/tree_dp.md)
通用演算法筆記：[knapsack_dp](../algorithm/knapsack_dp.md)
資料結構筆記：[adjacency_list](../data_structure/adjacency_list.md)

### 核心觀察

- 折扣只由直屬主管是否購買決定，和更上層無關，因此對每個節點用「父節點有/無購買」當作 DP 狀態就能涵蓋所有折扣情況。  
- 節點自己買或不買會影響子節點選哪個狀態（享折扣或不享折扣），可對兩種選擇分別做樹上 0/1 背包再取最大值。  
- 預算上限 `160`，可在每個節點維持長度 `budget+1` 的價值表並用背包合併子樹，總複雜度可接受。

### 演算法

1. 以員工 1 為根建子節點陣列。定義 `dfs(u)` 回傳兩個長度 `B+1` 的陣列：  
   - `dp0`: 父節點沒買時，在子樹 `u` 內花費 `b` 的最大獲利。  
   - `dp1`: 父節點已買時的同義陣列（`u` 本人可半價）。  
2. 在 `dfs` 中列舉兩種情境：「`u` 不買」與「`u` 買」。  
   - 若 `u` 不買，子節點只能用 `dp0` 狀態（無折扣）。  
   - 若 `u` 買，成本為原價或半價，子節點使用 `dp1` 狀態（有折扣）。  
   對每個情境，從基底成本開始，逐一與子節點的陣列做 0/1 背包合併。  
3. `dp0` 取「不買」與「買（原價）」兩組合併結果的逐欄最大值；`dp1` 則取「不買」與「買（半價）」的最大值。  
4. 最終答案為根節點 `dp0` 中、預算不超過 `budget` 的最大值。

### 時間與空間

- 時間：`O(n * B^2)`，每個節點合併子樹做背包，`B = budget (<= 160)`。  
- 空間：`O(n * B)` 儲存兩組 DP 陣列（可就地覆蓋避免額外記憶體）。

```rust
impl Solution {
    pub fn max_profit(
        n: i32,
        present: Vec<i32>,
        future: Vec<i32>,
        hierarchy: Vec<Vec<i32>>,
        budget: i32,
    ) -> i32 {
        const NEG: i32 = -1_000_000_000;
        let b = budget as usize;
        let mut children = vec![Vec::new(); n as usize];
        for edge in hierarchy {
            let u = (edge[0] - 1) as usize;
            let v = (edge[1] - 1) as usize;
            children[u].push(v);
        }

        fn merge(base: Vec<i32>, child: &Vec<i32>, limit: usize) -> Vec<i32> {
            let mut res = vec![NEG; limit + 1];
            for i in 0..=limit {
                if base[i] == NEG {
                    continue;
                }
                let remain = limit - i;
                for j in 0..=remain {
                    let val = child[j];
                    if val == NEG {
                        continue;
                    }
                    let new_cost = i + j;
                    let new_val = base[i] + val;
                    if new_val > res[new_cost] {
                        res[new_cost] = new_val;
                    }
                }
            }
            res
        }

        fn build_option(
            base_cost: usize,
            base_profit: i32,
            child_states: &[(Vec<i32>, Vec<i32>)],
            use_discount_state: bool,
            limit: usize,
        ) -> Vec<i32> {
            let mut dp = vec![NEG; limit + 1];
            if base_cost <= limit {
                dp[base_cost] = base_profit;
            }
            for (c0, c1) in child_states {
                let child = if use_discount_state { c1 } else { c0 };
                dp = merge(dp, child, limit);
            }
            dp
        }

        fn dfs(
            u: usize,
            children: &Vec<Vec<usize>>,
            present: &Vec<i32>,
            future: &Vec<i32>,
            limit: usize,
        ) -> (Vec<i32>, Vec<i32>) {
            let mut sub = Vec::new();
            for &v in &children[u] {
                sub.push(dfs(v, children, present, future, limit));
            }

            let full_cost = present[u] as usize;
            let full_profit = future[u] - present[u];
            let disc_cost = (present[u] / 2) as usize;
            let disc_profit = future[u] - present[u] / 2;

            let opt_no_buy = build_option(0, 0, &sub, false, limit);
            let opt_buy_full = build_option(full_cost, full_profit, &sub, true, limit);
            let mut dp0 = vec![NEG; limit + 1];
            for i in 0..=limit {
                dp0[i] = opt_no_buy[i].max(opt_buy_full[i]);
            }

            let opt_buy_disc = build_option(disc_cost, disc_profit, &sub, true, limit);
            let mut dp1 = vec![NEG; limit + 1];
            for i in 0..=limit {
                dp1[i] = opt_no_buy[i].max(opt_buy_disc[i]);
            }

            (dp0, dp1)
        }

        let (root_dp, _) = dfs(0, &children, &present, &future, b);
        root_dp.into_iter().take(b + 1).max().unwrap_or(0)
    }
}
```


## 補充筆記：  

```rust
fn dfs(u: usize, g: &Vec<Vec<usize>>, w: &Vec<usize>, val: &Vec<i32>, B: usize) -> Vec<i32> {
    const NEG: i32 = -1_000_000_000;
    let mut dp = vec![NEG; B + 1];
    dp[0] = 0;
    for &ch in &g[u] {
        let child = dfs(ch, g, w, val, B);
        dp = merge(dp, child, B); // merge 是 0/1 背包式的表合併
    }
    // 選當前節點（父未選則不會進 dfs 或在外層另外控制）
    for c in (w[u]..=B).rev() {
        dp[c] = dp[c].max(dp[c - w[u]] + val[u]);
    }
    dp
}
```

- 變形：若有「父不選子不可選」以外的條件（如本題的半價折扣、強制不買等），就在 `dp` 上再開一層父狀態，或在基底成本/收益調整後再做合併。

## 思考過程

1. 折扣只由「直屬父」決定，與更遠祖先無關，因此每個節點只需知道「父是否買了」。  
2. 預算上限 160，不大，背包維度可直接用成本做 DP。  
3. 樹型結構天然適合 DFS 自底向上合併子樹：先計算子節點最優，再把子樹結果當成「物品組」做合併。  
4. 節點 `u` 自身的買/不買會影響子節點折扣，因此需為兩個父狀態都保留一張背包表，且在狀態內考慮 `u` 的買/不買兩種情境。

## 狀態設計

- `dp0_u[c]`：父未買（無折扣），在 `u` 子樹花費 `c` 的最大獲利。  
- `dp1_u[c]`：父已買（有折扣），在 `u` 子樹花費 `c` 的最大獲利。  
- 長度皆為 `B+1`，初始化為負無限，未使用成本視為不可行。

## 轉移邏輯

對節點 `u`，先 DFS 得到所有子節點的 `(dp0, dp1)`。接著分情境建兩張候選表，再逐成本取最大：

- **不買 `u`**：基底成本 0、收益 0；子節點只能用 `dp0`（無折扣）。逐子節點用 0/1 背包合併。  
- **買 `u`**：  
  - 父未買時，`u` 成本 = 原價，收益 = `future[u] - present[u]`，子節點用 `dp1`（享折扣）。  
  - 父已買時，`u` 成本 = 半價 `present[u]/2`，收益 = `future[u] - present[u]/2`，子節點同樣用 `dp1`。  
- `dp0` = max(不買, 買原價)；`dp1` = max(不買, 買半價) 逐成本比較。

**子合併（0/1 背包）**：給定當前表 `base` 與子表 `child`，枚舉花費 `i` in `base` 與 `j` in `child`，更新 `res[i+j] = max(res[i+j], base[i] + child[j])`。成本超界則跳過。

## 正確性直覺

- 折扣的唯一來源是父節點是否買，所以「父是否買」充分描述了對子節點的價格影響。  
- 在每個父狀態下，節點 `u` 的買與不買都被枚舉，子節點使用對應價格表，涵蓋所有合法選擇組合。  
- 背包合併保證在每個成本下取得最大收益，DFS 自底向上即得全局最優。

## 複雜度

- 時間：`O(n * B^2)`，每個節點合併子樹背包，`B = budget (<= 160)`。  
- 空間：`O(n * B)`，兩組 DP 陣列，可就地覆蓋降低常數。

## 邊界與實作細節

- 半價採整數除法 `present[u] / 2`。  
- 需保留「不買」的 0 成本 0 獲利，避免強迫買入負收益股票。  
- 用大負數初始化不可行狀態，合併時跳過不可行項。  
- 樹深最多 160，遞迴可接受；若擔心，可改顯式堆疊。  
- 根節點答案取 `dp0` 在 `0..=B` 的最大值（根沒有上層折扣）。  
- 本方法應用在：折扣/額外條件只依賴父節點、且預算維度不大時的樹上選擇/背包問題。

## 程式碼逐行解釋（對應 [q3562](q3562.md) 的 Rust）

- `const NEG: i32 = -1_000_000_000;`：不可行狀態的負無限，避免溢位又不會誤成最佳。  
- `children`：根據 `hierarchy` 建子節點清單（0-based）。  
- `merge(base, child, limit)`：0/1 背包合併，枚舉 `i`（已花費）與 `j`（子花費），更新 `res[i+j]`。遇到 `NEG` 跳過。  
- `build_option(base_cost, base_profit, child_states, use_discount_state, limit)`：建一個情境的背包表。先放入基底成本/收益（買或不買 `u`），再依序合併每個子節點的狀態表；`use_discount_state` 決定取子節點的 `dp1`（有折扣）或 `dp0`（無折扣）。  
- `dfs(u, ...) -> (dp0, dp1)`：  
  - 先遞迴子節點收集 `(dp0, dp1)`。  
  - 計算 `full_cost/full_profit`（原價）與 `disc_cost/disc_profit`（半價）。  
  - `opt_no_buy`：`base_cost=0`，子用 `dp0`。  
  - `opt_buy_full`：`base_cost=present[u]`，子用 `dp1`。  
  - `dp0[i] = max(opt_no_buy[i], opt_buy_full[i])`。  
  - `opt_buy_disc`：`base_cost=present[u]/2`，子用 `dp1`。  
  - `dp1[i] = max(opt_no_buy[i], opt_buy_disc[i])`。  
  - 回傳 `(dp0, dp1)`。  
- 主程式：`let (root_dp, _) = dfs(0, ...);` 取根的 `dp0`（父不存在視為未買），在 `0..=budget` 中取最大值作答。  
- 重要邏輯：  
  - 子狀態選擇完全由 `use_discount_state` 控制，確保父買時子享折扣，父不買時子原價。  
  - `opt_no_buy` 共享於 `dp0/dp1`，代表「這個節點不買」的通用情境。  
  - 負無限初始化與跳過不可行值避免錯誤累加。  
  - 成本採 `usize` 避免負值；收益保留 `i32`，因為差值可能為負，但初始化的 `NEG` 確保不會被無效狀態覆蓋。
