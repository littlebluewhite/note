[3583. Count Special Triplets](https://leetcode.com/problems/count-special-triplets/)

[3583. Count Special Triplets](https://leetcode.com/problems/count-special-triplets/)

Medium

Topics

![premium lock icon](https://leetcode.com/_next/static/images/lock-a6627e2c7fa0ce8bc117c109fb4e567d.svg)Companies

Hint

You are given an integer array `nums`.
給定整數陣列 `nums`。

A **special triplet** is defined as a triplet of indices `(i, j, k)` such that:
**特殊三元組** 定義為索引 `(i, j, k)`，滿足：

- `0 <= i < j < k < n`, where `n = nums.length`
- `nums[i] == nums[j] * 2`
- `nums[k] == nums[j] * 2`
- `0 <= i < j < k < n`，其中 `n = nums.length`
- `nums[i] == nums[j] * 2`
- `nums[k] == nums[j] * 2`

Return the total number of **special triplets** in the array.
回傳陣列中的 **特殊三元組** 總數。

Since the answer may be large, return it **modulo** `10^9 + 7`.
答案可能很大，請對 `10^9 + 7` 取模。

**Example 1:**

**Input:** nums = [6,3,6]

**Output:** 1

**Explanation:**
**解釋：**

The only special triplet is `(i, j, k) = (0, 1, 2)`, where:
唯一的特殊三元組是 `(i, j, k) = (0, 1, 2)`，滿足：

- `nums[0] = 6`, `nums[1] = 3`, `nums[2] = 6`
- `nums[0] = nums[1] * 2 = 3 * 2 = 6`
- `nums[2] = nums[1] * 2 = 3 * 2 = 6`
- `nums[0] = 6`、`nums[1] = 3`、`nums[2] = 6`
- `nums[0] = nums[1] * 2 = 3 * 2 = 6`
- `nums[2] = nums[1] * 2 = 3 * 2 = 6`

**Example 2:**

**Input:** nums = [0,1,0,0]

**Output:** 1

**Explanation:**
**解釋：**

The only special triplet is `(i, j, k) = (0, 2, 3)`, where:
唯一的特殊三元組是 `(i, j, k) = (0, 2, 3)`，其中：

- `nums[0] = 0`, `nums[2] = 0`, `nums[3] = 0`
- `nums[0] = nums[2] * 2 = 0 * 2 = 0`
- `nums[3] = nums[2] * 2 = 0 * 2 = 0`
- `nums[0] = 0`、`nums[2] = 0`、`nums[3] = 0`
- `nums[0] = nums[2] * 2 = 0 * 2 = 0`
- `nums[3] = nums[2] * 2 = 0 * 2 = 0`

**Example 3:**

**Input:** nums = [8,4,2,8,4]

**Output:** 2

**Explanation:**
**解釋：**

There are exactly two special triplets:
共有兩個特殊三元組：

- `(i, j, k) = (0, 1, 3)`
    - `nums[0] = 8`, `nums[1] = 4`, `nums[3] = 8`
    - `nums[0] = nums[1] * 2 = 4 * 2 = 8`
    - `nums[3] = nums[1] * 2 = 4 * 2 = 8`
- `(i, j, k) = (1, 2, 4)`
    - `nums[1] = 4`, `nums[2] = 2`, `nums[4] = 4`
    - `nums[1] = nums[2] * 2 = 2 * 2 = 4`
    - `nums[4] = nums[2] * 2 = 2 * 2 = 4`
- `(i, j, k) = (0, 1, 3)`
    - `nums[0] = 8`、`nums[1] = 4`、`nums[3] = 8`
    - `nums[0] = nums[1] * 2 = 4 * 2 = 8`
    - `nums[3] = nums[1] * 2 = 4 * 2 = 8`
- `(i, j, k) = (1, 2, 4)`
    - `nums[1] = 4`、`nums[2] = 2`、`nums[4] = 4`
    - `nums[1] = nums[2] * 2 = 2 * 2 = 4`
    - `nums[4] = nums[2] * 2 = 2 * 2 = 4`

**Constraints:**

- `3 <= n == nums.length <= 10^5`
- `0 <= nums[i] <= 10^5`
- `3 <= n == nums.length <= 10^5`。
- `0 <= nums[i] <= 10^5`。

## 解題筆記與程式碼

演算法相關筆記：[special_triplets_freq_scan](../algorithm/special_triplets_freq_scan.md)

### 核心觀察

- 讓索引 `j` 當中心，條件化為「左邊有幾個值等於 `2 * nums[j]`，右邊有幾個值等於 `2 * nums[j]`」，組合數量就是兩者相乘。
- 先把所有數字計入右側頻率 `right`，雙指針掃描 `j`：處理當前 `j` 時先把 `nums[j]` 從 `right` 拿掉，避免自己被選；答案增加 `left[target] * right[target]`，最後把 `nums[j]` 加回左側頻率 `left`。
- `nums[i] <= 10^5`，所以目標值 `2 * nums[j]` 只到 `2 * 10^5`，用固定長度陣列即可 O(1) 存取。

### 演算法

1. 準備長度 `200001` 的 `left`、`right` 計數陣列（i64），先把整個 `nums` 填入 `right`。
2. 逐一枚舉中心索引 `j`：  
   - 從 `right` 減去 `nums[j]`。  
   - 計算目標值 `t = 2 * nums[j]`，若 `t` 在陣列範圍內，答案累加 `left[t] * right[t]`（模 `MOD`）。  
   - 把 `nums[j]` 加入 `left`，進入下一輪。
3. 回傳累加結果。

### 時間與空間

- 時間：O(n)，每個元素只被掃描一次。
- 空間：O(U)，`U = 2 * 10^5 + 1` 的計數陣列。

```rust
const MOD: i64 = 1_000_000_007;
const MAX_VAL: usize = 200_000; // 2 * 10^5，涵蓋 nums[i] * 2 的上界

impl Solution {
    pub fn special_triplets(nums: Vec<i32>) -> i32 {
        let n = nums.len();
        let mut left = vec![0i64; MAX_VAL + 1];
        let mut right = vec![0i64; MAX_VAL + 1];

        for &v in &nums {
            right[v as usize] += 1;
        }

        let mut ans: i64 = 0;
        for &v in &nums {
            let val = v as usize;
            right[val] -= 1; // 略過當前 j

            let target = val * 2;
            if target <= MAX_VAL {
                ans = (ans + left[target] * right[target]) % MOD;
            }

            left[val] += 1; // j 之後可作為左側
        }

        (ans % MOD) as i32
    }
}
```
